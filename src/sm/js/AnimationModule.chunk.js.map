{"version":3,"sources":["webpack:///AnimationModule.chunk.js","webpack:///./js/modules/Base.module.js?da84*******","webpack:///../~/svg.js/dist/svg.js?fc29","webpack:///./js/modules/animation/Animation.module.js","webpack:///./js/modules/animation/constants/ModuleLoader.const.js","webpack:///./js/modules/repositories/Animation.repository.js","webpack:///./js/modules/repositories/splitpoints/Animation.splitpoints.js"],"names":["webpackJsonp","22","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_classCallCheck2","_classCallCheck3","BaseModule","moduleConfig","this","node","config","identifier","prototype","init","getIdentifier","167","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","document","call","undefined","window","pathRegReplace","a","b","c","d","replace","SVG","regex","dots","array_clone","arr","clone","slice","i","length","Array","isArray","is","el","matches","selector","matchesSelector","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","camelCase","s","toLowerCase","m","g","toUpperCase","capitalize","charAt","fullHex","hex","substring","join","compToHex","comp","toString","proportionalSize","element","width","height","box","bbox","deltaTransformPoint","matrix","x","y","arrayToMatrix","e","f","parseMatrix","Matrix","ensureCentre","o","target","cx","cy","arrayToString","il","assignNewId","childNodes","SVGElement","adopt","id","eid","nodeName","fullBox","w","h","x2","y2","idFromReference","url","match","reference","supported","Doc","parser","draw","prepare","ns","xmlns","xlink","svgjs","createElementNS","createSVGRect","did","name","create","setAttribute","extend","modules","methods","key","arguments","pop","Set","inherit","invent","initializer","constructor","construct","parent","Container","instance","parentNode","Nested","Gradient","Element","type","namespace","defs","setData","JSON","parse","getAttribute","body","getElementsByTagName","documentElement","nested","size","style","poly","polyline","path","native","addEventListener","numberAndUnit","rgb","transforms","whitespace","isHex","isRgb","isCss","isBlank","isNumber","isPercent","isImage","delimiter","hyphen","pathLetters","isPathLetter","numbersWithDots","utils","map","array","block","result","push","filter","radians","Math","PI","degrees","r","filterSVGElements","nodes","defaults","attrs","fill-opacity","stroke-opacity","stroke-width","stroke-linejoin","stroke-linecap","fill","stroke","opacity","rx","ry","offset","stop-opacity","stop-color","font-size","font-family","text-anchor","Color","color","test","exec","parseInt","toHex","toRgb","brightness","morph","destination","at","pos","isColor","fallback","valueOf","lastValue","lastDestination","settle","seen","indexOf","split","string","trim","parseFloat","reverse","PointArray","toLine","x1","y1","points","len","move","isNaN","getBBox","PathArray","l","equalCommands","pathArray","j","jl","sourceArray","destinationArray","x0","y0","seg","paramCnt","M","L","H","V","C","S","Q","T","A","reduce","prev","curr","concat","shift","Number","unit","isFinite","toJSON","plus","number","minus","times","divide","to","relative","_stroke","_event","dom","attr","center","p","withData","writeDataToDom","cloneNode","add","after","remove","removeElement","addTo","put","putIn","inside","show","hide","visible","classes","hasClass","addClass","removeClass","toggleClass","get","doc","parents","svg","well","createElement","Parent","appendChild","innerHTML","firstChild","each","lines","fn","removeAttribute","keys","stringify","easing","-","<>","cos",">","sin","<","from","MorphObj","Situation","reversed","reversing","duration","delay","start","Date","finish","ease","loop","loops","animations","styles","once","FX","_target","situations","active","situation","paused","lastPos","absPos","_speed","animate","queue","timeToAbsPos","timestamp","absPosToTime","startAnimFrame","stopAnimFrame","animationFrame","requestAnimationFrame","step","bind","cancelAnimationFrame","startCurrent","initAnimations","dequeue","stop","source","initialTransformation","matrixify","clearQueue","clearCurrent","jumpToEnd","atEnd","reset","temp","atStart","isAbsPos","durDivSpd","speed","pause","last","play","progress","easeIt","wrapper","detail","off","on","_callStart","during","eased","afterAll","duringAll","method","args","ignoreTime","absPosInt","lastLoop","max","floor","Boolean","min","fire","fx","eachAt","self","apply","multiply","undo","extract","isEased","setTimeout","real","v","G","transform","num","Text","plot","leading","viewbox","ViewBox","update","Stop","Box","left","top","merge","xMin","Infinity","xMax","yMin","yMax","pts","Point","forEach","BBox","contains","Exception","topParent","Shape","clientLeft","clientTop","clientWidth","clientHeight","tbox","console","warn","rbox","RBox","getBoundingClientRect","addOffset","pageXOffset","pageYOffset","screenCTM","inverse","base","abcdef","px","py","skewX","atan2","transformedX","sqrt","transformedY","skewY","scaleX","scaleY","rotation","translate","scale","around","rotate","flip","skew","tan","createSVGMatrix","ctm","getCTM","rect","getScreenCTM","point","createSVGPoint","matrixTransform","n","attributes","nodeValue","image","Image","pattern","setAttributeNS","rebuild","Rotate","Scale","Skew","Translate","untransform","str","kv","toParent","pCtm","toDoc","Transformation","inversed","params","_undo","cssText","children","insertBefore","has","index","first","deep","removeChild","clear","hasChildNodes","lastChild","_defs","ungroup","depth","Defs","flatten","view","we","he","wm","hm","reg","offsetWidth","offsetHeight","zoom","event","listeners","handlerMap","listenerId","listener","binding","ev","_svgjsListenerId","removeEventListener","data","Event","dispatchEvent","CustomEvent","cancelable","gbox","trans","group","siblings","position","next","previous","forward","backward","front","back","before","Mask","targets","unmask","mask","maskWith","masker","ClipPath","unclip","clip","clipWith","clipper","gradient","fy","Pattern","patternUnits","getElementById","version","spof","Bare","words","text","createTextNode","Symbol","symbol","Use","file","use","Rect","Circle","circle","Ellipse","ellipse","Line","line","Polyline","Polygon","polygon","_array","morphArray","Path","load","img","_loaded","ratio","_error","src","loaded","error","_rebuild","_build","oy","nodeType","newLined","textContent","build","tspan","newLine","textPath","blankLineOffset","dy","plain","Tspan","dx","t","getComputedTextLength","TextPath","track","link","linkTo","Marker","ref","marker","sugar","prefix","extension","dmove","radius","getTotalLength","pointAt","getPointAtLength","font","members","elements","splice","set","remember","k","memory","forget","_memory","select","query","querySelectorAll","options","bubbles","createEvent","initCustomEvent","lastTime","vendors","callback","currTime","getTime","timeToCall","clearTimeout","646","_possibleConstructorReturn2","_possibleConstructorReturn3","_inherits2","_inherits3","_Base","_Base2","_AppConfigParser","_AppConfigParser2","_ModuleLoader","_ModuleLoader2","_moduleLoader","_moduleLoader2","_Animation","_Animation2","AnimationModule","_BaseModule","loadDependencies","getConfig","ANIMATIONS","648","SELECTOR","ATTRIBUTE","CONFIG_ATTRIBUTE","685","_interopRequireWildcard","newObj","hasOwnProperty","_BaseModule2","SplitPoints","AnimationRepository","_BaseModuleRepository","registerHandlerForIdentifier","burgerMenu","687","resolve","reject","require"],"mappings":"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","file":"AnimationModule.chunk.js","sourcesContent":["/*!\n * frontend\n * name: innogy-web,\n * buildDate: Tue Jul 11 2017 11:09:41 GMT+0200 (CEST),\n * packageVersion: 2.0.0\n */\n\nwebpackJsonp([10],{\n\n/***/ 22:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _classCallCheck2 = __webpack_require__(1);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Basic module class definition providing basic interface functions\n\t */\n\t\n\tvar BaseModule = function () {\n\t\n\t\t/**\n\t  * Initialize a module with a config provided by the AppConmoduleConfig\n\t  * @param {moduleConfig} moduleConfig - Config parsed from teh DOM\n\t  */\n\t\n\t\tfunction BaseModule(moduleConfig) {\n\t\t\t(0, _classCallCheck3.default)(this, BaseModule);\n\t\n\t\n\t\t\t/**\n\t   *\n\t   * @type {Object}\n\t   */\n\t\t\tthis.node = moduleConfig.node;\n\t\t\t/**\n\t   *\n\t   * @type {Object}\n\t   */\n\t\t\tthis.config = moduleConfig.config;\n\t\t\t/**\n\t   *\n\t   * @type {string}\n\t   */\n\t\t\tthis.identifier = moduleConfig.identifier;\n\t\t}\n\t\n\t\tBaseModule.prototype.init = function init() {\n\t\t\treturn this;\n\t\t};\n\t\n\t\t/**\n\t  * @return {string} returns the identifier for the module instance\n\t  */\n\t\n\t\n\t\tBaseModule.prototype.getIdentifier = function getIdentifier() {\n\t\t\treturn this.identifier;\n\t\t};\n\t\n\t\treturn BaseModule;\n\t}();\n\t\n\texports.default = BaseModule;\n\n/***/ }),\n\n/***/ 167:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t* svg.js - A lightweight library for manipulating and animating SVG.\n\t* @version 2.5.1\n\t* https://svgdotjs.github.io/\n\t*\n\t* @copyright Wout Fierens <wout@mick-wout.com>\n\t* @license MIT\n\t*\n\t* BUILT: Mon Mar 27 2017 13:30:36 GMT+0200 (Mitteleuropische Sommerzeit)\n\t*/;\n\t(function(root, factory) {\r\n\t  if (true) {\r\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(){\r\n\t      return factory(root, root.document)\r\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\t  } else if (typeof exports === 'object') {\r\n\t    module.exports = root.document ? factory(root, root.document) : function(w){ return factory(w, w.document) }\r\n\t  } else {\r\n\t    root.SVG = factory(root, root.document)\r\n\t  }\r\n\t}(typeof window !== \"undefined\" ? window : this, function(window, document) {\r\n\t\r\n\t// The main wrapping element\r\n\tvar SVG = this.SVG = function(element) {\r\n\t  if (SVG.supported) {\r\n\t    element = new SVG.Doc(element)\r\n\t\r\n\t    if(!SVG.parser.draw)\r\n\t      SVG.prepare()\r\n\t\r\n\t    return element\r\n\t  }\r\n\t}\r\n\t\r\n\t// Default namespaces\r\n\tSVG.ns    = 'http://www.w3.org/2000/svg'\r\n\tSVG.xmlns = 'http://www.w3.org/2000/xmlns/'\r\n\tSVG.xlink = 'http://www.w3.org/1999/xlink'\r\n\tSVG.svgjs = 'http://svgjs.com/svgjs'\r\n\t\r\n\t// Svg support test\r\n\tSVG.supported = (function() {\r\n\t  return !! document.createElementNS &&\r\n\t         !! document.createElementNS(SVG.ns,'svg').createSVGRect\r\n\t})()\r\n\t\r\n\t// Don't bother to continue if SVG is not supported\r\n\tif (!SVG.supported) return false\r\n\t\r\n\t// Element id sequence\r\n\tSVG.did  = 1000\r\n\t\r\n\t// Get next named element id\r\n\tSVG.eid = function(name) {\r\n\t  return 'Svgjs' + capitalize(name) + (SVG.did++)\r\n\t}\r\n\t\r\n\t// Method for element creation\r\n\tSVG.create = function(name) {\r\n\t  // create element\r\n\t  var element = document.createElementNS(this.ns, name)\r\n\t\r\n\t  // apply unique id\r\n\t  element.setAttribute('id', this.eid(name))\r\n\t\r\n\t  return element\r\n\t}\r\n\t\r\n\t// Method for extending objects\r\n\tSVG.extend = function() {\r\n\t  var modules, methods, key, i\r\n\t\r\n\t  // Get list of modules\r\n\t  modules = [].slice.call(arguments)\r\n\t\r\n\t  // Get object with extensions\r\n\t  methods = modules.pop()\r\n\t\r\n\t  for (i = modules.length - 1; i >= 0; i--)\r\n\t    if (modules[i])\r\n\t      for (key in methods)\r\n\t        modules[i].prototype[key] = methods[key]\r\n\t\r\n\t  // Make sure SVG.Set inherits any newly added methods\r\n\t  if (SVG.Set && SVG.Set.inherit)\r\n\t    SVG.Set.inherit()\r\n\t}\r\n\t\r\n\t// Invent new element\r\n\tSVG.invent = function(config) {\r\n\t  // Create element initializer\r\n\t  var initializer = typeof config.create == 'function' ?\r\n\t    config.create :\r\n\t    function() {\r\n\t      this.constructor.call(this, SVG.create(config.create))\r\n\t    }\r\n\t\r\n\t  // Inherit prototype\r\n\t  if (config.inherit)\r\n\t    initializer.prototype = new config.inherit\r\n\t\r\n\t  // Extend with methods\r\n\t  if (config.extend)\r\n\t    SVG.extend(initializer, config.extend)\r\n\t\r\n\t  // Attach construct method to parent\r\n\t  if (config.construct)\r\n\t    SVG.extend(config.parent || SVG.Container, config.construct)\r\n\t\r\n\t  return initializer\r\n\t}\r\n\t\r\n\t// Adopt existing svg elements\r\n\tSVG.adopt = function(node) {\r\n\t  // check for presence of node\r\n\t  if (!node) return null\r\n\t\r\n\t  // make sure a node isn't already adopted\r\n\t  if (node.instance) return node.instance\r\n\t\r\n\t  // initialize variables\r\n\t  var element\r\n\t\r\n\t  // adopt with element-specific settings\r\n\t  if (node.nodeName == 'svg')\r\n\t    element = node.parentNode instanceof window.SVGElement ? new SVG.Nested : new SVG.Doc\r\n\t  else if (node.nodeName == 'linearGradient')\r\n\t    element = new SVG.Gradient('linear')\r\n\t  else if (node.nodeName == 'radialGradient')\r\n\t    element = new SVG.Gradient('radial')\r\n\t  else if (SVG[capitalize(node.nodeName)])\r\n\t    element = new SVG[capitalize(node.nodeName)]\r\n\t  else\r\n\t    element = new SVG.Element(node)\r\n\t\r\n\t  // ensure references\r\n\t  element.type  = node.nodeName\r\n\t  element.node  = node\r\n\t  node.instance = element\r\n\t\r\n\t  // SVG.Class specific preparations\r\n\t  if (element instanceof SVG.Doc)\r\n\t    element.namespace().defs()\r\n\t\r\n\t  // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\r\n\t  element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {})\r\n\t\r\n\t  return element\r\n\t}\r\n\t\r\n\t// Initialize parsing element\r\n\tSVG.prepare = function() {\r\n\t  // Select document body and create invisible svg element\r\n\t  var body = document.getElementsByTagName('body')[0]\r\n\t    , draw = (body ? new SVG.Doc(body) :  SVG.adopt(document.documentElement).nested()).size(2, 0)\r\n\t\r\n\t  // Create parser object\r\n\t  SVG.parser = {\r\n\t    body: body || document.documentElement\r\n\t  , draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden')\r\n\t  , poly: draw.polyline().node\r\n\t  , path: draw.path().node\r\n\t  , native: SVG.create('svg')\r\n\t  }\r\n\t}\r\n\t\r\n\tSVG.parser = {\r\n\t  native: SVG.create('svg')\r\n\t}\r\n\t\r\n\tdocument.addEventListener('DOMContentLoaded', function() {\r\n\t  if(!SVG.parser.draw)\r\n\t    SVG.prepare()\r\n\t}, false)\r\n\t\n\t// Storage for regular expressions\r\n\tSVG.regex = {\r\n\t  // Parse unit value\r\n\t  numberAndUnit:    /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i\r\n\t\r\n\t  // Parse hex value\r\n\t, hex:              /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i\r\n\t\r\n\t  // Parse rgb value\r\n\t, rgb:              /rgb\\((\\d+),(\\d+),(\\d+)\\)/\r\n\t\r\n\t  // Parse reference id\r\n\t, reference:        /#([a-z0-9\\-_]+)/i\r\n\t\r\n\t  // splits a transformation chain\r\n\t, transforms:       /\\)\\s*,?\\s*/\r\n\t\r\n\t  // Whitespace\r\n\t, whitespace:       /\\s/g\r\n\t\r\n\t  // Test hex value\r\n\t, isHex:            /^#[a-f0-9]{3,6}$/i\r\n\t\r\n\t  // Test rgb value\r\n\t, isRgb:            /^rgb\\(/\r\n\t\r\n\t  // Test css declaration\r\n\t, isCss:            /[^:]+:[^;]+;?/\r\n\t\r\n\t  // Test for blank string\r\n\t, isBlank:          /^(\\s+)?$/\r\n\t\r\n\t  // Test for numeric string\r\n\t, isNumber:         /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i\r\n\t\r\n\t  // Test for percent value\r\n\t, isPercent:        /^-?[\\d\\.]+%$/\r\n\t\r\n\t  // Test for image url\r\n\t, isImage:          /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i\r\n\t\r\n\t  // split at whitespace and comma\r\n\t, delimiter:        /[\\s,]+/\r\n\t\r\n\t  // The following regex are used to parse the d attribute of a path\r\n\t\r\n\t  // Matches all hyphens which are not after an exponent\r\n\t, hyphen:           /([^e])\\-/gi\r\n\t\r\n\t  // Replaces and tests for all path letters\r\n\t, pathLetters:      /[MLHVCSQTAZ]/gi\r\n\t\r\n\t  // yes we need this one, too\r\n\t, isPathLetter:     /[MLHVCSQTAZ]/i\r\n\t\r\n\t  // matches 0.154.23.45\r\n\t, numbersWithDots:  /((\\d?\\.\\d+(?:e[+-]?\\d+)?)((?:\\.\\d+(?:e[+-]?\\d+)?)+))+/gi\r\n\t\r\n\t  // matches .\r\n\t, dots:             /\\./g\r\n\t}\r\n\t\n\tSVG.utils = {\r\n\t  // Map function\r\n\t  map: function(array, block) {\r\n\t    var i\r\n\t      , il = array.length\r\n\t      , result = []\r\n\t\r\n\t    for (i = 0; i < il; i++)\r\n\t      result.push(block(array[i]))\r\n\t\r\n\t    return result\r\n\t  }\r\n\t\r\n\t  // Filter function\r\n\t, filter: function(array, block) {\r\n\t    var i\r\n\t      , il = array.length\r\n\t      , result = []\r\n\t\r\n\t    for (i = 0; i < il; i++)\r\n\t      if (block(array[i]))\r\n\t        result.push(array[i])\r\n\t\r\n\t    return result\r\n\t  }\r\n\t\r\n\t  // Degrees to radians\r\n\t, radians: function(d) {\r\n\t    return d % 360 * Math.PI / 180\r\n\t  }\r\n\t\r\n\t  // Radians to degrees\r\n\t, degrees: function(r) {\r\n\t    return r * 180 / Math.PI % 360\r\n\t  }\r\n\t\r\n\t, filterSVGElements: function(nodes) {\r\n\t    return this.filter( nodes, function(el) { return el instanceof window.SVGElement })\r\n\t  }\r\n\t\r\n\t}\n\t\r\n\tSVG.defaults = {\r\n\t  // Default attribute values\r\n\t  attrs: {\r\n\t    // fill and stroke\r\n\t    'fill-opacity':     1\r\n\t  , 'stroke-opacity':   1\r\n\t  , 'stroke-width':     0\r\n\t  , 'stroke-linejoin':  'miter'\r\n\t  , 'stroke-linecap':   'butt'\r\n\t  , fill:               '#000000'\r\n\t  , stroke:             '#000000'\r\n\t  , opacity:            1\r\n\t    // position\r\n\t  , x:                  0\r\n\t  , y:                  0\r\n\t  , cx:                 0\r\n\t  , cy:                 0\r\n\t    // size\r\n\t  , width:              0\r\n\t  , height:             0\r\n\t    // radius\r\n\t  , r:                  0\r\n\t  , rx:                 0\r\n\t  , ry:                 0\r\n\t    // gradient\r\n\t  , offset:             0\r\n\t  , 'stop-opacity':     1\r\n\t  , 'stop-color':       '#000000'\r\n\t    // text\r\n\t  , 'font-size':        16\r\n\t  , 'font-family':      'Helvetica, Arial, sans-serif'\r\n\t  , 'text-anchor':      'start'\r\n\t  }\r\n\t\r\n\t}\n\t// Module for color convertions\r\n\tSVG.Color = function(color) {\r\n\t  var match\r\n\t\r\n\t  // initialize defaults\r\n\t  this.r = 0\r\n\t  this.g = 0\r\n\t  this.b = 0\r\n\t\r\n\t  if(!color) return\r\n\t\r\n\t  // parse color\r\n\t  if (typeof color === 'string') {\r\n\t    if (SVG.regex.isRgb.test(color)) {\r\n\t      // get rgb values\r\n\t      match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace,''))\r\n\t\r\n\t      // parse numeric values\r\n\t      this.r = parseInt(match[1])\r\n\t      this.g = parseInt(match[2])\r\n\t      this.b = parseInt(match[3])\r\n\t\r\n\t    } else if (SVG.regex.isHex.test(color)) {\r\n\t      // get hex values\r\n\t      match = SVG.regex.hex.exec(fullHex(color))\r\n\t\r\n\t      // parse numeric values\r\n\t      this.r = parseInt(match[1], 16)\r\n\t      this.g = parseInt(match[2], 16)\r\n\t      this.b = parseInt(match[3], 16)\r\n\t\r\n\t    }\r\n\t\r\n\t  } else if (typeof color === 'object') {\r\n\t    this.r = color.r\r\n\t    this.g = color.g\r\n\t    this.b = color.b\r\n\t\r\n\t  }\r\n\t\r\n\t}\r\n\t\r\n\tSVG.extend(SVG.Color, {\r\n\t  // Default to hex conversion\r\n\t  toString: function() {\r\n\t    return this.toHex()\r\n\t  }\r\n\t  // Build hex value\r\n\t, toHex: function() {\r\n\t    return '#'\r\n\t      + compToHex(this.r)\r\n\t      + compToHex(this.g)\r\n\t      + compToHex(this.b)\r\n\t  }\r\n\t  // Build rgb value\r\n\t, toRgb: function() {\r\n\t    return 'rgb(' + [this.r, this.g, this.b].join() + ')'\r\n\t  }\r\n\t  // Calculate true brightness\r\n\t, brightness: function() {\r\n\t    return (this.r / 255 * 0.30)\r\n\t         + (this.g / 255 * 0.59)\r\n\t         + (this.b / 255 * 0.11)\r\n\t  }\r\n\t  // Make color morphable\r\n\t, morph: function(color) {\r\n\t    this.destination = new SVG.Color(color)\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Get morphed color at given position\r\n\t, at: function(pos) {\r\n\t    // make sure a destination is defined\r\n\t    if (!this.destination) return this\r\n\t\r\n\t    // normalise pos\r\n\t    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos\r\n\t\r\n\t    // generate morphed color\r\n\t    return new SVG.Color({\r\n\t      r: ~~(this.r + (this.destination.r - this.r) * pos)\r\n\t    , g: ~~(this.g + (this.destination.g - this.g) * pos)\r\n\t    , b: ~~(this.b + (this.destination.b - this.b) * pos)\r\n\t    })\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\t// Testers\r\n\t\r\n\t// Test if given value is a color string\r\n\tSVG.Color.test = function(color) {\r\n\t  color += ''\r\n\t  return SVG.regex.isHex.test(color)\r\n\t      || SVG.regex.isRgb.test(color)\r\n\t}\r\n\t\r\n\t// Test if given value is a rgb object\r\n\tSVG.Color.isRgb = function(color) {\r\n\t  return color && typeof color.r == 'number'\r\n\t               && typeof color.g == 'number'\r\n\t               && typeof color.b == 'number'\r\n\t}\r\n\t\r\n\t// Test if given value is a color\r\n\tSVG.Color.isColor = function(color) {\r\n\t  return SVG.Color.isRgb(color) || SVG.Color.test(color)\r\n\t}\n\t// Module for array conversion\r\n\tSVG.Array = function(array, fallback) {\r\n\t  array = (array || []).valueOf()\r\n\t\r\n\t  // if array is empty and fallback is provided, use fallback\r\n\t  if (array.length == 0 && fallback)\r\n\t    array = fallback.valueOf()\r\n\t\r\n\t  // parse array\r\n\t  this.value = this.parse(array)\r\n\t}\r\n\t\r\n\tSVG.extend(SVG.Array, {\r\n\t  // Make array morphable\r\n\t  morph: function(array) {\r\n\t    this.destination = this.parse(array)\r\n\t\r\n\t    // normalize length of arrays\r\n\t    if (this.value.length != this.destination.length) {\r\n\t      var lastValue       = this.value[this.value.length - 1]\r\n\t        , lastDestination = this.destination[this.destination.length - 1]\r\n\t\r\n\t      while(this.value.length > this.destination.length)\r\n\t        this.destination.push(lastDestination)\r\n\t      while(this.value.length < this.destination.length)\r\n\t        this.value.push(lastValue)\r\n\t    }\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Clean up any duplicate points\r\n\t, settle: function() {\r\n\t    // find all unique values\r\n\t    for (var i = 0, il = this.value.length, seen = []; i < il; i++)\r\n\t      if (seen.indexOf(this.value[i]) == -1)\r\n\t        seen.push(this.value[i])\r\n\t\r\n\t    // set new value\r\n\t    return this.value = seen\r\n\t  }\r\n\t  // Get morphed array at given position\r\n\t, at: function(pos) {\r\n\t    // make sure a destination is defined\r\n\t    if (!this.destination) return this\r\n\t\r\n\t    // generate morphed array\r\n\t    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n\t      array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)\r\n\t\r\n\t    return new SVG.Array(array)\r\n\t  }\r\n\t  // Convert array to string\r\n\t, toString: function() {\r\n\t    return this.value.join(' ')\r\n\t  }\r\n\t  // Real value\r\n\t, valueOf: function() {\r\n\t    return this.value\r\n\t  }\r\n\t  // Parse whitespace separated string\r\n\t, parse: function(array) {\r\n\t    array = array.valueOf()\r\n\t\r\n\t    // if already is an array, no need to parse it\r\n\t    if (Array.isArray(array)) return array\r\n\t\r\n\t    return this.split(array)\r\n\t  }\r\n\t  // Strip unnecessary whitespace\r\n\t, split: function(string) {\r\n\t    return string.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n\t  }\r\n\t  // Reverse array\r\n\t, reverse: function() {\r\n\t    this.value.reverse()\r\n\t\r\n\t    return this\r\n\t  }\r\n\t, clone: function() {\r\n\t    var clone = new this.constructor()\r\n\t    clone.value = array_clone(this.value)\r\n\t    return clone\r\n\t  }\r\n\t})\n\t// Poly points array\r\n\tSVG.PointArray = function(array, fallback) {\r\n\t  SVG.Array.call(this, array, fallback || [[0,0]])\r\n\t}\r\n\t\r\n\t// Inherit from SVG.Array\r\n\tSVG.PointArray.prototype = new SVG.Array\r\n\tSVG.PointArray.prototype.constructor = SVG.PointArray\r\n\t\r\n\tSVG.extend(SVG.PointArray, {\r\n\t  // Convert array to string\r\n\t  toString: function() {\r\n\t    // convert to a poly point string\r\n\t    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n\t      array.push(this.value[i].join(','))\r\n\t\r\n\t    return array.join(' ')\r\n\t  }\r\n\t  // Convert array to line object\r\n\t, toLine: function() {\r\n\t    return {\r\n\t      x1: this.value[0][0]\r\n\t    , y1: this.value[0][1]\r\n\t    , x2: this.value[1][0]\r\n\t    , y2: this.value[1][1]\r\n\t    }\r\n\t  }\r\n\t  // Get morphed array at given position\r\n\t, at: function(pos) {\r\n\t    // make sure a destination is defined\r\n\t    if (!this.destination) return this\r\n\t\r\n\t    // generate morphed point string\r\n\t    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n\t      array.push([\r\n\t        this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos\r\n\t      , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos\r\n\t      ])\r\n\t\r\n\t    return new SVG.PointArray(array)\r\n\t  }\r\n\t  // Parse point string and flat array\r\n\t, parse: function(array) {\r\n\t    var points = []\r\n\t\r\n\t    array = array.valueOf()\r\n\t\r\n\t    // if it is an array\r\n\t    if (Array.isArray(array)) {\r\n\t      // and it is not flat, there is no need to parse it\r\n\t      if(Array.isArray(array[0])) {\r\n\t        return array\r\n\t      }\r\n\t    } else { // Else, it is considered as a string\r\n\t      // parse points\r\n\t      array = array.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n\t    }\r\n\t\r\n\t    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\r\n\t    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\r\n\t    if (array.length % 2 !== 0) array.pop()\r\n\t\r\n\t    // wrap points in two-tuples and parse points as floats\r\n\t    for(var i = 0, len = array.length; i < len; i = i + 2)\r\n\t      points.push([ array[i], array[i+1] ])\r\n\t\r\n\t    return points\r\n\t  }\r\n\t  // Move point string\r\n\t, move: function(x, y) {\r\n\t    var box = this.bbox()\r\n\t\r\n\t    // get relative offset\r\n\t    x -= box.x\r\n\t    y -= box.y\r\n\t\r\n\t    // move every point\r\n\t    if (!isNaN(x) && !isNaN(y))\r\n\t      for (var i = this.value.length - 1; i >= 0; i--)\r\n\t        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Resize poly string\r\n\t, size: function(width, height) {\r\n\t    var i, box = this.bbox()\r\n\t\r\n\t    // recalculate position of all points according to new size\r\n\t    for (i = this.value.length - 1; i >= 0; i--) {\r\n\t      if(box.width) this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x\r\n\t      if(box.height) this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n\t    }\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Get bounding box of points\r\n\t, bbox: function() {\r\n\t    SVG.parser.poly.setAttribute('points', this.toString())\r\n\t\r\n\t    return SVG.parser.poly.getBBox()\r\n\t  }\r\n\t})\r\n\t\n\t// Path points array\r\n\tSVG.PathArray = function(array, fallback) {\r\n\t  SVG.Array.call(this, array, fallback || [['M', 0, 0]])\r\n\t}\r\n\t\r\n\t// Inherit from SVG.Array\r\n\tSVG.PathArray.prototype = new SVG.Array\r\n\tSVG.PathArray.prototype.constructor = SVG.PathArray\r\n\t\r\n\tSVG.extend(SVG.PathArray, {\r\n\t  // Convert array to string\r\n\t  toString: function() {\r\n\t    return arrayToString(this.value)\r\n\t  }\r\n\t  // Move path string\r\n\t, move: function(x, y) {\r\n\t    // get bounding box of current situation\r\n\t    var box = this.bbox()\r\n\t\r\n\t    // get relative offset\r\n\t    x -= box.x\r\n\t    y -= box.y\r\n\t\r\n\t    if (!isNaN(x) && !isNaN(y)) {\r\n\t      // move every point\r\n\t      for (var l, i = this.value.length - 1; i >= 0; i--) {\r\n\t        l = this.value[i][0]\r\n\t\r\n\t        if (l == 'M' || l == 'L' || l == 'T')  {\r\n\t          this.value[i][1] += x\r\n\t          this.value[i][2] += y\r\n\t\r\n\t        } else if (l == 'H')  {\r\n\t          this.value[i][1] += x\r\n\t\r\n\t        } else if (l == 'V')  {\r\n\t          this.value[i][1] += y\r\n\t\r\n\t        } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n\t          this.value[i][1] += x\r\n\t          this.value[i][2] += y\r\n\t          this.value[i][3] += x\r\n\t          this.value[i][4] += y\r\n\t\r\n\t          if (l == 'C')  {\r\n\t            this.value[i][5] += x\r\n\t            this.value[i][6] += y\r\n\t          }\r\n\t\r\n\t        } else if (l == 'A')  {\r\n\t          this.value[i][6] += x\r\n\t          this.value[i][7] += y\r\n\t        }\r\n\t\r\n\t      }\r\n\t    }\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Resize path string\r\n\t, size: function(width, height) {\r\n\t    // get bounding box of current situation\r\n\t    var i, l, box = this.bbox()\r\n\t\r\n\t    // recalculate position of all points according to new size\r\n\t    for (i = this.value.length - 1; i >= 0; i--) {\r\n\t      l = this.value[i][0]\r\n\t\r\n\t      if (l == 'M' || l == 'L' || l == 'T')  {\r\n\t        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n\t        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n\t\r\n\t      } else if (l == 'H')  {\r\n\t        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n\t\r\n\t      } else if (l == 'V')  {\r\n\t        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n\t\r\n\t      } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n\t        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n\t        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n\t        this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x\r\n\t        this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y\r\n\t\r\n\t        if (l == 'C')  {\r\n\t          this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x\r\n\t          this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y\r\n\t        }\r\n\t\r\n\t      } else if (l == 'A')  {\r\n\t        // resize radii\r\n\t        this.value[i][1] = (this.value[i][1] * width)  / box.width\r\n\t        this.value[i][2] = (this.value[i][2] * height) / box.height\r\n\t\r\n\t        // move position values\r\n\t        this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x\r\n\t        this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y\r\n\t      }\r\n\t\r\n\t    }\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Test if the passed path array use the same path data commands as this path array\r\n\t, equalCommands: function(pathArray) {\r\n\t    var i, il, equalCommands\r\n\t\r\n\t    pathArray = new SVG.PathArray(pathArray)\r\n\t\r\n\t    equalCommands = this.value.length === pathArray.value.length\r\n\t    for(i = 0, il = this.value.length; equalCommands && i < il; i++) {\r\n\t      equalCommands = this.value[i][0] === pathArray.value[i][0]\r\n\t    }\r\n\t\r\n\t    return equalCommands\r\n\t  }\r\n\t  // Make path array morphable\r\n\t, morph: function(pathArray) {\r\n\t    pathArray = new SVG.PathArray(pathArray)\r\n\t\r\n\t    if(this.equalCommands(pathArray)) {\r\n\t      this.destination = pathArray\r\n\t    } else {\r\n\t      this.destination = null\r\n\t    }\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Get morphed path array at given position\r\n\t, at: function(pos) {\r\n\t    // make sure a destination is defined\r\n\t    if (!this.destination) return this\r\n\t\r\n\t    var sourceArray = this.value\r\n\t      , destinationArray = this.destination.value\r\n\t      , array = [], pathArray = new SVG.PathArray()\r\n\t      , i, il, j, jl\r\n\t\r\n\t    // Animate has specified in the SVG spec\r\n\t    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\r\n\t    for (i = 0, il = sourceArray.length; i < il; i++) {\r\n\t      array[i] = [sourceArray[i][0]]\r\n\t      for(j = 1, jl = sourceArray[i].length; j < jl; j++) {\r\n\t        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos\r\n\t      }\r\n\t      // For the two flags of the elliptical arc command, the SVG spec say:\r\n\t      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\r\n\t      // Elliptical arc command as an array followed by corresponding indexes:\r\n\t      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\r\n\t      //   0    1   2        3                 4             5      6  7\r\n\t      if(array[i][0] === 'A') {\r\n\t        array[i][4] = +(array[i][4] != 0)\r\n\t        array[i][5] = +(array[i][5] != 0)\r\n\t      }\r\n\t    }\r\n\t\r\n\t    // Directly modify the value of a path array, this is done this way for performance\r\n\t    pathArray.value = array\r\n\t    return pathArray\r\n\t  }\r\n\t  // Absolutize and parse path to array\r\n\t, parse: function(array) {\r\n\t    // if it's already a patharray, no need to parse it\r\n\t    if (array instanceof SVG.PathArray) return array.valueOf()\r\n\t\r\n\t    // prepare for parsing\r\n\t    var i, x0, y0, s, seg, arr\r\n\t      , x = 0\r\n\t      , y = 0\r\n\t      , paramCnt = { 'M':2, 'L':2, 'H':1, 'V':1, 'C':6, 'S':4, 'Q':4, 'T':2, 'A':7 }\r\n\t\r\n\t    if(typeof array == 'string'){\r\n\t\r\n\t      array = array\r\n\t        .replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\r\n\t        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\r\n\t        .replace(SVG.regex.hyphen, '$1 -')      // add space before hyphen\r\n\t        .trim()                                 // trim\r\n\t        .split(SVG.regex.delimiter)   // split into array\r\n\t\r\n\t    }else{\r\n\t      array = array.reduce(function(prev, curr){\r\n\t        return [].concat.call(prev, curr)\r\n\t      }, [])\r\n\t    }\r\n\t\r\n\t    // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\r\n\t\r\n\t    var arr = []\r\n\t\r\n\t    do{\r\n\t\r\n\t      // Test if we have a path letter\r\n\t      if(SVG.regex.isPathLetter.test(array[0])){\r\n\t        s = array[0]\r\n\t        array.shift()\r\n\t      // If last letter was a move command and we got no new, it defaults to [L]ine\r\n\t      }else if(s == 'M'){\r\n\t        s = 'L'\r\n\t      }else if(s == 'm'){\r\n\t        s = 'l'\r\n\t      }\r\n\t\r\n\t      // add path letter as first element\r\n\t      seg = [s.toUpperCase()]\r\n\t\r\n\t      // push all necessary parameters to segment\r\n\t      for(i = 0; i < paramCnt[seg[0]]; ++i){\r\n\t        seg.push(parseFloat(array.shift()))\r\n\t      }\r\n\t\r\n\t      // upper case\r\n\t      if(s == seg[0]){\r\n\t\r\n\t        if(s == 'M' || s == 'L' || s == 'C' || s == 'Q' || s == 'S' || s == 'T'){\r\n\t          x = seg[paramCnt[seg[0]]-1]\r\n\t          y = seg[paramCnt[seg[0]]]\r\n\t        }else if(s == 'V'){\r\n\t          y = seg[1]\r\n\t        }else if(s == 'H'){\r\n\t          x = seg[1]\r\n\t        }else if(s == 'A'){\r\n\t          x = seg[6]\r\n\t          y = seg[7]\r\n\t        }\r\n\t\r\n\t      // lower case\r\n\t      }else{\r\n\t\r\n\t        // convert relative to absolute values\r\n\t        if(s == 'm' || s == 'l' || s == 'c' || s == 's' || s == 'q' || s == 't'){\r\n\t\r\n\t          seg[1] += x\r\n\t          seg[2] += y\r\n\t\r\n\t          if(seg[3] != null){\r\n\t            seg[3] += x\r\n\t            seg[4] += y\r\n\t          }\r\n\t\r\n\t          if(seg[5] != null){\r\n\t            seg[5] += x\r\n\t            seg[6] += y\r\n\t          }\r\n\t\r\n\t          // move pointer\r\n\t          x = seg[paramCnt[seg[0]]-1]\r\n\t          y = seg[paramCnt[seg[0]]]\r\n\t\r\n\t        }else if(s == 'v'){\r\n\t          seg[1] += y\r\n\t          y = seg[1]\r\n\t        }else if(s == 'h'){\r\n\t          seg[1] += x\r\n\t          x = seg[1]\r\n\t        }else if(s == 'a'){\r\n\t          seg[6] += x\r\n\t          seg[7] += y\r\n\t          x = seg[6]\r\n\t          y = seg[7]\r\n\t        }\r\n\t\r\n\t      }\r\n\t\r\n\t      if(seg[0] == 'M'){\r\n\t        x0 = x\r\n\t        y0 = y\r\n\t      }\r\n\t\r\n\t      if(seg[0] == 'Z'){\r\n\t        x = x0\r\n\t        y = y0\r\n\t      }\r\n\t\r\n\t      arr.push(seg)\r\n\t\r\n\t    }while(array.length)\r\n\t\r\n\t    return arr\r\n\t\r\n\t  }\r\n\t  // Get bounding box of path\r\n\t, bbox: function() {\r\n\t    SVG.parser.path.setAttribute('d', this.toString())\r\n\t\r\n\t    return SVG.parser.path.getBBox()\r\n\t  }\r\n\t\r\n\t})\r\n\t\n\t// Module for unit convertions\r\n\tSVG.Number = SVG.invent({\r\n\t  // Initialize\r\n\t  create: function(value, unit) {\r\n\t    // initialize defaults\r\n\t    this.value = 0\r\n\t    this.unit  = unit || ''\r\n\t\r\n\t    // parse value\r\n\t    if (typeof value === 'number') {\r\n\t      // ensure a valid numeric value\r\n\t      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value\r\n\t\r\n\t    } else if (typeof value === 'string') {\r\n\t      unit = value.match(SVG.regex.numberAndUnit)\r\n\t\r\n\t      if (unit) {\r\n\t        // make value numeric\r\n\t        this.value = parseFloat(unit[1])\r\n\t\r\n\t        // normalize\r\n\t        if (unit[5] == '%')\r\n\t          this.value /= 100\r\n\t        else if (unit[5] == 's')\r\n\t          this.value *= 1000\r\n\t\r\n\t        // store unit\r\n\t        this.unit = unit[5]\r\n\t      }\r\n\t\r\n\t    } else {\r\n\t      if (value instanceof SVG.Number) {\r\n\t        this.value = value.valueOf()\r\n\t        this.unit  = value.unit\r\n\t      }\r\n\t    }\r\n\t\r\n\t  }\r\n\t  // Add methods\r\n\t, extend: {\r\n\t    // Stringalize\r\n\t    toString: function() {\r\n\t      return (\r\n\t        this.unit == '%' ?\r\n\t          ~~(this.value * 1e8) / 1e6:\r\n\t        this.unit == 's' ?\r\n\t          this.value / 1e3 :\r\n\t          this.value\r\n\t      ) + this.unit\r\n\t    }\r\n\t  , toJSON: function() {\r\n\t      return this.toString()\r\n\t    }\r\n\t  , // Convert to primitive\r\n\t    valueOf: function() {\r\n\t      return this.value\r\n\t    }\r\n\t    // Add number\r\n\t  , plus: function(number) {\r\n\t      number = new SVG.Number(number)\r\n\t      return new SVG.Number(this + number, this.unit || number.unit)\r\n\t    }\r\n\t    // Subtract number\r\n\t  , minus: function(number) {\r\n\t      number = new SVG.Number(number)\r\n\t      return new SVG.Number(this - number, this.unit || number.unit)\r\n\t    }\r\n\t    // Multiply number\r\n\t  , times: function(number) {\r\n\t      number = new SVG.Number(number)\r\n\t      return new SVG.Number(this * number, this.unit || number.unit)\r\n\t    }\r\n\t    // Divide number\r\n\t  , divide: function(number) {\r\n\t      number = new SVG.Number(number)\r\n\t      return new SVG.Number(this / number, this.unit || number.unit)\r\n\t    }\r\n\t    // Convert to different unit\r\n\t  , to: function(unit) {\r\n\t      var number = new SVG.Number(this)\r\n\t\r\n\t      if (typeof unit === 'string')\r\n\t        number.unit = unit\r\n\t\r\n\t      return number\r\n\t    }\r\n\t    // Make number morphable\r\n\t  , morph: function(number) {\r\n\t      this.destination = new SVG.Number(number)\r\n\t\r\n\t      if(number.relative) {\r\n\t        this.destination.value += this.value\r\n\t      }\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Get morphed number at given position\r\n\t  , at: function(pos) {\r\n\t      // Make sure a destination is defined\r\n\t      if (!this.destination) return this\r\n\t\r\n\t      // Generate new morphed number\r\n\t      return new SVG.Number(this.destination)\r\n\t          .minus(this)\r\n\t          .times(pos)\r\n\t          .plus(this)\r\n\t    }\r\n\t\r\n\t  }\r\n\t})\r\n\t\n\t\r\n\tSVG.Element = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: function(node) {\r\n\t    // make stroke value accessible dynamically\r\n\t    this._stroke = SVG.defaults.attrs.stroke\r\n\t    this._event = null\r\n\t\r\n\t    // initialize data object\r\n\t    this.dom = {}\r\n\t\r\n\t    // create circular reference\r\n\t    if (this.node = node) {\r\n\t      this.type = node.nodeName\r\n\t      this.node.instance = this\r\n\t\r\n\t      // store current attribute value\r\n\t      this._stroke = node.getAttribute('stroke') || this._stroke\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Move over x-axis\r\n\t    x: function(x) {\r\n\t      return this.attr('x', x)\r\n\t    }\r\n\t    // Move over y-axis\r\n\t  , y: function(y) {\r\n\t      return this.attr('y', y)\r\n\t    }\r\n\t    // Move by center over x-axis\r\n\t  , cx: function(x) {\r\n\t      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)\r\n\t    }\r\n\t    // Move by center over y-axis\r\n\t  , cy: function(y) {\r\n\t      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)\r\n\t    }\r\n\t    // Move element to given x and y values\r\n\t  , move: function(x, y) {\r\n\t      return this.x(x).y(y)\r\n\t    }\r\n\t    // Move element by its center\r\n\t  , center: function(x, y) {\r\n\t      return this.cx(x).cy(y)\r\n\t    }\r\n\t    // Set width of element\r\n\t  , width: function(width) {\r\n\t      return this.attr('width', width)\r\n\t    }\r\n\t    // Set height of element\r\n\t  , height: function(height) {\r\n\t      return this.attr('height', height)\r\n\t    }\r\n\t    // Set element size to given width and height\r\n\t  , size: function(width, height) {\r\n\t      var p = proportionalSize(this, width, height)\r\n\t\r\n\t      return this\r\n\t        .width(new SVG.Number(p.width))\r\n\t        .height(new SVG.Number(p.height))\r\n\t    }\r\n\t    // Clone element\r\n\t  , clone: function(parent, withData) {\r\n\t      // write dom data to the dom so the clone can pickup the data\r\n\t      this.writeDataToDom()\r\n\t\r\n\t      // clone element and assign new id\r\n\t      var clone = assignNewId(this.node.cloneNode(true))\r\n\t\r\n\t      // insert the clone in the given parent or after myself\r\n\t      if(parent) parent.add(clone)\r\n\t      else this.after(clone)\r\n\t\r\n\t      return clone\r\n\t    }\r\n\t    // Remove element\r\n\t  , remove: function() {\r\n\t      if (this.parent())\r\n\t        this.parent().removeElement(this)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Replace element\r\n\t  , replace: function(element) {\r\n\t      this.after(element).remove()\r\n\t\r\n\t      return element\r\n\t    }\r\n\t    // Add element to given container and return self\r\n\t  , addTo: function(parent) {\r\n\t      return parent.put(this)\r\n\t    }\r\n\t    // Add element to given container and return container\r\n\t  , putIn: function(parent) {\r\n\t      return parent.add(this)\r\n\t    }\r\n\t    // Get / set id\r\n\t  , id: function(id) {\r\n\t      return this.attr('id', id)\r\n\t    }\r\n\t    // Checks whether the given point inside the bounding box of the element\r\n\t  , inside: function(x, y) {\r\n\t      var box = this.bbox()\r\n\t\r\n\t      return x > box.x\r\n\t          && y > box.y\r\n\t          && x < box.x + box.width\r\n\t          && y < box.y + box.height\r\n\t    }\r\n\t    // Show element\r\n\t  , show: function() {\r\n\t      return this.style('display', '')\r\n\t    }\r\n\t    // Hide element\r\n\t  , hide: function() {\r\n\t      return this.style('display', 'none')\r\n\t    }\r\n\t    // Is element visible?\r\n\t  , visible: function() {\r\n\t      return this.style('display') != 'none'\r\n\t    }\r\n\t    // Return id on string conversion\r\n\t  , toString: function() {\r\n\t      return this.attr('id')\r\n\t    }\r\n\t    // Return array of classes on the node\r\n\t  , classes: function() {\r\n\t      var attr = this.attr('class')\r\n\t\r\n\t      return attr == null ? [] : attr.trim().split(SVG.regex.delimiter)\r\n\t    }\r\n\t    // Return true if class exists on the node, false otherwise\r\n\t  , hasClass: function(name) {\r\n\t      return this.classes().indexOf(name) != -1\r\n\t    }\r\n\t    // Add class to the node\r\n\t  , addClass: function(name) {\r\n\t      if (!this.hasClass(name)) {\r\n\t        var array = this.classes()\r\n\t        array.push(name)\r\n\t        this.attr('class', array.join(' '))\r\n\t      }\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Remove class from the node\r\n\t  , removeClass: function(name) {\r\n\t      if (this.hasClass(name)) {\r\n\t        this.attr('class', this.classes().filter(function(c) {\r\n\t          return c != name\r\n\t        }).join(' '))\r\n\t      }\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Toggle the presence of a class on the node\r\n\t  , toggleClass: function(name) {\r\n\t      return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)\r\n\t    }\r\n\t    // Get referenced element form attribute value\r\n\t  , reference: function(attr) {\r\n\t      return SVG.get(this.attr(attr))\r\n\t    }\r\n\t    // Returns the parent element instance\r\n\t  , parent: function(type) {\r\n\t      var parent = this\r\n\t\r\n\t      // check for parent\r\n\t      if(!parent.node.parentNode) return null\r\n\t\r\n\t      // get parent element\r\n\t      parent = SVG.adopt(parent.node.parentNode)\r\n\t\r\n\t      if(!type) return parent\r\n\t\r\n\t      // loop trough ancestors if type is given\r\n\t      while(parent && parent.node instanceof window.SVGElement){\r\n\t        if(typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent\r\n\t        parent = SVG.adopt(parent.node.parentNode)\r\n\t      }\r\n\t    }\r\n\t    // Get parent document\r\n\t  , doc: function() {\r\n\t      return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)\r\n\t    }\r\n\t    // return array of all ancestors of given type up to the root svg\r\n\t  , parents: function(type) {\r\n\t      var parents = [], parent = this\r\n\t\r\n\t      do{\r\n\t        parent = parent.parent(type)\r\n\t        if(!parent || !parent.node) break\r\n\t\r\n\t        parents.push(parent)\r\n\t      } while(parent.parent)\r\n\t\r\n\t      return parents\r\n\t    }\r\n\t    // matches the element vs a css selector\r\n\t  , matches: function(selector){\r\n\t      return matches(this.node, selector)\r\n\t    }\r\n\t    // Returns the svg node to call native svg methods on it\r\n\t  , native: function() {\r\n\t      return this.node\r\n\t    }\r\n\t    // Import raw svg\r\n\t  , svg: function(svg) {\r\n\t      // create temporary holder\r\n\t      var well = document.createElement('svg')\r\n\t\r\n\t      // act as a setter if svg is given\r\n\t      if (svg && this instanceof SVG.Parent) {\r\n\t        // dump raw svg\r\n\t        well.innerHTML = '<svg>' + svg.replace(/\\n/, '').replace(/<(\\w+)([^<]+?)\\/>/g, '<$1$2></$1>') + '</svg>'\r\n\t\r\n\t        // transplant nodes\r\n\t        for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)\r\n\t          this.node.appendChild(well.firstChild.firstChild)\r\n\t\r\n\t      // otherwise act as a getter\r\n\t      } else {\r\n\t        // create a wrapping svg element in case of partial content\r\n\t        well.appendChild(svg = document.createElement('svg'))\r\n\t\r\n\t        // write svgjs data to the dom\r\n\t        this.writeDataToDom()\r\n\t\r\n\t        // insert a copy of this node\r\n\t        svg.appendChild(this.node.cloneNode(true))\r\n\t\r\n\t        // return target element\r\n\t        return well.innerHTML.replace(/^<svg>/, '').replace(/<\\/svg>$/, '')\r\n\t      }\r\n\t\r\n\t      return this\r\n\t    }\r\n\t  // write svgjs data to the dom\r\n\t  , writeDataToDom: function() {\r\n\t\r\n\t      // dump variables recursively\r\n\t      if(this.each || this.lines){\r\n\t        var fn = this.each ? this : this.lines();\r\n\t        fn.each(function(){\r\n\t          this.writeDataToDom()\r\n\t        })\r\n\t      }\r\n\t\r\n\t      // remove previously set data\r\n\t      this.node.removeAttribute('svgjs:data')\r\n\t\r\n\t      if(Object.keys(this.dom).length)\r\n\t        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)) // see #428\r\n\t\r\n\t      return this\r\n\t    }\r\n\t  // set given data to the elements data property\r\n\t  , setData: function(o){\r\n\t      this.dom = o\r\n\t      return this\r\n\t    }\r\n\t  , is: function(obj){\r\n\t      return is(this, obj)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\n\tSVG.easing = {\r\n\t  '-': function(pos){return pos}\r\n\t, '<>':function(pos){return -Math.cos(pos * Math.PI) / 2 + 0.5}\r\n\t, '>': function(pos){return  Math.sin(pos * Math.PI / 2)}\r\n\t, '<': function(pos){return -Math.cos(pos * Math.PI / 2) + 1}\r\n\t}\r\n\t\r\n\tSVG.morph = function(pos){\r\n\t  return function(from, to) {\r\n\t    return new SVG.MorphObj(from, to).at(pos)\r\n\t  }\r\n\t}\r\n\t\r\n\tSVG.Situation = SVG.invent({\r\n\t\r\n\t  create: function(o){\r\n\t    this.init = false\r\n\t    this.reversed = false\r\n\t    this.reversing = false\r\n\t\r\n\t    this.duration = new SVG.Number(o.duration).valueOf()\r\n\t    this.delay = new SVG.Number(o.delay).valueOf()\r\n\t\r\n\t    this.start = +new Date() + this.delay\r\n\t    this.finish = this.start + this.duration\r\n\t    this.ease = o.ease\r\n\t\r\n\t    // this.loop is incremented from 0 to this.loops\r\n\t    // it is also incremented when in an infinite loop (when this.loops is true)\r\n\t    this.loop = 0\r\n\t    this.loops = false\r\n\t\r\n\t    this.animations = {\r\n\t      // functionToCall: [list of morphable objects]\r\n\t      // e.g. move: [SVG.Number, SVG.Number]\r\n\t    }\r\n\t\r\n\t    this.attrs = {\r\n\t      // holds all attributes which are not represented from a function svg.js provides\r\n\t      // e.g. someAttr: SVG.Number\r\n\t    }\r\n\t\r\n\t    this.styles = {\r\n\t      // holds all styles which should be animated\r\n\t      // e.g. fill-color: SVG.Color\r\n\t    }\r\n\t\r\n\t    this.transforms = [\r\n\t      // holds all transformations as transformation objects\r\n\t      // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\r\n\t    ]\r\n\t\r\n\t    this.once = {\r\n\t      // functions to fire at a specific position\r\n\t      // e.g. \"0.5\": function foo(){}\r\n\t    }\r\n\t\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\t\r\n\tSVG.FX = SVG.invent({\r\n\t\r\n\t  create: function(element) {\r\n\t    this._target = element\r\n\t    this.situations = []\r\n\t    this.active = false\r\n\t    this.situation = null\r\n\t    this.paused = false\r\n\t    this.lastPos = 0\r\n\t    this.pos = 0\r\n\t    // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\r\n\t    // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\r\n\t    this.absPos = 0\r\n\t    this._speed = 1\r\n\t  }\r\n\t\r\n\t, extend: {\r\n\t\r\n\t    /**\r\n\t     * sets or returns the target of this animation\r\n\t     * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\r\n\t     * @param ease function || string Function which should be used for easing or easing keyword\r\n\t     * @param delay Number indicating the delay before the animation starts\r\n\t     * @return target || this\r\n\t     */\r\n\t    animate: function(o, ease, delay){\r\n\t\r\n\t      if(typeof o == 'object'){\r\n\t        ease = o.ease\r\n\t        delay = o.delay\r\n\t        o = o.duration\r\n\t      }\r\n\t\r\n\t      var situation = new SVG.Situation({\r\n\t        duration: o || 1000,\r\n\t        delay: delay || 0,\r\n\t        ease: SVG.easing[ease || '-'] || ease\r\n\t      })\r\n\t\r\n\t      this.queue(situation)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * sets a delay before the next element of the queue is called\r\n\t     * @param delay Duration of delay in milliseconds\r\n\t     * @return this.target()\r\n\t     */\r\n\t  , delay: function(delay){\r\n\t      // The delay is performed by an empty situation with its duration\r\n\t      // attribute set to the duration of the delay\r\n\t      var situation = new SVG.Situation({\r\n\t        duration: delay,\r\n\t        delay: 0,\r\n\t        ease: SVG.easing['-']\r\n\t      })\r\n\t\r\n\t      return this.queue(situation)\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * sets or returns the target of this animation\r\n\t     * @param null || target SVG.Element which should be set as new target\r\n\t     * @return target || this\r\n\t     */\r\n\t  , target: function(target){\r\n\t      if(target && target instanceof SVG.Element){\r\n\t        this._target = target\r\n\t        return this\r\n\t      }\r\n\t\r\n\t      return this._target\r\n\t    }\r\n\t\r\n\t    // returns the absolute position at a given time\r\n\t  , timeToAbsPos: function(timestamp){\r\n\t      return (timestamp - this.situation.start) / (this.situation.duration/this._speed)\r\n\t    }\r\n\t\r\n\t    // returns the timestamp from a given absolute positon\r\n\t  , absPosToTime: function(absPos){\r\n\t      return this.situation.duration/this._speed * absPos + this.situation.start\r\n\t    }\r\n\t\r\n\t    // starts the animationloop\r\n\t  , startAnimFrame: function(){\r\n\t      this.stopAnimFrame()\r\n\t      this.animationFrame = window.requestAnimationFrame(function(){ this.step() }.bind(this))\r\n\t    }\r\n\t\r\n\t    // cancels the animationframe\r\n\t  , stopAnimFrame: function(){\r\n\t      window.cancelAnimationFrame(this.animationFrame)\r\n\t    }\r\n\t\r\n\t    // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\r\n\t  , start: function(){\r\n\t      // dont start if already started\r\n\t      if(!this.active && this.situation){\r\n\t        this.active = true\r\n\t        this.startCurrent()\r\n\t      }\r\n\t\r\n\t      return this\r\n\t    }\r\n\t\r\n\t    // start the current situation\r\n\t  , startCurrent: function(){\r\n\t      this.situation.start = +new Date + this.situation.delay/this._speed\r\n\t      this.situation.finish = this.situation.start + this.situation.duration/this._speed\r\n\t      return this.initAnimations().step()\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * adds a function / Situation to the animation queue\r\n\t     * @param fn function / situation to add\r\n\t     * @return this\r\n\t     */\r\n\t  , queue: function(fn){\r\n\t      if(typeof fn == 'function' || fn instanceof SVG.Situation)\r\n\t        this.situations.push(fn)\r\n\t\r\n\t      if(!this.situation) this.situation = this.situations.shift()\r\n\t\r\n\t      return this\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * pulls next element from the queue and execute it\r\n\t     * @return this\r\n\t     */\r\n\t  , dequeue: function(){\r\n\t      // stop current animation\r\n\t      this.stop()\r\n\t\r\n\t      // get next animation from queue\r\n\t      this.situation = this.situations.shift()\r\n\t\r\n\t      if(this.situation){\r\n\t        if(this.situation instanceof SVG.Situation) {\r\n\t          this.start()\r\n\t        } else {\r\n\t          // If it is not a SVG.Situation, then it is a function, we execute it\r\n\t          this.situation.call(this)\r\n\t        }\r\n\t      }\r\n\t\r\n\t      return this\r\n\t    }\r\n\t\r\n\t    // updates all animations to the current state of the element\r\n\t    // this is important when one property could be changed from another property\r\n\t  , initAnimations: function() {\r\n\t      var i, source\r\n\t      var s = this.situation\r\n\t\r\n\t      if(s.init) return this\r\n\t\r\n\t      for(i in s.animations){\r\n\t        source = this.target()[i]()\r\n\t\r\n\t        // The condition is because some methods return a normal number instead\r\n\t        // of a SVG.Number\r\n\t        if(s.animations[i] instanceof SVG.Number)\r\n\t          source = new SVG.Number(source)\r\n\t\r\n\t        s.animations[i] = source.morph(s.animations[i])\r\n\t      }\r\n\t\r\n\t      for(i in s.attrs){\r\n\t        s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i])\r\n\t      }\r\n\t\r\n\t      for(i in s.styles){\r\n\t        s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i])\r\n\t      }\r\n\t\r\n\t      s.initialTransformation = this.target().matrixify()\r\n\t\r\n\t      s.init = true\r\n\t      return this\r\n\t    }\r\n\t  , clearQueue: function(){\r\n\t      this.situations = []\r\n\t      return this\r\n\t    }\r\n\t  , clearCurrent: function(){\r\n\t      this.situation = null\r\n\t      return this\r\n\t    }\r\n\t    /** stops the animation immediately\r\n\t     * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\r\n\t     * @param clearQueue A Boolean indicating whether to remove queued animation as well.\r\n\t     * @return this\r\n\t     */\r\n\t  , stop: function(jumpToEnd, clearQueue){\r\n\t      var active = this.active\r\n\t      this.active = false\r\n\t\r\n\t      if(clearQueue){\r\n\t        this.clearQueue()\r\n\t      }\r\n\t\r\n\t      if(jumpToEnd && this.situation){\r\n\t        // initialize the situation if it was not\r\n\t        !active && this.startCurrent()\r\n\t        this.atEnd()\r\n\t      }\r\n\t\r\n\t      this.stopAnimFrame()\r\n\t\r\n\t      return this.clearCurrent()\r\n\t    }\r\n\t\r\n\t    /** resets the element to the state where the current element has started\r\n\t     * @return this\r\n\t     */\r\n\t  , reset: function(){\r\n\t      if(this.situation){\r\n\t        var temp = this.situation\r\n\t        this.stop()\r\n\t        this.situation = temp\r\n\t        this.atStart()\r\n\t      }\r\n\t      return this\r\n\t    }\r\n\t\r\n\t    // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.\r\n\t  , finish: function(){\r\n\t\r\n\t      this.stop(true, false)\r\n\t\r\n\t      while(this.dequeue().situation && this.stop(true, false));\r\n\t\r\n\t      this.clearQueue().clearCurrent()\r\n\t\r\n\t      return this\r\n\t    }\r\n\t\r\n\t    // set the internal animation pointer at the start position, before any loops, and updates the visualisation\r\n\t  , atStart: function() {\r\n\t      return this.at(0, true)\r\n\t    }\r\n\t\r\n\t    // set the internal animation pointer at the end position, after all the loops, and updates the visualisation\r\n\t  , atEnd: function() {\r\n\t      if (this.situation.loops === true) {\r\n\t        // If in a infinite loop, we end the current iteration\r\n\t        this.situation.loops = this.situation.loop + 1\r\n\t      }\r\n\t\r\n\t      if(typeof this.situation.loops == 'number') {\r\n\t        // If performing a finite number of loops, we go after all the loops\r\n\t        return this.at(this.situation.loops, true)\r\n\t      } else {\r\n\t        // If no loops, we just go at the end\r\n\t        return this.at(1, true)\r\n\t      }\r\n\t    }\r\n\t\r\n\t    // set the internal animation pointer to the specified position and updates the visualisation\r\n\t    // if isAbsPos is true, pos is treated as an absolute position\r\n\t  , at: function(pos, isAbsPos){\r\n\t      var durDivSpd = this.situation.duration/this._speed\r\n\t\r\n\t      this.absPos = pos\r\n\t      // If pos is not an absolute position, we convert it into one\r\n\t      if (!isAbsPos) {\r\n\t        if (this.situation.reversed) this.absPos = 1 - this.absPos\r\n\t        this.absPos += this.situation.loop\r\n\t      }\r\n\t\r\n\t      this.situation.start = +new Date - this.absPos * durDivSpd\r\n\t      this.situation.finish = this.situation.start + durDivSpd\r\n\t\r\n\t      return this.step(true)\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * sets or returns the speed of the animations\r\n\t     * @param speed null || Number The new speed of the animations\r\n\t     * @return Number || this\r\n\t     */\r\n\t  , speed: function(speed){\r\n\t      if (speed === 0) return this.pause()\r\n\t\r\n\t      if (speed) {\r\n\t        this._speed = speed\r\n\t        // We use an absolute position here so that speed can affect the delay before the animation\r\n\t        return this.at(this.absPos, true)\r\n\t      } else return this._speed\r\n\t    }\r\n\t\r\n\t    // Make loopable\r\n\t  , loop: function(times, reverse) {\r\n\t      var c = this.last()\r\n\t\r\n\t      // store total loops\r\n\t      c.loops = (times != null) ? times : true\r\n\t      c.loop = 0\r\n\t\r\n\t      if(reverse) c.reversing = true\r\n\t      return this\r\n\t    }\r\n\t\r\n\t    // pauses the animation\r\n\t  , pause: function(){\r\n\t      this.paused = true\r\n\t      this.stopAnimFrame()\r\n\t\r\n\t      return this\r\n\t    }\r\n\t\r\n\t    // unpause the animation\r\n\t  , play: function(){\r\n\t      if(!this.paused) return this\r\n\t      this.paused = false\r\n\t      // We use an absolute position here so that the delay before the animation can be paused\r\n\t      return this.at(this.absPos, true)\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * toggle or set the direction of the animation\r\n\t     * true sets direction to backwards while false sets it to forwards\r\n\t     * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)\r\n\t     * @return this\r\n\t     */\r\n\t  , reverse: function(reversed){\r\n\t      var c = this.last()\r\n\t\r\n\t      if(typeof reversed == 'undefined') c.reversed = !c.reversed\r\n\t      else c.reversed = reversed\r\n\t\r\n\t      return this\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * returns a float from 0-1 indicating the progress of the current animation\r\n\t     * @param eased Boolean indicating whether the returned position should be eased or not\r\n\t     * @return number\r\n\t     */\r\n\t  , progress: function(easeIt){\r\n\t      return easeIt ? this.situation.ease(this.pos) : this.pos\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * adds a callback function which is called when the current animation is finished\r\n\t     * @param fn Function which should be executed as callback\r\n\t     * @return number\r\n\t     */\r\n\t  , after: function(fn){\r\n\t      var c = this.last()\r\n\t        , wrapper = function wrapper(e){\r\n\t            if(e.detail.situation == c){\r\n\t              fn.call(this, c)\r\n\t              this.off('finished.fx', wrapper) // prevent memory leak\r\n\t            }\r\n\t          }\r\n\t\r\n\t      this.target().on('finished.fx', wrapper)\r\n\t\r\n\t      return this._callStart()\r\n\t    }\r\n\t\r\n\t    // adds a callback which is called whenever one animation step is performed\r\n\t  , during: function(fn){\r\n\t      var c = this.last()\r\n\t        , wrapper = function(e){\r\n\t            if(e.detail.situation == c){\r\n\t              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c)\r\n\t            }\r\n\t          }\r\n\t\r\n\t      // see above\r\n\t      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\t\r\n\t      this.after(function(){\r\n\t        this.off('during.fx', wrapper)\r\n\t      })\r\n\t\r\n\t      return this._callStart()\r\n\t    }\r\n\t\r\n\t    // calls after ALL animations in the queue are finished\r\n\t  , afterAll: function(fn){\r\n\t      var wrapper = function wrapper(e){\r\n\t            fn.call(this)\r\n\t            this.off('allfinished.fx', wrapper)\r\n\t          }\r\n\t\r\n\t      // see above\r\n\t      this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper)\r\n\t\r\n\t      return this._callStart()\r\n\t    }\r\n\t\r\n\t    // calls on every animation step for all animations\r\n\t  , duringAll: function(fn){\r\n\t      var wrapper = function(e){\r\n\t            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation)\r\n\t          }\r\n\t\r\n\t      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\t\r\n\t      this.afterAll(function(){\r\n\t        this.off('during.fx', wrapper)\r\n\t      })\r\n\t\r\n\t      return this._callStart()\r\n\t    }\r\n\t\r\n\t  , last: function(){\r\n\t      return this.situations.length ? this.situations[this.situations.length-1] : this.situation\r\n\t    }\r\n\t\r\n\t    // adds one property to the animations\r\n\t  , add: function(method, args, type){\r\n\t      this.last()[type || 'animations'][method] = args\r\n\t      return this._callStart()\r\n\t    }\r\n\t\r\n\t    /** perform one step of the animation\r\n\t     *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\r\n\t     *  @return this\r\n\t     */\r\n\t  , step: function(ignoreTime){\r\n\t\r\n\t      // convert current time to an absolute position\r\n\t      if(!ignoreTime) this.absPos = this.timeToAbsPos(+new Date)\r\n\t\r\n\t      // This part convert an absolute position to a position\r\n\t      if(this.situation.loops !== false) {\r\n\t        var absPos, absPosInt, lastLoop\r\n\t\r\n\t        // If the absolute position is below 0, we just treat it as if it was 0\r\n\t        absPos = Math.max(this.absPos, 0)\r\n\t        absPosInt = Math.floor(absPos)\r\n\t\r\n\t        if(this.situation.loops === true || absPosInt < this.situation.loops) {\r\n\t          this.pos = absPos - absPosInt\r\n\t          lastLoop = this.situation.loop\r\n\t          this.situation.loop = absPosInt\r\n\t        } else {\r\n\t          this.absPos = this.situation.loops\r\n\t          this.pos = 1\r\n\t          // The -1 here is because we don't want to toggle reversed when all the loops have been completed\r\n\t          lastLoop = this.situation.loop - 1\r\n\t          this.situation.loop = this.situation.loops\r\n\t        }\r\n\t\r\n\t        if(this.situation.reversing) {\r\n\t          // Toggle reversed if an odd number of loops as occured since the last call of step\r\n\t          this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2)\r\n\t        }\r\n\t\r\n\t      } else {\r\n\t        // If there are no loop, the absolute position must not be above 1\r\n\t        this.absPos = Math.min(this.absPos, 1)\r\n\t        this.pos = this.absPos\r\n\t      }\r\n\t\r\n\t      // while the absolute position can be below 0, the position must not be below 0\r\n\t      if(this.pos < 0) this.pos = 0\r\n\t\r\n\t      if(this.situation.reversed) this.pos = 1 - this.pos\r\n\t\r\n\t\r\n\t      // apply easing\r\n\t      var eased = this.situation.ease(this.pos)\r\n\t\r\n\t      // call once-callbacks\r\n\t      for(var i in this.situation.once){\r\n\t        if(i > this.lastPos && i <= eased){\r\n\t          this.situation.once[i].call(this.target(), this.pos, eased)\r\n\t          delete this.situation.once[i]\r\n\t        }\r\n\t      }\r\n\t\r\n\t      // fire during callback with position, eased position and current situation as parameter\r\n\t      if(this.active) this.target().fire('during', {pos: this.pos, eased: eased, fx: this, situation: this.situation})\r\n\t\r\n\t      // the user may call stop or finish in the during callback\r\n\t      // so make sure that we still have a valid situation\r\n\t      if(!this.situation){\r\n\t        return this\r\n\t      }\r\n\t\r\n\t      // apply the actual animation to every property\r\n\t      this.eachAt()\r\n\t\r\n\t      // do final code when situation is finished\r\n\t      if((this.pos == 1 && !this.situation.reversed) || (this.situation.reversed && this.pos == 0)){\r\n\t\r\n\t        // stop animation callback\r\n\t        this.stopAnimFrame()\r\n\t\r\n\t        // fire finished callback with current situation as parameter\r\n\t        this.target().fire('finished', {fx:this, situation: this.situation})\r\n\t\r\n\t        if(!this.situations.length){\r\n\t          this.target().fire('allfinished')\r\n\t          this.target().off('.fx') // there shouldnt be any binding left, but to make sure...\r\n\t          this.active = false\r\n\t        }\r\n\t\r\n\t        // start next animation\r\n\t        if(this.active) this.dequeue()\r\n\t        else this.clearCurrent()\r\n\t\r\n\t      }else if(!this.paused && this.active){\r\n\t        // we continue animating when we are not at the end\r\n\t        this.startAnimFrame()\r\n\t      }\r\n\t\r\n\t      // save last eased position for once callback triggering\r\n\t      this.lastPos = eased\r\n\t      return this\r\n\t\r\n\t    }\r\n\t\r\n\t    // calculates the step for every property and calls block with it\r\n\t  , eachAt: function(){\r\n\t      var i, at, self = this, target = this.target(), s = this.situation\r\n\t\r\n\t      // apply animations which can be called trough a method\r\n\t      for(i in s.animations){\r\n\t\r\n\t        at = [].concat(s.animations[i]).map(function(el){\r\n\t          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n\t        })\r\n\t\r\n\t        target[i].apply(target, at)\r\n\t\r\n\t      }\r\n\t\r\n\t      // apply animation which has to be applied with attr()\r\n\t      for(i in s.attrs){\r\n\t\r\n\t        at = [i].concat(s.attrs[i]).map(function(el){\r\n\t          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n\t        })\r\n\t\r\n\t        target.attr.apply(target, at)\r\n\t\r\n\t      }\r\n\t\r\n\t      // apply animation which has to be applied with style()\r\n\t      for(i in s.styles){\r\n\t\r\n\t        at = [i].concat(s.styles[i]).map(function(el){\r\n\t          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n\t        })\r\n\t\r\n\t        target.style.apply(target, at)\r\n\t\r\n\t      }\r\n\t\r\n\t      // animate initialTransformation which has to be chained\r\n\t      if(s.transforms.length){\r\n\t\r\n\t        // get initial initialTransformation\r\n\t        at = s.initialTransformation\r\n\t        for(i = 0, len = s.transforms.length; i < len; i++){\r\n\t\r\n\t          // get next transformation in chain\r\n\t          var a = s.transforms[i]\r\n\t\r\n\t          // multiply matrix directly\r\n\t          if(a instanceof SVG.Matrix){\r\n\t\r\n\t            if(a.relative){\r\n\t              at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)))\r\n\t            }else{\r\n\t              at = at.morph(a).at(s.ease(this.pos))\r\n\t            }\r\n\t            continue\r\n\t          }\r\n\t\r\n\t          // when transformation is absolute we have to reset the needed transformation first\r\n\t          if(!a.relative)\r\n\t            a.undo(at.extract())\r\n\t\r\n\t          // and reapply it after\r\n\t          at = at.multiply(a.at(s.ease(this.pos)))\r\n\t\r\n\t        }\r\n\t\r\n\t        // set new matrix on element\r\n\t        target.matrix(at)\r\n\t      }\r\n\t\r\n\t      return this\r\n\t\r\n\t    }\r\n\t\r\n\t\r\n\t    // adds an once-callback which is called at a specific position and never again\r\n\t  , once: function(pos, fn, isEased){\r\n\t\r\n\t      if(!isEased)pos = this.situation.ease(pos)\r\n\t\r\n\t      this.situation.once[pos] = fn\r\n\t\r\n\t      return this\r\n\t    }\r\n\t\r\n\t  , _callStart: function() {\r\n\t      setTimeout(function(){this.start()}.bind(this), 0)\r\n\t      return this\r\n\t    }\r\n\t\r\n\t  }\r\n\t\r\n\t, parent: SVG.Element\r\n\t\r\n\t  // Add method to parent elements\r\n\t, construct: {\r\n\t    // Get fx module or create a new one, then animate with given duration and ease\r\n\t    animate: function(o, ease, delay) {\r\n\t      return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay)\r\n\t    }\r\n\t  , delay: function(delay){\r\n\t      return (this.fx || (this.fx = new SVG.FX(this))).delay(delay)\r\n\t    }\r\n\t  , stop: function(jumpToEnd, clearQueue) {\r\n\t      if (this.fx)\r\n\t        this.fx.stop(jumpToEnd, clearQueue)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t  , finish: function() {\r\n\t      if (this.fx)\r\n\t        this.fx.finish()\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Pause current animation\r\n\t  , pause: function() {\r\n\t      if (this.fx)\r\n\t        this.fx.pause()\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Play paused current animation\r\n\t  , play: function() {\r\n\t      if (this.fx)\r\n\t        this.fx.play()\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Set/Get the speed of the animations\r\n\t  , speed: function(speed) {\r\n\t      if (this.fx)\r\n\t        if (speed == null)\r\n\t          return this.fx.speed()\r\n\t        else\r\n\t          this.fx.speed(speed)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\t// MorphObj is used whenever no morphable object is given\r\n\tSVG.MorphObj = SVG.invent({\r\n\t\r\n\t  create: function(from, to){\r\n\t    // prepare color for morphing\r\n\t    if(SVG.Color.isColor(to)) return new SVG.Color(from).morph(to)\r\n\t    // prepare number for morphing\r\n\t    if(SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to)\r\n\t\r\n\t    // prepare for plain morphing\r\n\t    this.value = from\r\n\t    this.destination = to\r\n\t  }\r\n\t\r\n\t, extend: {\r\n\t    at: function(pos, real){\r\n\t      return real < 1 ? this.value : this.destination\r\n\t    },\r\n\t\r\n\t    valueOf: function(){\r\n\t      return this.value\r\n\t    }\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.FX, {\r\n\t  // Add animatable attributes\r\n\t  attr: function(a, v, relative) {\r\n\t    // apply attributes individually\r\n\t    if (typeof a == 'object') {\r\n\t      for (var key in a)\r\n\t        this.attr(key, a[key])\r\n\t\r\n\t    } else {\r\n\t      this.add(a, v, 'attrs')\r\n\t    }\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Add animatable styles\r\n\t, style: function(s, v) {\r\n\t    if (typeof s == 'object')\r\n\t      for (var key in s)\r\n\t        this.style(key, s[key])\r\n\t\r\n\t    else\r\n\t      this.add(s, v, 'styles')\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Animatable x-axis\r\n\t, x: function(x, relative) {\r\n\t    if(this.target() instanceof SVG.G){\r\n\t      this.transform({x:x}, relative)\r\n\t      return this\r\n\t    }\r\n\t\r\n\t    var num = new SVG.Number(x)\r\n\t    num.relative = relative\r\n\t    return this.add('x', num)\r\n\t  }\r\n\t  // Animatable y-axis\r\n\t, y: function(y, relative) {\r\n\t    if(this.target() instanceof SVG.G){\r\n\t      this.transform({y:y}, relative)\r\n\t      return this\r\n\t    }\r\n\t\r\n\t    var num = new SVG.Number(y)\r\n\t    num.relative = relative\r\n\t    return this.add('y', num)\r\n\t  }\r\n\t  // Animatable center x-axis\r\n\t, cx: function(x) {\r\n\t    return this.add('cx', new SVG.Number(x))\r\n\t  }\r\n\t  // Animatable center y-axis\r\n\t, cy: function(y) {\r\n\t    return this.add('cy', new SVG.Number(y))\r\n\t  }\r\n\t  // Add animatable move\r\n\t, move: function(x, y) {\r\n\t    return this.x(x).y(y)\r\n\t  }\r\n\t  // Add animatable center\r\n\t, center: function(x, y) {\r\n\t    return this.cx(x).cy(y)\r\n\t  }\r\n\t  // Add animatable size\r\n\t, size: function(width, height) {\r\n\t    if (this.target() instanceof SVG.Text) {\r\n\t      // animate font size for Text elements\r\n\t      this.attr('font-size', width)\r\n\t\r\n\t    } else {\r\n\t      // animate bbox based size for all other elements\r\n\t      var box\r\n\t\r\n\t      if(!width || !height){\r\n\t        box = this.target().bbox()\r\n\t      }\r\n\t\r\n\t      if(!width){\r\n\t        width = box.width / box.height  * height\r\n\t      }\r\n\t\r\n\t      if(!height){\r\n\t        height = box.height / box.width  * width\r\n\t      }\r\n\t\r\n\t      this.add('width' , new SVG.Number(width))\r\n\t          .add('height', new SVG.Number(height))\r\n\t\r\n\t    }\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Add animatable plot\r\n\t, plot: function() {\r\n\t    // We use arguments here since SVG.Line's plot method can be passed 4 parameters\r\n\t    return this.add('plot', arguments.length > 1 ? [].slice.call(arguments) : arguments[0])\r\n\t  }\r\n\t  // Add leading method\r\n\t, leading: function(value) {\r\n\t    return this.target().leading ?\r\n\t      this.add('leading', new SVG.Number(value)) :\r\n\t      this\r\n\t  }\r\n\t  // Add animatable viewbox\r\n\t, viewbox: function(x, y, width, height) {\r\n\t    if (this.target() instanceof SVG.Container) {\r\n\t      this.add('viewbox', new SVG.ViewBox(x, y, width, height))\r\n\t    }\r\n\t\r\n\t    return this\r\n\t  }\r\n\t, update: function(o) {\r\n\t    if (this.target() instanceof SVG.Stop) {\r\n\t      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n\t        return this.update({\r\n\t          offset:  arguments[0]\r\n\t        , color:   arguments[1]\r\n\t        , opacity: arguments[2]\r\n\t        })\r\n\t      }\r\n\t\r\n\t      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n\t      if (o.color   != null) this.attr('stop-color', o.color)\r\n\t      if (o.offset  != null) this.attr('offset', o.offset)\r\n\t    }\r\n\t\r\n\t    return this\r\n\t  }\r\n\t})\r\n\t\n\tSVG.Box = SVG.invent({\r\n\t  create: function(x, y, width, height) {\r\n\t    if (typeof x == 'object' && !(x instanceof SVG.Element)) {\r\n\t      // chromes getBoundingClientRect has no x and y property\r\n\t      return SVG.Box.call(this, x.left != null ? x.left : x.x , x.top != null ? x.top : x.y, x.width, x.height)\r\n\t    } else if (arguments.length == 4) {\r\n\t      this.x = x\r\n\t      this.y = y\r\n\t      this.width = width\r\n\t      this.height = height\r\n\t\r\n\t    }\r\n\t\r\n\t    // add center, right, bottom...\r\n\t    fullBox(this)\r\n\t  }\r\n\t, extend: {\r\n\t    // Merge rect box with another, return a new instance\r\n\t    merge: function(box) {\r\n\t      var b = new this.constructor()\r\n\t\r\n\t      // merge boxes\r\n\t      b.x      = Math.min(this.x, box.x)\r\n\t      b.y      = Math.min(this.y, box.y)\r\n\t      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x\r\n\t      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y\r\n\t\r\n\t      return fullBox(b)\r\n\t    }\r\n\t\r\n\t  , transform: function(m) {\r\n\t      var xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, p\r\n\t\r\n\t      var pts = [\r\n\t        new SVG.Point(this.x, this.y),\r\n\t        new SVG.Point(this.x2, this.y),\r\n\t        new SVG.Point(this.x, this.y2),\r\n\t        new SVG.Point(this.x2, this.y2)\r\n\t      ]\r\n\t\r\n\t      pts.forEach(function(p) {\r\n\t        p = p.transform(m)\r\n\t        xMin = Math.min(xMin,p.x)\r\n\t        xMax = Math.max(xMax,p.x)\r\n\t        yMin = Math.min(yMin,p.y)\r\n\t        yMax = Math.max(yMax,p.y)\r\n\t      })\r\n\t\r\n\t      bbox = new this.constructor()\r\n\t      bbox.x = xMin\r\n\t      bbox.width = xMax-xMin\r\n\t      bbox.y = yMin\r\n\t      bbox.height = yMax-yMin\r\n\t\r\n\t      fullBox(bbox)\r\n\t\r\n\t      return bbox\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.BBox = SVG.invent({\r\n\t  // Initialize\r\n\t  create: function(element) {\r\n\t    SVG.Box.apply(this, [].slice.call(arguments))\r\n\t\r\n\t    // get values if element is given\r\n\t    if (element instanceof SVG.Element) {\r\n\t      var box\r\n\t\r\n\t      // yes this is ugly, but Firefox can be a bitch when it comes to elements that are not yet rendered\r\n\t      try {\r\n\t\r\n\t        if (!document.documentElement.contains){\r\n\t          // This is IE - it does not support contains() for top-level SVGs\r\n\t          var topParent = element.node\r\n\t          while (topParent.parentNode){\r\n\t            topParent = topParent.parentNode\r\n\t          }\r\n\t          if (topParent != document) throw new Exception('Element not in the dom')\r\n\t        } else {\r\n\t          // the element is NOT in the dom, throw error\r\n\t          if(!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')\r\n\t        }\r\n\t\r\n\t        // find native bbox\r\n\t        box = element.node.getBBox()\r\n\t      } catch(e) {\r\n\t        if(element instanceof SVG.Shape){\r\n\t          var clone = element.clone(SVG.parser.draw).show()\r\n\t          box = clone.node.getBBox()\r\n\t          clone.remove()\r\n\t        }else{\r\n\t          box = {\r\n\t            x:      element.node.clientLeft\r\n\t          , y:      element.node.clientTop\r\n\t          , width:  element.node.clientWidth\r\n\t          , height: element.node.clientHeight\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t\r\n\t      SVG.Box.call(this, box)\r\n\t    }\r\n\t\r\n\t  }\r\n\t\r\n\t  // Define ancestor\r\n\t, inherit: SVG.Box\r\n\t\r\n\t  // Define Parent\r\n\t, parent: SVG.Element\r\n\t\r\n\t  // Constructor\r\n\t, construct: {\r\n\t    // Get bounding box\r\n\t    bbox: function() {\r\n\t      return new SVG.BBox(this)\r\n\t    }\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.BBox.prototype.constructor = SVG.BBox\r\n\t\r\n\t\r\n\tSVG.extend(SVG.Element, {\r\n\t  tbox: function(){\r\n\t    console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.')\r\n\t    return this.rbox(this.doc())\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.RBox = SVG.invent({\r\n\t  // Initialize\r\n\t  create: function(element) {\r\n\t    SVG.Box.apply(this, [].slice.call(arguments))\r\n\t\r\n\t    if (element instanceof SVG.Element) {\r\n\t      SVG.Box.call(this, element.node.getBoundingClientRect())\r\n\t    }\r\n\t  }\r\n\t\r\n\t, inherit: SVG.Box\r\n\t\r\n\t  // define Parent\r\n\t, parent: SVG.Element\r\n\t\r\n\t, extend: {\r\n\t    addOffset: function() {\r\n\t      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\r\n\t      this.x += window.pageXOffset\r\n\t      this.y += window.pageYOffset\r\n\t      return this\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Constructor\r\n\t, construct: {\r\n\t    // Get rect box\r\n\t    rbox: function(el) {\r\n\t      if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse())\r\n\t      return new SVG.RBox(this).addOffset()\r\n\t    }\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.RBox.prototype.constructor = SVG.RBox\r\n\t\n\tSVG.Matrix = SVG.invent({\r\n\t  // Initialize\r\n\t  create: function(source) {\r\n\t    var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0])\r\n\t\r\n\t    // ensure source as object\r\n\t    source = source instanceof SVG.Element ?\r\n\t      source.matrixify() :\r\n\t    typeof source === 'string' ?\r\n\t      arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) :\r\n\t    arguments.length == 6 ?\r\n\t      arrayToMatrix([].slice.call(arguments)) :\r\n\t    Array.isArray(source) ?\r\n\t      arrayToMatrix(source) :\r\n\t    typeof source === 'object' ?\r\n\t      source : base\r\n\t\r\n\t    // merge source\r\n\t    for (i = abcdef.length - 1; i >= 0; --i)\r\n\t      this[abcdef[i]] = source && typeof source[abcdef[i]] === 'number' ?\r\n\t        source[abcdef[i]] : base[abcdef[i]]\r\n\t  }\r\n\t\r\n\t  // Add methods\r\n\t, extend: {\r\n\t    // Extract individual transformations\r\n\t    extract: function() {\r\n\t      // find delta transform points\r\n\t      var px    = deltaTransformPoint(this, 0, 1)\r\n\t        , py    = deltaTransformPoint(this, 1, 0)\r\n\t        , skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90\r\n\t\r\n\t      return {\r\n\t        // translation\r\n\t        x:        this.e\r\n\t      , y:        this.f\r\n\t      , transformedX:(this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b)\r\n\t      , transformedY:(this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d)\r\n\t        // skew\r\n\t      , skewX:    -skewX\r\n\t      , skewY:    180 / Math.PI * Math.atan2(py.y, py.x)\r\n\t        // scale\r\n\t      , scaleX:   Math.sqrt(this.a * this.a + this.b * this.b)\r\n\t      , scaleY:   Math.sqrt(this.c * this.c + this.d * this.d)\r\n\t        // rotation\r\n\t      , rotation: skewX\r\n\t      , a: this.a\r\n\t      , b: this.b\r\n\t      , c: this.c\r\n\t      , d: this.d\r\n\t      , e: this.e\r\n\t      , f: this.f\r\n\t      , matrix: new SVG.Matrix(this)\r\n\t      }\r\n\t    }\r\n\t    // Clone matrix\r\n\t  , clone: function() {\r\n\t      return new SVG.Matrix(this)\r\n\t    }\r\n\t    // Morph one matrix into another\r\n\t  , morph: function(matrix) {\r\n\t      // store new destination\r\n\t      this.destination = new SVG.Matrix(matrix)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Get morphed matrix at a given position\r\n\t  , at: function(pos) {\r\n\t      // make sure a destination is defined\r\n\t      if (!this.destination) return this\r\n\t\r\n\t      // calculate morphed matrix at a given position\r\n\t      var matrix = new SVG.Matrix({\r\n\t        a: this.a + (this.destination.a - this.a) * pos\r\n\t      , b: this.b + (this.destination.b - this.b) * pos\r\n\t      , c: this.c + (this.destination.c - this.c) * pos\r\n\t      , d: this.d + (this.destination.d - this.d) * pos\r\n\t      , e: this.e + (this.destination.e - this.e) * pos\r\n\t      , f: this.f + (this.destination.f - this.f) * pos\r\n\t      })\r\n\t\r\n\t      return matrix\r\n\t    }\r\n\t    // Multiplies by given matrix\r\n\t  , multiply: function(matrix) {\r\n\t      return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()))\r\n\t    }\r\n\t    // Inverses matrix\r\n\t  , inverse: function() {\r\n\t      return new SVG.Matrix(this.native().inverse())\r\n\t    }\r\n\t    // Translate matrix\r\n\t  , translate: function(x, y) {\r\n\t      return new SVG.Matrix(this.native().translate(x || 0, y || 0))\r\n\t    }\r\n\t    // Scale matrix\r\n\t  , scale: function(x, y, cx, cy) {\r\n\t      // support uniformal scale\r\n\t      if (arguments.length == 1) {\r\n\t        y = x\r\n\t      } else if (arguments.length == 3) {\r\n\t        cy = cx\r\n\t        cx = y\r\n\t        y = x\r\n\t      }\r\n\t\r\n\t      return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))\r\n\t    }\r\n\t    // Rotate matrix\r\n\t  , rotate: function(r, cx, cy) {\r\n\t      // convert degrees to radians\r\n\t      r = SVG.utils.radians(r)\r\n\t\r\n\t      return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))\r\n\t    }\r\n\t    // Flip matrix on x or y, at a given offset\r\n\t  , flip: function(a, o) {\r\n\t      o = typeof a == 'number' ? a : o\r\n\t      return a == 'x' ?\r\n\t          this.scale(-1, 1, o, 0) :\r\n\t        a == 'y' ?\r\n\t          this.scale(1, -1, 0, o) :\r\n\t          this.scale(-1, -1, o, o)\r\n\t    }\r\n\t    // Skew\r\n\t  , skew: function(x, y, cx, cy) {\r\n\t      // support uniformal skew\r\n\t      if (arguments.length == 1) {\r\n\t        y = x\r\n\t      } else if (arguments.length == 3) {\r\n\t        cy = cx\r\n\t        cx = y\r\n\t        y = x\r\n\t      }\r\n\t\r\n\t      // convert degrees to radians\r\n\t      x = SVG.utils.radians(x)\r\n\t      y = SVG.utils.radians(y)\r\n\t\r\n\t      return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0))\r\n\t    }\r\n\t    // SkewX\r\n\t  , skewX: function(x, cx, cy) {\r\n\t      return this.skew(x, 0, cx, cy)\r\n\t    }\r\n\t    // SkewY\r\n\t  , skewY: function(y, cx, cy) {\r\n\t      return this.skew(0, y, cx, cy)\r\n\t    }\r\n\t    // Transform around a center point\r\n\t  , around: function(cx, cy, matrix) {\r\n\t      return this\r\n\t        .multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0))\r\n\t        .multiply(matrix)\r\n\t        .multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))\r\n\t    }\r\n\t    // Convert to native SVGMatrix\r\n\t  , native: function() {\r\n\t      // create new matrix\r\n\t      var matrix = SVG.parser.native.createSVGMatrix()\r\n\t\r\n\t      // update with current values\r\n\t      for (var i = abcdef.length - 1; i >= 0; i--)\r\n\t        matrix[abcdef[i]] = this[abcdef[i]]\r\n\t\r\n\t      return matrix\r\n\t    }\r\n\t    // Convert matrix to string\r\n\t  , toString: function() {\r\n\t      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')'\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Define parent\r\n\t, parent: SVG.Element\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Get current matrix\r\n\t    ctm: function() {\r\n\t      return new SVG.Matrix(this.node.getCTM())\r\n\t    },\r\n\t    // Get current screen matrix\r\n\t    screenCTM: function() {\r\n\t      /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\r\n\t         This is needed because FF does not return the transformation matrix\r\n\t         for the inner coordinate system when getScreenCTM() is called on nested svgs.\r\n\t         However all other Browsers do that */\r\n\t      if(this instanceof SVG.Nested) {\r\n\t        var rect = this.rect(1,1)\r\n\t        var m = rect.node.getScreenCTM()\r\n\t        rect.remove()\r\n\t        return new SVG.Matrix(m)\r\n\t      }\r\n\t      return new SVG.Matrix(this.node.getScreenCTM())\r\n\t    }\r\n\t\r\n\t  }\r\n\t\r\n\t})\r\n\t\n\tSVG.Point = SVG.invent({\r\n\t  // Initialize\r\n\t  create: function(x,y) {\r\n\t    var i, source, base = {x:0, y:0}\r\n\t\r\n\t    // ensure source as object\r\n\t    source = Array.isArray(x) ?\r\n\t      {x:x[0], y:x[1]} :\r\n\t    typeof x === 'object' ?\r\n\t      {x:x.x, y:x.y} :\r\n\t    x != null ?\r\n\t      {x:x, y:(y != null ? y : x)} : base // If y has no value, then x is used has its value\r\n\t\r\n\t    // merge source\r\n\t    this.x = source.x\r\n\t    this.y = source.y\r\n\t  }\r\n\t\r\n\t  // Add methods\r\n\t, extend: {\r\n\t    // Clone point\r\n\t    clone: function() {\r\n\t      return new SVG.Point(this)\r\n\t    }\r\n\t    // Morph one point into another\r\n\t  , morph: function(x, y) {\r\n\t      // store new destination\r\n\t      this.destination = new SVG.Point(x, y)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Get morphed point at a given position\r\n\t  , at: function(pos) {\r\n\t      // make sure a destination is defined\r\n\t      if (!this.destination) return this\r\n\t\r\n\t      // calculate morphed matrix at a given position\r\n\t      var point = new SVG.Point({\r\n\t        x: this.x + (this.destination.x - this.x) * pos\r\n\t      , y: this.y + (this.destination.y - this.y) * pos\r\n\t      })\r\n\t\r\n\t      return point\r\n\t    }\r\n\t    // Convert to native SVGPoint\r\n\t  , native: function() {\r\n\t      // create new point\r\n\t      var point = SVG.parser.native.createSVGPoint()\r\n\t\r\n\t      // update with current values\r\n\t      point.x = this.x\r\n\t      point.y = this.y\r\n\t\r\n\t      return point\r\n\t    }\r\n\t    // transform point with matrix\r\n\t  , transform: function(matrix) {\r\n\t      return new SVG.Point(this.native().matrixTransform(matrix.native()))\r\n\t    }\r\n\t\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.Element, {\r\n\t\r\n\t  // Get point\r\n\t  point: function(x, y) {\r\n\t    return new SVG.Point(x,y).transform(this.screenCTM().inverse());\r\n\t  }\r\n\t\r\n\t})\r\n\t\n\tSVG.extend(SVG.Element, {\r\n\t  // Set svg element attribute\r\n\t  attr: function(a, v, n) {\r\n\t    // act as full getter\r\n\t    if (a == null) {\r\n\t      // get an object of attributes\r\n\t      a = {}\r\n\t      v = this.node.attributes\r\n\t      for (n = v.length - 1; n >= 0; n--)\r\n\t        a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue\r\n\t\r\n\t      return a\r\n\t\r\n\t    } else if (typeof a == 'object') {\r\n\t      // apply every attribute individually if an object is passed\r\n\t      for (v in a) this.attr(v, a[v])\r\n\t\r\n\t    } else if (v === null) {\r\n\t        // remove value\r\n\t        this.node.removeAttribute(a)\r\n\t\r\n\t    } else if (v == null) {\r\n\t      // act as a getter if the first and only argument is not an object\r\n\t      v = this.node.getAttribute(a)\r\n\t      return v == null ?\r\n\t        SVG.defaults.attrs[a] :\r\n\t      SVG.regex.isNumber.test(v) ?\r\n\t        parseFloat(v) : v\r\n\t\r\n\t    } else {\r\n\t      // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\r\n\t      if (a == 'stroke-width')\r\n\t        this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)\r\n\t      else if (a == 'stroke')\r\n\t        this._stroke = v\r\n\t\r\n\t      // convert image fill and stroke to patterns\r\n\t      if (a == 'fill' || a == 'stroke') {\r\n\t        if (SVG.regex.isImage.test(v))\r\n\t          v = this.doc().defs().image(v, 0, 0)\r\n\t\r\n\t        if (v instanceof SVG.Image)\r\n\t          v = this.doc().defs().pattern(0, 0, function() {\r\n\t            this.add(v)\r\n\t          })\r\n\t      }\r\n\t\r\n\t      // ensure correct numeric values (also accepts NaN and Infinity)\r\n\t      if (typeof v === 'number')\r\n\t        v = new SVG.Number(v)\r\n\t\r\n\t      // ensure full hex color\r\n\t      else if (SVG.Color.isColor(v))\r\n\t        v = new SVG.Color(v)\r\n\t\r\n\t      // parse array values\r\n\t      else if (Array.isArray(v))\r\n\t        v = new SVG.Array(v)\r\n\t\r\n\t      // if the passed attribute is leading...\r\n\t      if (a == 'leading') {\r\n\t        // ... call the leading method instead\r\n\t        if (this.leading)\r\n\t          this.leading(v)\r\n\t      } else {\r\n\t        // set given attribute on node\r\n\t        typeof n === 'string' ?\r\n\t          this.node.setAttributeNS(n, a, v.toString()) :\r\n\t          this.node.setAttribute(a, v.toString())\r\n\t      }\r\n\t\r\n\t      // rebuild if required\r\n\t      if (this.rebuild && (a == 'font-size' || a == 'x'))\r\n\t        this.rebuild(a, v)\r\n\t    }\r\n\t\r\n\t    return this\r\n\t  }\r\n\t})\n\tSVG.extend(SVG.Element, {\r\n\t  // Add transformations\r\n\t  transform: function(o, relative) {\r\n\t    // get target in case of the fx module, otherwise reference this\r\n\t    var target = this\r\n\t      , matrix\r\n\t\r\n\t    // act as a getter\r\n\t    if (typeof o !== 'object') {\r\n\t      // get current matrix\r\n\t      matrix = new SVG.Matrix(target).extract()\r\n\t\r\n\t      return typeof o === 'string' ? matrix[o] : matrix\r\n\t    }\r\n\t\r\n\t    // get current matrix\r\n\t    matrix = new SVG.Matrix(target)\r\n\t\r\n\t    // ensure relative flag\r\n\t    relative = !!relative || !!o.relative\r\n\t\r\n\t    // act on matrix\r\n\t    if (o.a != null) {\r\n\t      matrix = relative ?\r\n\t        // relative\r\n\t        matrix.multiply(new SVG.Matrix(o)) :\r\n\t        // absolute\r\n\t        new SVG.Matrix(o)\r\n\t\r\n\t    // act on rotation\r\n\t    } else if (o.rotation != null) {\r\n\t      // ensure centre point\r\n\t      ensureCentre(o, target)\r\n\t\r\n\t      // apply transformation\r\n\t      matrix = relative ?\r\n\t        // relative\r\n\t        matrix.rotate(o.rotation, o.cx, o.cy) :\r\n\t        // absolute\r\n\t        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)\r\n\t\r\n\t    // act on scale\r\n\t    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n\t      // ensure centre point\r\n\t      ensureCentre(o, target)\r\n\t\r\n\t      // ensure scale values on both axes\r\n\t      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n\t      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\t\r\n\t      if (!relative) {\r\n\t        // absolute; multiply inversed values\r\n\t        var e = matrix.extract()\r\n\t        o.scaleX = o.scaleX * 1 / e.scaleX\r\n\t        o.scaleY = o.scaleY * 1 / e.scaleY\r\n\t      }\r\n\t\r\n\t      matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\t\r\n\t    // act on skew\r\n\t    } else if (o.skew != null || o.skewX != null || o.skewY != null) {\r\n\t      // ensure centre point\r\n\t      ensureCentre(o, target)\r\n\t\r\n\t      // ensure skew values on both axes\r\n\t      o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0\r\n\t      o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0\r\n\t\r\n\t      if (!relative) {\r\n\t        // absolute; reset skew values\r\n\t        var e = matrix.extract()\r\n\t        matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse())\r\n\t      }\r\n\t\r\n\t      matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\t\r\n\t    // act on flip\r\n\t    } else if (o.flip) {\r\n\t      matrix = matrix.flip(\r\n\t        o.flip\r\n\t      , o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n\t      )\r\n\t\r\n\t    // act on translate\r\n\t    } else if (o.x != null || o.y != null) {\r\n\t      if (relative) {\r\n\t        // relative\r\n\t        matrix = matrix.translate(o.x, o.y)\r\n\t      } else {\r\n\t        // absolute\r\n\t        if (o.x != null) matrix.e = o.x\r\n\t        if (o.y != null) matrix.f = o.y\r\n\t      }\r\n\t    }\r\n\t\r\n\t    return this.attr('transform', matrix)\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.FX, {\r\n\t  transform: function(o, relative) {\r\n\t    // get target in case of the fx module, otherwise reference this\r\n\t    var target = this.target()\r\n\t      , matrix\r\n\t\r\n\t    // act as a getter\r\n\t    if (typeof o !== 'object') {\r\n\t      // get current matrix\r\n\t      matrix = new SVG.Matrix(target).extract()\r\n\t\r\n\t      return typeof o === 'string' ? matrix[o] : matrix\r\n\t    }\r\n\t\r\n\t    // ensure relative flag\r\n\t    relative = !!relative || !!o.relative\r\n\t\r\n\t    // act on matrix\r\n\t    if (o.a != null) {\r\n\t      matrix = new SVG.Matrix(o)\r\n\t\r\n\t    // act on rotation\r\n\t    } else if (o.rotation != null) {\r\n\t      // ensure centre point\r\n\t      ensureCentre(o, target)\r\n\t\r\n\t      // apply transformation\r\n\t      matrix = new SVG.Rotate(o.rotation, o.cx, o.cy)\r\n\t\r\n\t    // act on scale\r\n\t    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n\t      // ensure centre point\r\n\t      ensureCentre(o, target)\r\n\t\r\n\t      // ensure scale values on both axes\r\n\t      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n\t      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\t\r\n\t      matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\t\r\n\t    // act on skew\r\n\t    } else if (o.skewX != null || o.skewY != null) {\r\n\t      // ensure centre point\r\n\t      ensureCentre(o, target)\r\n\t\r\n\t      // ensure skew values on both axes\r\n\t      o.skewX = o.skewX != null ? o.skewX : 0\r\n\t      o.skewY = o.skewY != null ? o.skewY : 0\r\n\t\r\n\t      matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\t\r\n\t    // act on flip\r\n\t    } else if (o.flip) {\r\n\t      matrix = new SVG.Matrix().flip(\r\n\t        o.flip\r\n\t      , o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n\t      )\r\n\t\r\n\t    // act on translate\r\n\t    } else if (o.x != null || o.y != null) {\r\n\t      matrix = new SVG.Translate(o.x, o.y)\r\n\t    }\r\n\t\r\n\t    if(!matrix) return this\r\n\t\r\n\t    matrix.relative = relative\r\n\t\r\n\t    this.last().transforms.push(matrix)\r\n\t\r\n\t    return this._callStart()\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.Element, {\r\n\t  // Reset all transformations\r\n\t  untransform: function() {\r\n\t    return this.attr('transform', null)\r\n\t  },\r\n\t  // merge the whole transformation chain into one matrix and returns it\r\n\t  matrixify: function() {\r\n\t\r\n\t    var matrix = (this.attr('transform') || '')\r\n\t      // split transformations\r\n\t      .split(SVG.regex.transforms).slice(0,-1).map(function(str){\r\n\t        // generate key => value pairs\r\n\t        var kv = str.trim().split('(')\r\n\t        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function(str){ return parseFloat(str) })]\r\n\t      })\r\n\t      // merge every transformation into one matrix\r\n\t      .reduce(function(matrix, transform){\r\n\t\r\n\t        if(transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))\r\n\t        return matrix[transform[0]].apply(matrix, transform[1])\r\n\t\r\n\t      }, new SVG.Matrix())\r\n\t\r\n\t    return matrix\r\n\t  },\r\n\t  // add an element to another parent without changing the visual representation on the screen\r\n\t  toParent: function(parent) {\r\n\t    if(this == parent) return this\r\n\t    var ctm = this.screenCTM()\r\n\t    var pCtm = parent.screenCTM().inverse()\r\n\t\r\n\t    this.addTo(parent).untransform().transform(pCtm.multiply(ctm))\r\n\t\r\n\t    return this\r\n\t  },\r\n\t  // same as above with parent equals root-svg\r\n\t  toDoc: function() {\r\n\t    return this.toParent(this.doc())\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.Transformation = SVG.invent({\r\n\t\r\n\t  create: function(source, inversed){\r\n\t\r\n\t    if(arguments.length > 1 && typeof inversed != 'boolean'){\r\n\t      return this.constructor.call(this, [].slice.call(arguments))\r\n\t    }\r\n\t\r\n\t    if(Array.isArray(source)){\r\n\t      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n\t        this[this.arguments[i]] = source[i]\r\n\t      }\r\n\t    } else if(typeof source == 'object'){\r\n\t      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n\t        this[this.arguments[i]] = source[this.arguments[i]]\r\n\t      }\r\n\t    }\r\n\t\r\n\t    this.inversed = false\r\n\t\r\n\t    if(inversed === true){\r\n\t      this.inversed = true\r\n\t    }\r\n\t\r\n\t  }\r\n\t\r\n\t, extend: {\r\n\t\r\n\t    arguments: []\r\n\t  , method: ''\r\n\t\r\n\t  , at: function(pos){\r\n\t\r\n\t      var params = []\r\n\t\r\n\t      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n\t        params.push(this[this.arguments[i]])\r\n\t      }\r\n\t\r\n\t      var m = this._undo || new SVG.Matrix()\r\n\t\r\n\t      m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos)\r\n\t\r\n\t      return this.inversed ? m.inverse() : m\r\n\t\r\n\t    }\r\n\t\r\n\t  , undo: function(o){\r\n\t      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n\t        o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]]\r\n\t      }\r\n\t\r\n\t      // The method SVG.Matrix.extract which was used before calling this\r\n\t      // method to obtain a value for the parameter o doesn't return a cx and\r\n\t      // a cy so we use the ones that were provided to this object at its creation\r\n\t      o.cx = this.cx\r\n\t      o.cy = this.cy\r\n\t\r\n\t      this._undo = new SVG[capitalize(this.method)](o, true).at(1)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.Translate = SVG.invent({\r\n\t\r\n\t  parent: SVG.Matrix\r\n\t, inherit: SVG.Transformation\r\n\t\r\n\t, create: function(source, inversed){\r\n\t    this.constructor.apply(this, [].slice.call(arguments))\r\n\t  }\r\n\t\r\n\t, extend: {\r\n\t    arguments: ['transformedX', 'transformedY']\r\n\t  , method: 'translate'\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.Rotate = SVG.invent({\r\n\t\r\n\t  parent: SVG.Matrix\r\n\t, inherit: SVG.Transformation\r\n\t\r\n\t, create: function(source, inversed){\r\n\t    this.constructor.apply(this, [].slice.call(arguments))\r\n\t  }\r\n\t\r\n\t, extend: {\r\n\t    arguments: ['rotation', 'cx', 'cy']\r\n\t  , method: 'rotate'\r\n\t  , at: function(pos){\r\n\t      var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy)\r\n\t      return this.inversed ? m.inverse() : m\r\n\t    }\r\n\t  , undo: function(o){\r\n\t      this._undo = o\r\n\t      return this\r\n\t    }\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.Scale = SVG.invent({\r\n\t\r\n\t  parent: SVG.Matrix\r\n\t, inherit: SVG.Transformation\r\n\t\r\n\t, create: function(source, inversed){\r\n\t    this.constructor.apply(this, [].slice.call(arguments))\r\n\t  }\r\n\t\r\n\t, extend: {\r\n\t    arguments: ['scaleX', 'scaleY', 'cx', 'cy']\r\n\t  , method: 'scale'\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.Skew = SVG.invent({\r\n\t\r\n\t  parent: SVG.Matrix\r\n\t, inherit: SVG.Transformation\r\n\t\r\n\t, create: function(source, inversed){\r\n\t    this.constructor.apply(this, [].slice.call(arguments))\r\n\t  }\r\n\t\r\n\t, extend: {\r\n\t    arguments: ['skewX', 'skewY', 'cx', 'cy']\r\n\t  , method: 'skew'\r\n\t  }\r\n\t\r\n\t})\r\n\t\n\tSVG.extend(SVG.Element, {\r\n\t  // Dynamic style generator\r\n\t  style: function(s, v) {\r\n\t    if (arguments.length == 0) {\r\n\t      // get full style\r\n\t      return this.node.style.cssText || ''\r\n\t\r\n\t    } else if (arguments.length < 2) {\r\n\t      // apply every style individually if an object is passed\r\n\t      if (typeof s == 'object') {\r\n\t        for (v in s) this.style(v, s[v])\r\n\t\r\n\t      } else if (SVG.regex.isCss.test(s)) {\r\n\t        // parse css string\r\n\t        s = s.split(/\\s*;\\s*/)\r\n\t          // filter out suffix ; and stuff like ;;\r\n\t          .filter(function(e) { return !!e })\r\n\t          .map(function(e){ return e.split(/\\s*:\\s*/) })\r\n\t\r\n\t        // apply every definition individually\r\n\t        while (v = s.pop()) {\r\n\t          this.style(v[0], v[1])\r\n\t        }\r\n\t      } else {\r\n\t        // act as a getter if the first and only argument is not an object\r\n\t        return this.node.style[camelCase(s)]\r\n\t      }\r\n\t\r\n\t    } else {\r\n\t      this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v\r\n\t    }\r\n\t\r\n\t    return this\r\n\t  }\r\n\t})\n\tSVG.Parent = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: function(element) {\r\n\t    this.constructor.call(this, element)\r\n\t  }\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Element\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Returns all child elements\r\n\t    children: function() {\r\n\t      return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {\r\n\t        return SVG.adopt(node)\r\n\t      })\r\n\t    }\r\n\t    // Add given element at a position\r\n\t  , add: function(element, i) {\r\n\t      if (i == null)\r\n\t        this.node.appendChild(element.node)\r\n\t      else if (element.node != this.node.childNodes[i])\r\n\t        this.node.insertBefore(element.node, this.node.childNodes[i])\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Basically does the same as `add()` but returns the added element instead\r\n\t  , put: function(element, i) {\r\n\t      this.add(element, i)\r\n\t      return element\r\n\t    }\r\n\t    // Checks if the given element is a child\r\n\t  , has: function(element) {\r\n\t      return this.index(element) >= 0\r\n\t    }\r\n\t    // Gets index of given element\r\n\t  , index: function(element) {\r\n\t      return [].slice.call(this.node.childNodes).indexOf(element.node)\r\n\t    }\r\n\t    // Get a element at the given index\r\n\t  , get: function(i) {\r\n\t      return SVG.adopt(this.node.childNodes[i])\r\n\t    }\r\n\t    // Get first child\r\n\t  , first: function() {\r\n\t      return this.get(0)\r\n\t    }\r\n\t    // Get the last child\r\n\t  , last: function() {\r\n\t      return this.get(this.node.childNodes.length - 1)\r\n\t    }\r\n\t    // Iterates over all children and invokes a given block\r\n\t  , each: function(block, deep) {\r\n\t      var i, il\r\n\t        , children = this.children()\r\n\t\r\n\t      for (i = 0, il = children.length; i < il; i++) {\r\n\t        if (children[i] instanceof SVG.Element)\r\n\t          block.apply(children[i], [i, children])\r\n\t\r\n\t        if (deep && (children[i] instanceof SVG.Container))\r\n\t          children[i].each(block, deep)\r\n\t      }\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Remove a given child\r\n\t  , removeElement: function(element) {\r\n\t      this.node.removeChild(element.node)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Remove all elements in this container\r\n\t  , clear: function() {\r\n\t      // remove children\r\n\t      while(this.node.hasChildNodes())\r\n\t        this.node.removeChild(this.node.lastChild)\r\n\t\r\n\t      // remove defs reference\r\n\t      delete this._defs\r\n\t\r\n\t      return this\r\n\t    }\r\n\t  , // Get defs\r\n\t    defs: function() {\r\n\t      return this.doc().defs()\r\n\t    }\r\n\t  }\r\n\t\r\n\t})\r\n\t\n\tSVG.extend(SVG.Parent, {\r\n\t\r\n\t  ungroup: function(parent, depth) {\r\n\t    if(depth === 0 || this instanceof SVG.Defs) return this\r\n\t\r\n\t    parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent))\r\n\t    depth = depth || Infinity\r\n\t\r\n\t    this.each(function(){\r\n\t      if(this instanceof SVG.Defs) return this\r\n\t      if(this instanceof SVG.Parent) return this.ungroup(parent, depth-1)\r\n\t      return this.toParent(parent)\r\n\t    })\r\n\t\r\n\t    this.node.firstChild || this.remove()\r\n\t\r\n\t    return this\r\n\t  },\r\n\t\r\n\t  flatten: function(parent, depth) {\r\n\t    return this.ungroup(parent, depth)\r\n\t  }\r\n\t\r\n\t})\n\tSVG.Container = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: function(element) {\r\n\t    this.constructor.call(this, element)\r\n\t  }\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Parent\r\n\t\r\n\t})\n\t\r\n\tSVG.ViewBox = SVG.invent({\r\n\t\r\n\t  create: function(source) {\r\n\t    var i, base = [0, 0, 0, 0]\r\n\t\r\n\t    var x, y, width, height, box, view, we, he\r\n\t      , wm   = 1 // width multiplier\r\n\t      , hm   = 1 // height multiplier\r\n\t      , reg  = /[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?/gi\r\n\t\r\n\t    if(source instanceof SVG.Element){\r\n\t\r\n\t      we = source\r\n\t      he = source\r\n\t      view = (source.attr('viewBox') || '').match(reg)\r\n\t      box = source.bbox\r\n\t\r\n\t      // get dimensions of current node\r\n\t      width  = new SVG.Number(source.width())\r\n\t      height = new SVG.Number(source.height())\r\n\t\r\n\t      // find nearest non-percentual dimensions\r\n\t      while (width.unit == '%') {\r\n\t        wm *= width.value\r\n\t        width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width())\r\n\t        we = we.parent()\r\n\t      }\r\n\t      while (height.unit == '%') {\r\n\t        hm *= height.value\r\n\t        height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height())\r\n\t        he = he.parent()\r\n\t      }\r\n\t\r\n\t      // ensure defaults\r\n\t      this.x      = 0\r\n\t      this.y      = 0\r\n\t      this.width  = width  * wm\r\n\t      this.height = height * hm\r\n\t      this.zoom   = 1\r\n\t\r\n\t      if (view) {\r\n\t        // get width and height from viewbox\r\n\t        x      = parseFloat(view[0])\r\n\t        y      = parseFloat(view[1])\r\n\t        width  = parseFloat(view[2])\r\n\t        height = parseFloat(view[3])\r\n\t\r\n\t        // calculate zoom accoring to viewbox\r\n\t        this.zoom = ((this.width / this.height) > (width / height)) ?\r\n\t          this.height / height :\r\n\t          this.width  / width\r\n\t\r\n\t        // calculate real pixel dimensions on parent SVG.Doc element\r\n\t        this.x      = x\r\n\t        this.y      = y\r\n\t        this.width  = width\r\n\t        this.height = height\r\n\t\r\n\t      }\r\n\t\r\n\t    }else{\r\n\t\r\n\t      // ensure source as object\r\n\t      source = typeof source === 'string' ?\r\n\t        source.match(reg).map(function(el){ return parseFloat(el) }) :\r\n\t      Array.isArray(source) ?\r\n\t        source :\r\n\t      typeof source == 'object' ?\r\n\t        [source.x, source.y, source.width, source.height] :\r\n\t      arguments.length == 4 ?\r\n\t        [].slice.call(arguments) :\r\n\t        base\r\n\t\r\n\t      this.x = source[0]\r\n\t      this.y = source[1]\r\n\t      this.width = source[2]\r\n\t      this.height = source[3]\r\n\t    }\r\n\t\r\n\t\r\n\t  }\r\n\t\r\n\t, extend: {\r\n\t\r\n\t    toString: function() {\r\n\t      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height\r\n\t    }\r\n\t  , morph: function(x, y, width, height){\r\n\t      this.destination = new SVG.ViewBox(x, y, width, height)\r\n\t      return this\r\n\t    }\r\n\t\r\n\t  , at: function(pos) {\r\n\t\r\n\t      if(!this.destination) return this\r\n\t\r\n\t      return new SVG.ViewBox([\r\n\t          this.x + (this.destination.x - this.x) * pos\r\n\t        , this.y + (this.destination.y - this.y) * pos\r\n\t        , this.width + (this.destination.width - this.width) * pos\r\n\t        , this.height + (this.destination.height - this.height) * pos\r\n\t      ])\r\n\t\r\n\t    }\r\n\t\r\n\t  }\r\n\t\r\n\t  // Define parent\r\n\t, parent: SVG.Container\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t\r\n\t    // get/set viewbox\r\n\t    viewbox: function(x, y, width, height) {\r\n\t      if (arguments.length == 0)\r\n\t        // act as a getter if there are no arguments\r\n\t        return new SVG.ViewBox(this)\r\n\t\r\n\t      // otherwise act as a setter\r\n\t      return this.attr('viewBox', new SVG.ViewBox(x, y, width, height))\r\n\t    }\r\n\t\r\n\t  }\r\n\t\r\n\t})\n\t// Add events to elements\r\n\t;[  'click'\r\n\t  , 'dblclick'\r\n\t  , 'mousedown'\r\n\t  , 'mouseup'\r\n\t  , 'mouseover'\r\n\t  , 'mouseout'\r\n\t  , 'mousemove'\r\n\t  // , 'mouseenter' -> not supported by IE\r\n\t  // , 'mouseleave' -> not supported by IE\r\n\t  , 'touchstart'\r\n\t  , 'touchmove'\r\n\t  , 'touchleave'\r\n\t  , 'touchend'\r\n\t  , 'touchcancel' ].forEach(function(event) {\r\n\t\r\n\t  // add event to SVG.Element\r\n\t  SVG.Element.prototype[event] = function(f) {\r\n\t    // bind event to element rather than element node\r\n\t    SVG.on(this.node, event, f)\r\n\t    return this\r\n\t  }\r\n\t})\r\n\t\r\n\t// Initialize listeners stack\r\n\tSVG.listeners = []\r\n\tSVG.handlerMap = []\r\n\tSVG.listenerId = 0\r\n\t\r\n\t// Add event binder in the SVG namespace\r\n\tSVG.on = function(node, event, listener, binding) {\r\n\t  // create listener, get object-index\r\n\t  var l     = listener.bind(binding || node.instance || node)\r\n\t    , index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1\r\n\t    , ev    = event.split('.')[0]\r\n\t    , ns    = event.split('.')[1] || '*'\r\n\t\r\n\t\r\n\t  // ensure valid object\r\n\t  SVG.listeners[index]         = SVG.listeners[index]         || {}\r\n\t  SVG.listeners[index][ev]     = SVG.listeners[index][ev]     || {}\r\n\t  SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {}\r\n\t\r\n\t  if(!listener._svgjsListenerId)\r\n\t    listener._svgjsListenerId = ++SVG.listenerId\r\n\t\r\n\t  // reference listener\r\n\t  SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l\r\n\t\r\n\t  // add listener\r\n\t  node.addEventListener(ev, l, false)\r\n\t}\r\n\t\r\n\t// Add event unbinder in the SVG namespace\r\n\tSVG.off = function(node, event, listener) {\r\n\t  var index = SVG.handlerMap.indexOf(node)\r\n\t    , ev    = event && event.split('.')[0]\r\n\t    , ns    = event && event.split('.')[1]\r\n\t\r\n\t  if(index == -1) return\r\n\t\r\n\t  if (listener) {\r\n\t    if(typeof listener == 'function') listener = listener._svgjsListenerId\r\n\t    if(!listener) return\r\n\t\r\n\t    // remove listener reference\r\n\t    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {\r\n\t      // remove listener\r\n\t      node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false)\r\n\t\r\n\t      delete SVG.listeners[index][ev][ns || '*'][listener]\r\n\t    }\r\n\t\r\n\t  } else if (ns && ev) {\r\n\t    // remove all listeners for a namespaced event\r\n\t    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {\r\n\t      for (listener in SVG.listeners[index][ev][ns])\r\n\t        SVG.off(node, [ev, ns].join('.'), listener)\r\n\t\r\n\t      delete SVG.listeners[index][ev][ns]\r\n\t    }\r\n\t\r\n\t  } else if (ns){\r\n\t    // remove all listeners for a specific namespace\r\n\t    for(event in SVG.listeners[index]){\r\n\t        for(namespace in SVG.listeners[index][event]){\r\n\t            if(ns === namespace){\r\n\t                SVG.off(node, [event, ns].join('.'))\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t  } else if (ev) {\r\n\t    // remove all listeners for the event\r\n\t    if (SVG.listeners[index][ev]) {\r\n\t      for (namespace in SVG.listeners[index][ev])\r\n\t        SVG.off(node, [ev, namespace].join('.'))\r\n\t\r\n\t      delete SVG.listeners[index][ev]\r\n\t    }\r\n\t\r\n\t  } else {\r\n\t    // remove all listeners on a given node\r\n\t    for (event in SVG.listeners[index])\r\n\t      SVG.off(node, event)\r\n\t\r\n\t    delete SVG.listeners[index]\r\n\t    delete SVG.handlerMap[index]\r\n\t\r\n\t  }\r\n\t}\r\n\t\r\n\t//\r\n\tSVG.extend(SVG.Element, {\r\n\t  // Bind given event to listener\r\n\t  on: function(event, listener, binding) {\r\n\t    SVG.on(this.node, event, listener, binding)\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Unbind event from listener\r\n\t, off: function(event, listener) {\r\n\t    SVG.off(this.node, event, listener)\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Fire given event\r\n\t, fire: function(event, data) {\r\n\t\r\n\t    // Dispatch event\r\n\t    if(event instanceof window.Event){\r\n\t        this.node.dispatchEvent(event)\r\n\t    }else{\r\n\t        this.node.dispatchEvent(event = new window.CustomEvent(event, {detail:data, cancelable: true}))\r\n\t    }\r\n\t\r\n\t    this._event = event\r\n\t    return this\r\n\t  }\r\n\t, event: function() {\r\n\t    return this._event\r\n\t  }\r\n\t})\n\t\r\n\tSVG.Defs = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'defs'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Container\r\n\t\r\n\t})\n\tSVG.G = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'g'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Container\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Move over x-axis\r\n\t    x: function(x) {\r\n\t      return x == null ? this.transform('x') : this.transform({ x: x - this.x() }, true)\r\n\t    }\r\n\t    // Move over y-axis\r\n\t  , y: function(y) {\r\n\t      return y == null ? this.transform('y') : this.transform({ y: y - this.y() }, true)\r\n\t    }\r\n\t    // Move by center over x-axis\r\n\t  , cx: function(x) {\r\n\t      return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2)\r\n\t    }\r\n\t    // Move by center over y-axis\r\n\t  , cy: function(y) {\r\n\t      return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2)\r\n\t    }\r\n\t  , gbox: function() {\r\n\t\r\n\t      var bbox  = this.bbox()\r\n\t        , trans = this.transform()\r\n\t\r\n\t      bbox.x  += trans.x\r\n\t      bbox.x2 += trans.x\r\n\t      bbox.cx += trans.x\r\n\t\r\n\t      bbox.y  += trans.y\r\n\t      bbox.y2 += trans.y\r\n\t      bbox.cy += trans.y\r\n\t\r\n\t      return bbox\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create a group element\r\n\t    group: function() {\r\n\t      return this.put(new SVG.G)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\n\t// ### This module adds backward / forward functionality to elements.\r\n\t\r\n\t//\r\n\tSVG.extend(SVG.Element, {\r\n\t  // Get all siblings, including myself\r\n\t  siblings: function() {\r\n\t    return this.parent().children()\r\n\t  }\r\n\t  // Get the curent position siblings\r\n\t, position: function() {\r\n\t    return this.parent().index(this)\r\n\t  }\r\n\t  // Get the next element (will return null if there is none)\r\n\t, next: function() {\r\n\t    return this.siblings()[this.position() + 1]\r\n\t  }\r\n\t  // Get the next element (will return null if there is none)\r\n\t, previous: function() {\r\n\t    return this.siblings()[this.position() - 1]\r\n\t  }\r\n\t  // Send given element one step forward\r\n\t, forward: function() {\r\n\t    var i = this.position() + 1\r\n\t      , p = this.parent()\r\n\t\r\n\t    // move node one step forward\r\n\t    p.removeElement(this).add(this, i)\r\n\t\r\n\t    // make sure defs node is always at the top\r\n\t    if (p instanceof SVG.Doc)\r\n\t      p.node.appendChild(p.defs().node)\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Send given element one step backward\r\n\t, backward: function() {\r\n\t    var i = this.position()\r\n\t\r\n\t    if (i > 0)\r\n\t      this.parent().removeElement(this).add(this, i - 1)\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Send given element all the way to the front\r\n\t, front: function() {\r\n\t    var p = this.parent()\r\n\t\r\n\t    // Move node forward\r\n\t    p.node.appendChild(this.node)\r\n\t\r\n\t    // Make sure defs node is always at the top\r\n\t    if (p instanceof SVG.Doc)\r\n\t      p.node.appendChild(p.defs().node)\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Send given element all the way to the back\r\n\t, back: function() {\r\n\t    if (this.position() > 0)\r\n\t      this.parent().removeElement(this).add(this, 0)\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Inserts a given element before the targeted element\r\n\t, before: function(element) {\r\n\t    element.remove()\r\n\t\r\n\t    var i = this.position()\r\n\t\r\n\t    this.parent().add(element, i)\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Insters a given element after the targeted element\r\n\t, after: function(element) {\r\n\t    element.remove()\r\n\t\r\n\t    var i = this.position()\r\n\t\r\n\t    this.parent().add(element, i + 1)\r\n\t\r\n\t    return this\r\n\t  }\r\n\t\r\n\t})\n\tSVG.Mask = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: function() {\r\n\t    this.constructor.call(this, SVG.create('mask'))\r\n\t\r\n\t    // keep references to masked elements\r\n\t    this.targets = []\r\n\t  }\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Container\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Unmask all masked elements and remove itself\r\n\t    remove: function() {\r\n\t      // unmask all targets\r\n\t      for (var i = this.targets.length - 1; i >= 0; i--)\r\n\t        if (this.targets[i])\r\n\t          this.targets[i].unmask()\r\n\t      this.targets = []\r\n\t\r\n\t      // remove mask from parent\r\n\t      this.parent().removeElement(this)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create masking element\r\n\t    mask: function() {\r\n\t      return this.defs().put(new SVG.Mask)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\r\n\t\r\n\tSVG.extend(SVG.Element, {\r\n\t  // Distribute mask to svg element\r\n\t  maskWith: function(element) {\r\n\t    // use given mask or create a new one\r\n\t    this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element)\r\n\t\r\n\t    // store reverence on self in mask\r\n\t    this.masker.targets.push(this)\r\n\t\r\n\t    // apply mask\r\n\t    return this.attr('mask', 'url(\"#' + this.masker.attr('id') + '\")')\r\n\t  }\r\n\t  // Unmask element\r\n\t, unmask: function() {\r\n\t    delete this.masker\r\n\t    return this.attr('mask', null)\r\n\t  }\r\n\t\r\n\t})\r\n\t\n\tSVG.ClipPath = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: function() {\r\n\t    this.constructor.call(this, SVG.create('clipPath'))\r\n\t\r\n\t    // keep references to clipped elements\r\n\t    this.targets = []\r\n\t  }\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Container\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Unclip all clipped elements and remove itself\r\n\t    remove: function() {\r\n\t      // unclip all targets\r\n\t      for (var i = this.targets.length - 1; i >= 0; i--)\r\n\t        if (this.targets[i])\r\n\t          this.targets[i].unclip()\r\n\t      this.targets = []\r\n\t\r\n\t      // remove clipPath from parent\r\n\t      this.parent().removeElement(this)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create clipping element\r\n\t    clip: function() {\r\n\t      return this.defs().put(new SVG.ClipPath)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\r\n\t//\r\n\tSVG.extend(SVG.Element, {\r\n\t  // Distribute clipPath to svg element\r\n\t  clipWith: function(element) {\r\n\t    // use given clip or create a new one\r\n\t    this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element)\r\n\t\r\n\t    // store reverence on self in mask\r\n\t    this.clipper.targets.push(this)\r\n\t\r\n\t    // apply mask\r\n\t    return this.attr('clip-path', 'url(\"#' + this.clipper.attr('id') + '\")')\r\n\t  }\r\n\t  // Unclip element\r\n\t, unclip: function() {\r\n\t    delete this.clipper\r\n\t    return this.attr('clip-path', null)\r\n\t  }\r\n\t\r\n\t})\n\tSVG.Gradient = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: function(type) {\r\n\t    this.constructor.call(this, SVG.create(type + 'Gradient'))\r\n\t\r\n\t    // store type\r\n\t    this.type = type\r\n\t  }\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Container\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Add a color stop\r\n\t    at: function(offset, color, opacity) {\r\n\t      return this.put(new SVG.Stop).update(offset, color, opacity)\r\n\t    }\r\n\t    // Update gradient\r\n\t  , update: function(block) {\r\n\t      // remove all stops\r\n\t      this.clear()\r\n\t\r\n\t      // invoke passed block\r\n\t      if (typeof block == 'function')\r\n\t        block.call(this, this)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Return the fill id\r\n\t  , fill: function() {\r\n\t      return 'url(#' + this.id() + ')'\r\n\t    }\r\n\t    // Alias string convertion to fill\r\n\t  , toString: function() {\r\n\t      return this.fill()\r\n\t    }\r\n\t    // custom attr to handle transform\r\n\t  , attr: function(a, b, c) {\r\n\t      if(a == 'transform') a = 'gradientTransform'\r\n\t      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create gradient element in defs\r\n\t    gradient: function(type, block) {\r\n\t      return this.defs().gradient(type, block)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\r\n\t// Add animatable methods to both gradient and fx module\r\n\tSVG.extend(SVG.Gradient, SVG.FX, {\r\n\t  // From position\r\n\t  from: function(x, y) {\r\n\t    return (this._target || this).type == 'radial' ?\r\n\t      this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :\r\n\t      this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })\r\n\t  }\r\n\t  // To position\r\n\t, to: function(x, y) {\r\n\t    return (this._target || this).type == 'radial' ?\r\n\t      this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :\r\n\t      this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })\r\n\t  }\r\n\t})\r\n\t\r\n\t// Base gradient generation\r\n\tSVG.extend(SVG.Defs, {\r\n\t  // define gradient\r\n\t  gradient: function(type, block) {\r\n\t    return this.put(new SVG.Gradient(type)).update(block)\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.Stop = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'stop'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Element\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // add color stops\r\n\t    update: function(o) {\r\n\t      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n\t        o = {\r\n\t          offset:  arguments[0]\r\n\t        , color:   arguments[1]\r\n\t        , opacity: arguments[2]\r\n\t        }\r\n\t      }\r\n\t\r\n\t      // set attributes\r\n\t      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n\t      if (o.color   != null) this.attr('stop-color', o.color)\r\n\t      if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))\r\n\t\r\n\t      return this\r\n\t    }\r\n\t  }\r\n\t\r\n\t})\r\n\t\n\tSVG.Pattern = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'pattern'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Container\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Return the fill id\r\n\t    fill: function() {\r\n\t      return 'url(#' + this.id() + ')'\r\n\t    }\r\n\t    // Update pattern by rebuilding\r\n\t  , update: function(block) {\r\n\t      // remove content\r\n\t      this.clear()\r\n\t\r\n\t      // invoke passed block\r\n\t      if (typeof block == 'function')\r\n\t        block.call(this, this)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Alias string convertion to fill\r\n\t  , toString: function() {\r\n\t      return this.fill()\r\n\t    }\r\n\t    // custom attr to handle transform\r\n\t  , attr: function(a, b, c) {\r\n\t      if(a == 'transform') a = 'patternTransform'\r\n\t      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n\t    }\r\n\t\r\n\t  }\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create pattern element in defs\r\n\t    pattern: function(width, height, block) {\r\n\t      return this.defs().pattern(width, height, block)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.Defs, {\r\n\t  // Define gradient\r\n\t  pattern: function(width, height, block) {\r\n\t    return this.put(new SVG.Pattern).update(block).attr({\r\n\t      x:            0\r\n\t    , y:            0\r\n\t    , width:        width\r\n\t    , height:       height\r\n\t    , patternUnits: 'userSpaceOnUse'\r\n\t    })\r\n\t  }\r\n\t\r\n\t})\n\tSVG.Doc = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: function(element) {\r\n\t    if (element) {\r\n\t      // ensure the presence of a dom element\r\n\t      element = typeof element == 'string' ?\r\n\t        document.getElementById(element) :\r\n\t        element\r\n\t\r\n\t      // If the target is an svg element, use that element as the main wrapper.\r\n\t      // This allows svg.js to work with svg documents as well.\r\n\t      if (element.nodeName == 'svg') {\r\n\t        this.constructor.call(this, element)\r\n\t      } else {\r\n\t        this.constructor.call(this, SVG.create('svg'))\r\n\t        element.appendChild(this.node)\r\n\t        this.size('100%', '100%')\r\n\t      }\r\n\t\r\n\t      // set svg element attributes and ensure defs node\r\n\t      this.namespace().defs()\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Container\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Add namespaces\r\n\t    namespace: function() {\r\n\t      return this\r\n\t        .attr({ xmlns: SVG.ns, version: '1.1' })\r\n\t        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)\r\n\t        .attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns)\r\n\t    }\r\n\t    // Creates and returns defs element\r\n\t  , defs: function() {\r\n\t      if (!this._defs) {\r\n\t        var defs\r\n\t\r\n\t        // Find or create a defs element in this instance\r\n\t        if (defs = this.node.getElementsByTagName('defs')[0])\r\n\t          this._defs = SVG.adopt(defs)\r\n\t        else\r\n\t          this._defs = new SVG.Defs\r\n\t\r\n\t        // Make sure the defs node is at the end of the stack\r\n\t        this.node.appendChild(this._defs.node)\r\n\t      }\r\n\t\r\n\t      return this._defs\r\n\t    }\r\n\t    // custom parent method\r\n\t  , parent: function() {\r\n\t      return this.node.parentNode.nodeName == '#document' ? null : this.node.parentNode\r\n\t    }\r\n\t    // Fix for possible sub-pixel offset. See:\r\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=608812\r\n\t  , spof: function(spof) {\r\n\t      var pos = this.node.getScreenCTM()\r\n\t\r\n\t      if (pos)\r\n\t        this\r\n\t          .style('left', (-pos.e % 1) + 'px')\r\n\t          .style('top',  (-pos.f % 1) + 'px')\r\n\t\r\n\t      return this\r\n\t    }\r\n\t\r\n\t      // Removes the doc from the DOM\r\n\t  , remove: function() {\r\n\t      if(this.parent()) {\r\n\t        this.parent().removeChild(this.node);\r\n\t      }\r\n\t\r\n\t      return this;\r\n\t    }\r\n\t  }\r\n\t\r\n\t})\r\n\t\n\tSVG.Shape = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: function(element) {\r\n\t    this.constructor.call(this, element)\r\n\t  }\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Element\r\n\t\r\n\t})\n\t\r\n\tSVG.Bare = SVG.invent({\r\n\t  // Initialize\r\n\t  create: function(element, inherit) {\r\n\t    // construct element\r\n\t    this.constructor.call(this, SVG.create(element))\r\n\t\r\n\t    // inherit custom methods\r\n\t    if (inherit)\r\n\t      for (var method in inherit.prototype)\r\n\t        if (typeof inherit.prototype[method] === 'function')\r\n\t          this[method] = inherit.prototype[method]\r\n\t  }\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Element\r\n\t\r\n\t  // Add methods\r\n\t, extend: {\r\n\t    // Insert some plain text\r\n\t    words: function(text) {\r\n\t      // remove contents\r\n\t      while (this.node.hasChildNodes())\r\n\t        this.node.removeChild(this.node.lastChild)\r\n\t\r\n\t      // create text node\r\n\t      this.node.appendChild(document.createTextNode(text))\r\n\t\r\n\t      return this\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\r\n\t\r\n\tSVG.extend(SVG.Parent, {\r\n\t  // Create an element that is not described by SVG.js\r\n\t  element: function(element, inherit) {\r\n\t    return this.put(new SVG.Bare(element, inherit))\r\n\t  }\r\n\t})\r\n\t\n\tSVG.Symbol = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'symbol'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Container\r\n\t\r\n\t, construct: {\r\n\t    // create symbol\r\n\t    symbol: function() {\r\n\t      return this.put(new SVG.Symbol)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\n\tSVG.Use = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'use'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Shape\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Use element as a reference\r\n\t    element: function(element, file) {\r\n\t      // Set lined element\r\n\t      return this.attr('href', (file || '') + '#' + element, SVG.xlink)\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create a use element\r\n\t    use: function(element, file) {\r\n\t      return this.put(new SVG.Use).element(element, file)\r\n\t    }\r\n\t  }\r\n\t})\n\tSVG.Rect = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'rect'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Shape\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create a rect element\r\n\t    rect: function(width, height) {\r\n\t      return this.put(new SVG.Rect()).size(width, height)\r\n\t    }\r\n\t  }\r\n\t})\n\tSVG.Circle = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'circle'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Shape\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create circle element, based on ellipse\r\n\t    circle: function(size) {\r\n\t      return this.put(new SVG.Circle).rx(new SVG.Number(size).divide(2)).move(0, 0)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.Circle, SVG.FX, {\r\n\t  // Radius x value\r\n\t  rx: function(rx) {\r\n\t    return this.attr('r', rx)\r\n\t  }\r\n\t  // Alias radius x value\r\n\t, ry: function(ry) {\r\n\t    return this.rx(ry)\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.Ellipse = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'ellipse'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Shape\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create an ellipse\r\n\t    ellipse: function(width, height) {\r\n\t      return this.put(new SVG.Ellipse).size(width, height).move(0, 0)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\r\n\t  // Radius x value\r\n\t  rx: function(rx) {\r\n\t    return this.attr('rx', rx)\r\n\t  }\r\n\t  // Radius y value\r\n\t, ry: function(ry) {\r\n\t    return this.attr('ry', ry)\r\n\t  }\r\n\t})\r\n\t\r\n\t// Add common method\r\n\tSVG.extend(SVG.Circle, SVG.Ellipse, {\r\n\t    // Move over x-axis\r\n\t    x: function(x) {\r\n\t      return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())\r\n\t    }\r\n\t    // Move over y-axis\r\n\t  , y: function(y) {\r\n\t      return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())\r\n\t    }\r\n\t    // Move by center over x-axis\r\n\t  , cx: function(x) {\r\n\t      return x == null ? this.attr('cx') : this.attr('cx', x)\r\n\t    }\r\n\t    // Move by center over y-axis\r\n\t  , cy: function(y) {\r\n\t      return y == null ? this.attr('cy') : this.attr('cy', y)\r\n\t    }\r\n\t    // Set width of element\r\n\t  , width: function(width) {\r\n\t      return width == null ? this.rx() * 2 : this.rx(new SVG.Number(width).divide(2))\r\n\t    }\r\n\t    // Set height of element\r\n\t  , height: function(height) {\r\n\t      return height == null ? this.ry() * 2 : this.ry(new SVG.Number(height).divide(2))\r\n\t    }\r\n\t    // Custom size function\r\n\t  , size: function(width, height) {\r\n\t      var p = proportionalSize(this, width, height)\r\n\t\r\n\t      return this\r\n\t        .rx(new SVG.Number(p.width).divide(2))\r\n\t        .ry(new SVG.Number(p.height).divide(2))\r\n\t    }\r\n\t})\n\tSVG.Line = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'line'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Shape\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Get array\r\n\t    array: function() {\r\n\t      return new SVG.PointArray([\r\n\t        [ this.attr('x1'), this.attr('y1') ]\r\n\t      , [ this.attr('x2'), this.attr('y2') ]\r\n\t      ])\r\n\t    }\r\n\t    // Overwrite native plot() method\r\n\t  , plot: function(x1, y1, x2, y2) {\r\n\t      if (x1 == null)\r\n\t        return this.array()\r\n\t      else if (typeof y1 !== 'undefined')\r\n\t        x1 = { x1: x1, y1: y1, x2: x2, y2: y2 }\r\n\t      else\r\n\t        x1 = new SVG.PointArray(x1).toLine()\r\n\t\r\n\t      return this.attr(x1)\r\n\t    }\r\n\t    // Move by left top corner\r\n\t  , move: function(x, y) {\r\n\t      return this.attr(this.array().move(x, y).toLine())\r\n\t    }\r\n\t    // Set element size to given width and height\r\n\t  , size: function(width, height) {\r\n\t      var p = proportionalSize(this, width, height)\r\n\t\r\n\t      return this.attr(this.array().size(p.width, p.height).toLine())\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create a line element\r\n\t    line: function(x1, y1, x2, y2) {\r\n\t      // make sure plot is called as a setter\r\n\t      // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray\r\n\t      return SVG.Line.prototype.plot.apply(\r\n\t        this.put(new SVG.Line)\r\n\t      , x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]\r\n\t      )\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\n\tSVG.Polyline = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'polyline'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Shape\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create a wrapped polyline element\r\n\t    polyline: function(p) {\r\n\t      // make sure plot is called as a setter\r\n\t      return this.put(new SVG.Polyline).plot(p || new SVG.PointArray)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.Polygon = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'polygon'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Shape\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create a wrapped polygon element\r\n\t    polygon: function(p) {\r\n\t      // make sure plot is called as a setter\r\n\t      return this.put(new SVG.Polygon).plot(p || new SVG.PointArray)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\r\n\t// Add polygon-specific functions\r\n\tSVG.extend(SVG.Polyline, SVG.Polygon, {\r\n\t  // Get array\r\n\t  array: function() {\r\n\t    return this._array || (this._array = new SVG.PointArray(this.attr('points')))\r\n\t  }\r\n\t  // Plot new path\r\n\t, plot: function(p) {\r\n\t    return (p == null) ?\r\n\t      this.array() :\r\n\t      this.clear().attr('points', typeof p == 'string' ? p : (this._array = new SVG.PointArray(p)))\r\n\t  }\r\n\t  // Clear array cache\r\n\t, clear: function() {\r\n\t    delete this._array\r\n\t    return this\r\n\t  }\r\n\t  // Move by left top corner\r\n\t, move: function(x, y) {\r\n\t    return this.attr('points', this.array().move(x, y))\r\n\t  }\r\n\t  // Set element size to given width and height\r\n\t, size: function(width, height) {\r\n\t    var p = proportionalSize(this, width, height)\r\n\t\r\n\t    return this.attr('points', this.array().size(p.width, p.height))\r\n\t  }\r\n\t\r\n\t})\r\n\t\n\t// unify all point to point elements\r\n\tSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\r\n\t  // Define morphable array\r\n\t  morphArray:  SVG.PointArray\r\n\t  // Move by left top corner over x-axis\r\n\t, x: function(x) {\r\n\t    return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n\t  }\r\n\t  // Move by left top corner over y-axis\r\n\t, y: function(y) {\r\n\t    return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n\t  }\r\n\t  // Set width of element\r\n\t, width: function(width) {\r\n\t    var b = this.bbox()\r\n\t\r\n\t    return width == null ? b.width : this.size(width, b.height)\r\n\t  }\r\n\t  // Set height of element\r\n\t, height: function(height) {\r\n\t    var b = this.bbox()\r\n\t\r\n\t    return height == null ? b.height : this.size(b.width, height)\r\n\t  }\r\n\t})\n\tSVG.Path = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'path'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Shape\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Define morphable array\r\n\t    morphArray:  SVG.PathArray\r\n\t    // Get array\r\n\t  , array: function() {\r\n\t      return this._array || (this._array = new SVG.PathArray(this.attr('d')))\r\n\t    }\r\n\t    // Plot new path\r\n\t  , plot: function(d) {\r\n\t      return (d == null) ?\r\n\t        this.array() :\r\n\t        this.clear().attr('d', typeof d == 'string' ? d : (this._array = new SVG.PathArray(d)))\r\n\t    }\r\n\t    // Clear array cache\r\n\t  , clear: function() {\r\n\t      delete this._array\r\n\t      return this\r\n\t    }\r\n\t    // Move by left top corner\r\n\t  , move: function(x, y) {\r\n\t      return this.attr('d', this.array().move(x, y))\r\n\t    }\r\n\t    // Move by left top corner over x-axis\r\n\t  , x: function(x) {\r\n\t      return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n\t    }\r\n\t    // Move by left top corner over y-axis\r\n\t  , y: function(y) {\r\n\t      return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n\t    }\r\n\t    // Set element size to given width and height\r\n\t  , size: function(width, height) {\r\n\t      var p = proportionalSize(this, width, height)\r\n\t\r\n\t      return this.attr('d', this.array().size(p.width, p.height))\r\n\t    }\r\n\t    // Set width of element\r\n\t  , width: function(width) {\r\n\t      return width == null ? this.bbox().width : this.size(width, this.bbox().height)\r\n\t    }\r\n\t    // Set height of element\r\n\t  , height: function(height) {\r\n\t      return height == null ? this.bbox().height : this.size(this.bbox().width, height)\r\n\t    }\r\n\t\r\n\t  }\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create a wrapped path element\r\n\t    path: function(d) {\r\n\t      // make sure plot is called as a setter\r\n\t      return this.put(new SVG.Path).plot(d || new SVG.PathArray)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\n\tSVG.Image = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'image'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Shape\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // (re)load image\r\n\t    load: function(url) {\r\n\t      if (!url) return this\r\n\t\r\n\t      var self = this\r\n\t        , img  = new window.Image()\r\n\t\r\n\t      // preload image\r\n\t      SVG.on(img, 'load', function() {\r\n\t        var p = self.parent(SVG.Pattern)\r\n\t\r\n\t        if(p === null) return\r\n\t\r\n\t        // ensure image size\r\n\t        if (self.width() == 0 && self.height() == 0)\r\n\t          self.size(img.width, img.height)\r\n\t\r\n\t        // ensure pattern size if not set\r\n\t        if (p && p.width() == 0 && p.height() == 0)\r\n\t          p.size(self.width(), self.height())\r\n\t\r\n\t        // callback\r\n\t        if (typeof self._loaded === 'function')\r\n\t          self._loaded.call(self, {\r\n\t            width:  img.width\r\n\t          , height: img.height\r\n\t          , ratio:  img.width / img.height\r\n\t          , url:    url\r\n\t          })\r\n\t      })\r\n\t\r\n\t      SVG.on(img, 'error', function(e){\r\n\t        if (typeof self._error === 'function'){\r\n\t            self._error.call(self, e)\r\n\t        }\r\n\t      })\r\n\t\r\n\t      return this.attr('href', (img.src = this.src = url), SVG.xlink)\r\n\t    }\r\n\t    // Add loaded callback\r\n\t  , loaded: function(loaded) {\r\n\t      this._loaded = loaded\r\n\t      return this\r\n\t    }\r\n\t\r\n\t  , error: function(error) {\r\n\t      this._error = error\r\n\t      return this\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // create image element, load image and set its size\r\n\t    image: function(source, width, height) {\r\n\t      return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)\r\n\t    }\r\n\t  }\r\n\t\r\n\t})\n\tSVG.Text = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: function() {\r\n\t    this.constructor.call(this, SVG.create('text'))\r\n\t\r\n\t    this.dom.leading = new SVG.Number(1.3)    // store leading value for rebuilding\r\n\t    this._rebuild = true                      // enable automatic updating of dy values\r\n\t    this._build   = false                     // disable build mode for adding multiple lines\r\n\t\r\n\t    // set default font\r\n\t    this.attr('font-family', SVG.defaults.attrs['font-family'])\r\n\t  }\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Shape\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Move over x-axis\r\n\t    x: function(x) {\r\n\t      // act as getter\r\n\t      if (x == null)\r\n\t        return this.attr('x')\r\n\t\r\n\t      return this.attr('x', x)\r\n\t    }\r\n\t    // Move over y-axis\r\n\t  , y: function(y) {\r\n\t      var oy = this.attr('y')\r\n\t        , o  = typeof oy === 'number' ? oy - this.bbox().y : 0\r\n\t\r\n\t      // act as getter\r\n\t      if (y == null)\r\n\t        return typeof oy === 'number' ? oy - o : oy\r\n\t\r\n\t      return this.attr('y', typeof y === 'number' ? y + o : y)\r\n\t    }\r\n\t    // Move center over x-axis\r\n\t  , cx: function(x) {\r\n\t      return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)\r\n\t    }\r\n\t    // Move center over y-axis\r\n\t  , cy: function(y) {\r\n\t      return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)\r\n\t    }\r\n\t    // Set the text content\r\n\t  , text: function(text) {\r\n\t      // act as getter\r\n\t      if (typeof text === 'undefined'){\r\n\t        var text = ''\r\n\t        var children = this.node.childNodes\r\n\t        for(var i = 0, len = children.length; i < len; ++i){\r\n\t\r\n\t          // add newline if its not the first child and newLined is set to true\r\n\t          if(i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true){\r\n\t            text += '\\n'\r\n\t          }\r\n\t\r\n\t          // add content of this node\r\n\t          text += children[i].textContent\r\n\t        }\r\n\t\r\n\t        return text\r\n\t      }\r\n\t\r\n\t      // remove existing content\r\n\t      this.clear().build(true)\r\n\t\r\n\t      if (typeof text === 'function') {\r\n\t        // call block\r\n\t        text.call(this, this)\r\n\t\r\n\t      } else {\r\n\t        // store text and make sure text is not blank\r\n\t        text = text.split('\\n')\r\n\t\r\n\t        // build new lines\r\n\t        for (var i = 0, il = text.length; i < il; i++)\r\n\t          this.tspan(text[i]).newLine()\r\n\t      }\r\n\t\r\n\t      // disable build mode and rebuild lines\r\n\t      return this.build(false).rebuild()\r\n\t    }\r\n\t    // Set font size\r\n\t  , size: function(size) {\r\n\t      return this.attr('font-size', size).rebuild()\r\n\t    }\r\n\t    // Set / get leading\r\n\t  , leading: function(value) {\r\n\t      // act as getter\r\n\t      if (value == null)\r\n\t        return this.dom.leading\r\n\t\r\n\t      // act as setter\r\n\t      this.dom.leading = new SVG.Number(value)\r\n\t\r\n\t      return this.rebuild()\r\n\t    }\r\n\t    // Get all the first level lines\r\n\t  , lines: function() {\r\n\t      var node = (this.textPath && this.textPath() || this).node\r\n\t\r\n\t      // filter tspans and map them to SVG.js instances\r\n\t      var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function(el){\r\n\t        return SVG.adopt(el)\r\n\t      })\r\n\t\r\n\t      // return an instance of SVG.set\r\n\t      return new SVG.Set(lines)\r\n\t    }\r\n\t    // Rebuild appearance type\r\n\t  , rebuild: function(rebuild) {\r\n\t      // store new rebuild flag if given\r\n\t      if (typeof rebuild == 'boolean')\r\n\t        this._rebuild = rebuild\r\n\t\r\n\t      // define position of all lines\r\n\t      if (this._rebuild) {\r\n\t        var self = this\r\n\t          , blankLineOffset = 0\r\n\t          , dy = this.dom.leading * new SVG.Number(this.attr('font-size'))\r\n\t\r\n\t        this.lines().each(function() {\r\n\t          if (this.dom.newLined) {\r\n\t            if (!self.textPath())\r\n\t              this.attr('x', self.attr('x'))\r\n\t            if(this.text() == '\\n') {\r\n\t              blankLineOffset += dy\r\n\t            }else{\r\n\t              this.attr('dy', dy + blankLineOffset)\r\n\t              blankLineOffset = 0\r\n\t            }\r\n\t          }\r\n\t        })\r\n\t\r\n\t        this.fire('rebuild')\r\n\t      }\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Enable / disable build mode\r\n\t  , build: function(build) {\r\n\t      this._build = !!build\r\n\t      return this\r\n\t    }\r\n\t    // overwrite method from parent to set data properly\r\n\t  , setData: function(o){\r\n\t      this.dom = o\r\n\t      this.dom.leading = new SVG.Number(o.leading || 1.3)\r\n\t      return this\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create text element\r\n\t    text: function(text) {\r\n\t      return this.put(new SVG.Text).text(text)\r\n\t    }\r\n\t    // Create plain text element\r\n\t  , plain: function(text) {\r\n\t      return this.put(new SVG.Text).plain(text)\r\n\t    }\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.Tspan = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'tspan'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Shape\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Set text content\r\n\t    text: function(text) {\r\n\t      if(text == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '')\r\n\t\r\n\t      typeof text === 'function' ? text.call(this, this) : this.plain(text)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Shortcut dx\r\n\t  , dx: function(dx) {\r\n\t      return this.attr('dx', dx)\r\n\t    }\r\n\t    // Shortcut dy\r\n\t  , dy: function(dy) {\r\n\t      return this.attr('dy', dy)\r\n\t    }\r\n\t    // Create new line\r\n\t  , newLine: function() {\r\n\t      // fetch text parent\r\n\t      var t = this.parent(SVG.Text)\r\n\t\r\n\t      // mark new line\r\n\t      this.dom.newLined = true\r\n\t\r\n\t      // apply new hyn\r\n\t      return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x())\r\n\t    }\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.Text, SVG.Tspan, {\r\n\t  // Create plain text node\r\n\t  plain: function(text) {\r\n\t    // clear if build mode is disabled\r\n\t    if (this._build === false)\r\n\t      this.clear()\r\n\t\r\n\t    // create text node\r\n\t    this.node.appendChild(document.createTextNode(text))\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Create a tspan\r\n\t, tspan: function(text) {\r\n\t    var node  = (this.textPath && this.textPath() || this).node\r\n\t      , tspan = new SVG.Tspan\r\n\t\r\n\t    // clear if build mode is disabled\r\n\t    if (this._build === false)\r\n\t      this.clear()\r\n\t\r\n\t    // add new tspan\r\n\t    node.appendChild(tspan.node)\r\n\t\r\n\t    return tspan.text(text)\r\n\t  }\r\n\t  // Clear all lines\r\n\t, clear: function() {\r\n\t    var node = (this.textPath && this.textPath() || this).node\r\n\t\r\n\t    // remove existing child nodes\r\n\t    while (node.hasChildNodes())\r\n\t      node.removeChild(node.lastChild)\r\n\t\r\n\t    return this\r\n\t  }\r\n\t  // Get length of text element\r\n\t, length: function() {\r\n\t    return this.node.getComputedTextLength()\r\n\t  }\r\n\t})\r\n\t\n\tSVG.TextPath = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'textPath'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Parent\r\n\t\r\n\t  // Define parent class\r\n\t, parent: SVG.Text\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create path for text to run on\r\n\t    path: function(d) {\r\n\t      // create textPath element\r\n\t      var path  = new SVG.TextPath\r\n\t        , track = this.doc().defs().path(d)\r\n\t\r\n\t      // move lines to textpath\r\n\t      while (this.node.hasChildNodes())\r\n\t        path.node.appendChild(this.node.firstChild)\r\n\t\r\n\t      // add textPath element as child node\r\n\t      this.node.appendChild(path.node)\r\n\t\r\n\t      // link textPath to path and add content\r\n\t      path.attr('href', '#' + track, SVG.xlink)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // return the array of the path track element\r\n\t  , array: function() {\r\n\t      var track = this.track()\r\n\t\r\n\t      return track ? track.array() : null\r\n\t    }\r\n\t    // Plot path if any\r\n\t  , plot: function(d) {\r\n\t      var track = this.track()\r\n\t        , pathArray = null\r\n\t\r\n\t      if (track) {\r\n\t        pathArray = track.plot(d)\r\n\t      }\r\n\t\r\n\t      return (d == null) ? pathArray : this\r\n\t    }\r\n\t    // Get the path track element\r\n\t  , track: function() {\r\n\t      var path = this.textPath()\r\n\t\r\n\t      if (path)\r\n\t        return path.reference('href')\r\n\t    }\r\n\t    // Get the textPath child\r\n\t  , textPath: function() {\r\n\t      if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath')\r\n\t        return SVG.adopt(this.node.firstChild)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\n\tSVG.Nested = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: function() {\r\n\t    this.constructor.call(this, SVG.create('svg'))\r\n\t\r\n\t    this.style('overflow', 'visible')\r\n\t  }\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Container\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create nested svg document\r\n\t    nested: function() {\r\n\t      return this.put(new SVG.Nested)\r\n\t    }\r\n\t  }\r\n\t})\n\tSVG.A = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'a'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Container\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Link url\r\n\t    to: function(url) {\r\n\t      return this.attr('href', url, SVG.xlink)\r\n\t    }\r\n\t    // Link show attribute\r\n\t  , show: function(target) {\r\n\t      return this.attr('show', target, SVG.xlink)\r\n\t    }\r\n\t    // Link target attribute\r\n\t  , target: function(target) {\r\n\t      return this.attr('target', target)\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create a hyperlink element\r\n\t    link: function(url) {\r\n\t      return this.put(new SVG.A).to(url)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.Element, {\r\n\t  // Create a hyperlink element\r\n\t  linkTo: function(url) {\r\n\t    var link = new SVG.A\r\n\t\r\n\t    if (typeof url == 'function')\r\n\t      url.call(link, link)\r\n\t    else\r\n\t      link.to(url)\r\n\t\r\n\t    return this.parent().put(link).put(this)\r\n\t  }\r\n\t\r\n\t})\n\tSVG.Marker = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: 'marker'\r\n\t\r\n\t  // Inherit from\r\n\t, inherit: SVG.Container\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Set width of element\r\n\t    width: function(width) {\r\n\t      return this.attr('markerWidth', width)\r\n\t    }\r\n\t    // Set height of element\r\n\t  , height: function(height) {\r\n\t      return this.attr('markerHeight', height)\r\n\t    }\r\n\t    // Set marker refX and refY\r\n\t  , ref: function(x, y) {\r\n\t      return this.attr('refX', x).attr('refY', y)\r\n\t    }\r\n\t    // Update marker\r\n\t  , update: function(block) {\r\n\t      // remove all content\r\n\t      this.clear()\r\n\t\r\n\t      // invoke passed block\r\n\t      if (typeof block == 'function')\r\n\t        block.call(this, this)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Return the fill id\r\n\t  , toString: function() {\r\n\t      return 'url(#' + this.id() + ')'\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    marker: function(width, height, block) {\r\n\t      // Create marker element in defs\r\n\t      return this.defs().marker(width, height, block)\r\n\t    }\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.Defs, {\r\n\t  // Create marker\r\n\t  marker: function(width, height, block) {\r\n\t    // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\r\n\t    return this.put(new SVG.Marker)\r\n\t      .size(width, height)\r\n\t      .ref(width / 2, height / 2)\r\n\t      .viewbox(0, 0, width, height)\r\n\t      .attr('orient', 'auto')\r\n\t      .update(block)\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {\r\n\t  // Create and attach markers\r\n\t  marker: function(marker, width, height, block) {\r\n\t    var attr = ['marker']\r\n\t\r\n\t    // Build attribute name\r\n\t    if (marker != 'all') attr.push(marker)\r\n\t    attr = attr.join('-')\r\n\t\r\n\t    // Set marker attribute\r\n\t    marker = arguments[1] instanceof SVG.Marker ?\r\n\t      arguments[1] :\r\n\t      this.doc().marker(width, height, block)\r\n\t\r\n\t    return this.attr(attr, marker)\r\n\t  }\r\n\t\r\n\t})\n\t// Define list of available attributes for stroke and fill\r\n\tvar sugar = {\r\n\t  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']\r\n\t, fill:   ['color', 'opacity', 'rule']\r\n\t, prefix: function(t, a) {\r\n\t    return a == 'color' ? t : t + '-' + a\r\n\t  }\r\n\t}\r\n\t\r\n\t// Add sugar for fill and stroke\r\n\t;['fill', 'stroke'].forEach(function(m) {\r\n\t  var i, extension = {}\r\n\t\r\n\t  extension[m] = function(o) {\r\n\t    if (typeof o == 'undefined')\r\n\t      return this\r\n\t    if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))\r\n\t      this.attr(m, o)\r\n\t\r\n\t    else\r\n\t      // set all attributes from sugar.fill and sugar.stroke list\r\n\t      for (i = sugar[m].length - 1; i >= 0; i--)\r\n\t        if (o[sugar[m][i]] != null)\r\n\t          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])\r\n\t\r\n\t    return this\r\n\t  }\r\n\t\r\n\t  SVG.extend(SVG.Element, SVG.FX, extension)\r\n\t\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.Element, SVG.FX, {\r\n\t  // Map rotation to transform\r\n\t  rotate: function(d, cx, cy) {\r\n\t    return this.transform({ rotation: d, cx: cx, cy: cy })\r\n\t  }\r\n\t  // Map skew to transform\r\n\t, skew: function(x, y, cx, cy) {\r\n\t    return arguments.length == 1  || arguments.length == 3 ?\r\n\t      this.transform({ skew: x, cx: y, cy: cx }) :\r\n\t      this.transform({ skewX: x, skewY: y, cx: cx, cy: cy })\r\n\t  }\r\n\t  // Map scale to transform\r\n\t, scale: function(x, y, cx, cy) {\r\n\t    return arguments.length == 1  || arguments.length == 3 ?\r\n\t      this.transform({ scale: x, cx: y, cy: cx }) :\r\n\t      this.transform({ scaleX: x, scaleY: y, cx: cx, cy: cy })\r\n\t  }\r\n\t  // Map translate to transform\r\n\t, translate: function(x, y) {\r\n\t    return this.transform({ x: x, y: y })\r\n\t  }\r\n\t  // Map flip to transform\r\n\t, flip: function(a, o) {\r\n\t    o = typeof a == 'number' ? a : o\r\n\t    return this.transform({ flip: a || 'both', offset: o })\r\n\t  }\r\n\t  // Map matrix to transform\r\n\t, matrix: function(m) {\r\n\t    return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m))\r\n\t  }\r\n\t  // Opacity\r\n\t, opacity: function(value) {\r\n\t    return this.attr('opacity', value)\r\n\t  }\r\n\t  // Relative move over x axis\r\n\t, dx: function(x) {\r\n\t    return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true)\r\n\t  }\r\n\t  // Relative move over y axis\r\n\t, dy: function(y) {\r\n\t    return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true)\r\n\t  }\r\n\t  // Relative move over x and y axes\r\n\t, dmove: function(x, y) {\r\n\t    return this.dx(x).dy(y)\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {\r\n\t  // Add x and y radius\r\n\t  radius: function(x, y) {\r\n\t    var type = (this._target || this).type;\r\n\t    return type == 'radial' || type == 'circle' ?\r\n\t      this.attr('r', new SVG.Number(x)) :\r\n\t      this.rx(x).ry(y == null ? x : y)\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.Path, {\r\n\t  // Get path length\r\n\t  length: function() {\r\n\t    return this.node.getTotalLength()\r\n\t  }\r\n\t  // Get point at length\r\n\t, pointAt: function(length) {\r\n\t    return this.node.getPointAtLength(length)\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {\r\n\t  // Set font\r\n\t  font: function(a, v) {\r\n\t    if (typeof a == 'object') {\r\n\t      for (v in a) this.font(v, a[v])\r\n\t    }\r\n\t\r\n\t    return a == 'leading' ?\r\n\t        this.leading(v) :\r\n\t      a == 'anchor' ?\r\n\t        this.attr('text-anchor', v) :\r\n\t      a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ?\r\n\t        this.attr('font-'+ a, v) :\r\n\t        this.attr(a, v)\r\n\t  }\r\n\t})\r\n\t\n\tSVG.Set = SVG.invent({\r\n\t  // Initialize\r\n\t  create: function(members) {\r\n\t    // Set initial state\r\n\t    Array.isArray(members) ? this.members = members : this.clear()\r\n\t  }\r\n\t\r\n\t  // Add class methods\r\n\t, extend: {\r\n\t    // Add element to set\r\n\t    add: function() {\r\n\t      var i, il, elements = [].slice.call(arguments)\r\n\t\r\n\t      for (i = 0, il = elements.length; i < il; i++)\r\n\t        this.members.push(elements[i])\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Remove element from set\r\n\t  , remove: function(element) {\r\n\t      var i = this.index(element)\r\n\t\r\n\t      // remove given child\r\n\t      if (i > -1)\r\n\t        this.members.splice(i, 1)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Iterate over all members\r\n\t  , each: function(block) {\r\n\t      for (var i = 0, il = this.members.length; i < il; i++)\r\n\t        block.apply(this.members[i], [i, this.members])\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Restore to defaults\r\n\t  , clear: function() {\r\n\t      // initialize store\r\n\t      this.members = []\r\n\t\r\n\t      return this\r\n\t    }\r\n\t    // Get the length of a set\r\n\t  , length: function() {\r\n\t      return this.members.length\r\n\t    }\r\n\t    // Checks if a given element is present in set\r\n\t  , has: function(element) {\r\n\t      return this.index(element) >= 0\r\n\t    }\r\n\t    // retuns index of given element in set\r\n\t  , index: function(element) {\r\n\t      return this.members.indexOf(element)\r\n\t    }\r\n\t    // Get member at given index\r\n\t  , get: function(i) {\r\n\t      return this.members[i]\r\n\t    }\r\n\t    // Get first member\r\n\t  , first: function() {\r\n\t      return this.get(0)\r\n\t    }\r\n\t    // Get last member\r\n\t  , last: function() {\r\n\t      return this.get(this.members.length - 1)\r\n\t    }\r\n\t    // Default value\r\n\t  , valueOf: function() {\r\n\t      return this.members\r\n\t    }\r\n\t    // Get the bounding box of all members included or empty box if set has no items\r\n\t  , bbox: function(){\r\n\t      // return an empty box of there are no members\r\n\t      if (this.members.length == 0)\r\n\t        return new SVG.RBox()\r\n\t\r\n\t      // get the first rbox and update the target bbox\r\n\t      var rbox = this.members[0].rbox(this.members[0].doc())\r\n\t\r\n\t      this.each(function() {\r\n\t        // user rbox for correct position and visual representation\r\n\t        rbox = rbox.merge(this.rbox(this.doc()))\r\n\t      })\r\n\t\r\n\t      return rbox\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Add parent method\r\n\t, construct: {\r\n\t    // Create a new set\r\n\t    set: function(members) {\r\n\t      return new SVG.Set(members)\r\n\t    }\r\n\t  }\r\n\t})\r\n\t\r\n\tSVG.FX.Set = SVG.invent({\r\n\t  // Initialize node\r\n\t  create: function(set) {\r\n\t    // store reference to set\r\n\t    this.set = set\r\n\t  }\r\n\t\r\n\t})\r\n\t\r\n\t// Alias methods\r\n\tSVG.Set.inherit = function() {\r\n\t  var m\r\n\t    , methods = []\r\n\t\r\n\t  // gather shape methods\r\n\t  for(var m in SVG.Shape.prototype)\r\n\t    if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')\r\n\t      methods.push(m)\r\n\t\r\n\t  // apply shape aliasses\r\n\t  methods.forEach(function(method) {\r\n\t    SVG.Set.prototype[method] = function() {\r\n\t      for (var i = 0, il = this.members.length; i < il; i++)\r\n\t        if (this.members[i] && typeof this.members[i][method] == 'function')\r\n\t          this.members[i][method].apply(this.members[i], arguments)\r\n\t\r\n\t      return method == 'animate' ? (this.fx || (this.fx = new SVG.FX.Set(this))) : this\r\n\t    }\r\n\t  })\r\n\t\r\n\t  // clear methods for the next round\r\n\t  methods = []\r\n\t\r\n\t  // gather fx methods\r\n\t  for(var m in SVG.FX.prototype)\r\n\t    if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function')\r\n\t      methods.push(m)\r\n\t\r\n\t  // apply fx aliasses\r\n\t  methods.forEach(function(method) {\r\n\t    SVG.FX.Set.prototype[method] = function() {\r\n\t      for (var i = 0, il = this.set.members.length; i < il; i++)\r\n\t        this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)\r\n\t\r\n\t      return this\r\n\t    }\r\n\t  })\r\n\t}\r\n\t\r\n\t\r\n\t\n\t\r\n\tSVG.extend(SVG.Element, {\r\n\t  // Store data values on svg nodes\r\n\t  data: function(a, v, r) {\r\n\t    if (typeof a == 'object') {\r\n\t      for (v in a)\r\n\t        this.data(v, a[v])\r\n\t\r\n\t    } else if (arguments.length < 2) {\r\n\t      try {\r\n\t        return JSON.parse(this.attr('data-' + a))\r\n\t      } catch(e) {\r\n\t        return this.attr('data-' + a)\r\n\t      }\r\n\t\r\n\t    } else {\r\n\t      this.attr(\r\n\t        'data-' + a\r\n\t      , v === null ?\r\n\t          null :\r\n\t        r === true || typeof v === 'string' || typeof v === 'number' ?\r\n\t          v :\r\n\t          JSON.stringify(v)\r\n\t      )\r\n\t    }\r\n\t\r\n\t    return this\r\n\t  }\r\n\t})\n\tSVG.extend(SVG.Element, {\r\n\t  // Remember arbitrary data\r\n\t  remember: function(k, v) {\r\n\t    // remember every item in an object individually\r\n\t    if (typeof arguments[0] == 'object')\r\n\t      for (var v in k)\r\n\t        this.remember(v, k[v])\r\n\t\r\n\t    // retrieve memory\r\n\t    else if (arguments.length == 1)\r\n\t      return this.memory()[k]\r\n\t\r\n\t    // store memory\r\n\t    else\r\n\t      this.memory()[k] = v\r\n\t\r\n\t    return this\r\n\t  }\r\n\t\r\n\t  // Erase a given memory\r\n\t, forget: function() {\r\n\t    if (arguments.length == 0)\r\n\t      this._memory = {}\r\n\t    else\r\n\t      for (var i = arguments.length - 1; i >= 0; i--)\r\n\t        delete this.memory()[arguments[i]]\r\n\t\r\n\t    return this\r\n\t  }\r\n\t\r\n\t  // Initialize or return local memory object\r\n\t, memory: function() {\r\n\t    return this._memory || (this._memory = {})\r\n\t  }\r\n\t\r\n\t})\n\t// Method for getting an element by id\r\n\tSVG.get = function(id) {\r\n\t  var node = document.getElementById(idFromReference(id) || id)\r\n\t  return SVG.adopt(node)\r\n\t}\r\n\t\r\n\t// Select elements by query string\r\n\tSVG.select = function(query, parent) {\r\n\t  return new SVG.Set(\r\n\t    SVG.utils.map((parent || document).querySelectorAll(query), function(node) {\r\n\t      return SVG.adopt(node)\r\n\t    })\r\n\t  )\r\n\t}\r\n\t\r\n\tSVG.extend(SVG.Parent, {\r\n\t  // Scoped select method\r\n\t  select: function(query) {\r\n\t    return SVG.select(query, this.node)\r\n\t  }\r\n\t\r\n\t})\n\tfunction pathRegReplace(a, b, c, d) {\r\n\t  return c + d.replace(SVG.regex.dots, ' .')\r\n\t}\r\n\t\r\n\t// creates deep clone of array\r\n\tfunction array_clone(arr){\r\n\t  var clone = arr.slice(0)\r\n\t  for(var i = clone.length; i--;){\r\n\t    if(Array.isArray(clone[i])){\r\n\t      clone[i] = array_clone(clone[i])\r\n\t    }\r\n\t  }\r\n\t  return clone\r\n\t}\r\n\t\r\n\t// tests if a given element is instance of an object\r\n\tfunction is(el, obj){\r\n\t  return el instanceof obj\r\n\t}\r\n\t\r\n\t// tests if a given selector matches an element\r\n\tfunction matches(el, selector) {\r\n\t  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\r\n\t}\r\n\t\r\n\t// Convert dash-separated-string to camelCase\r\n\tfunction camelCase(s) {\r\n\t  return s.toLowerCase().replace(/-(.)/g, function(m, g) {\r\n\t    return g.toUpperCase()\r\n\t  })\r\n\t}\r\n\t\r\n\t// Capitalize first letter of a string\r\n\tfunction capitalize(s) {\r\n\t  return s.charAt(0).toUpperCase() + s.slice(1)\r\n\t}\r\n\t\r\n\t// Ensure to six-based hex\r\n\tfunction fullHex(hex) {\r\n\t  return hex.length == 4 ?\r\n\t    [ '#',\r\n\t      hex.substring(1, 2), hex.substring(1, 2)\r\n\t    , hex.substring(2, 3), hex.substring(2, 3)\r\n\t    , hex.substring(3, 4), hex.substring(3, 4)\r\n\t    ].join('') : hex\r\n\t}\r\n\t\r\n\t// Component to hex value\r\n\tfunction compToHex(comp) {\r\n\t  var hex = comp.toString(16)\r\n\t  return hex.length == 1 ? '0' + hex : hex\r\n\t}\r\n\t\r\n\t// Calculate proportional width and height values when necessary\r\n\tfunction proportionalSize(element, width, height) {\r\n\t  if (width == null || height == null) {\r\n\t    var box = element.bbox()\r\n\t\r\n\t    if (width == null)\r\n\t      width = box.width / box.height * height\r\n\t    else if (height == null)\r\n\t      height = box.height / box.width * width\r\n\t  }\r\n\t\r\n\t  return {\r\n\t    width:  width\r\n\t  , height: height\r\n\t  }\r\n\t}\r\n\t\r\n\t// Delta transform point\r\n\tfunction deltaTransformPoint(matrix, x, y) {\r\n\t  return {\r\n\t    x: x * matrix.a + y * matrix.c + 0\r\n\t  , y: x * matrix.b + y * matrix.d + 0\r\n\t  }\r\n\t}\r\n\t\r\n\t// Map matrix array to object\r\n\tfunction arrayToMatrix(a) {\r\n\t  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }\r\n\t}\r\n\t\r\n\t// Parse matrix if required\r\n\tfunction parseMatrix(matrix) {\r\n\t  if (!(matrix instanceof SVG.Matrix))\r\n\t    matrix = new SVG.Matrix(matrix)\r\n\t\r\n\t  return matrix\r\n\t}\r\n\t\r\n\t// Add centre point to transform object\r\n\tfunction ensureCentre(o, target) {\r\n\t  o.cx = o.cx == null ? target.bbox().cx : o.cx\r\n\t  o.cy = o.cy == null ? target.bbox().cy : o.cy\r\n\t}\r\n\t\r\n\t// PathArray Helpers\r\n\tfunction arrayToString(a) {\r\n\t  for (var i = 0, il = a.length, s = ''; i < il; i++) {\r\n\t    s += a[i][0]\r\n\t\r\n\t    if (a[i][1] != null) {\r\n\t      s += a[i][1]\r\n\t\r\n\t      if (a[i][2] != null) {\r\n\t        s += ' '\r\n\t        s += a[i][2]\r\n\t\r\n\t        if (a[i][3] != null) {\r\n\t          s += ' '\r\n\t          s += a[i][3]\r\n\t          s += ' '\r\n\t          s += a[i][4]\r\n\t\r\n\t          if (a[i][5] != null) {\r\n\t            s += ' '\r\n\t            s += a[i][5]\r\n\t            s += ' '\r\n\t            s += a[i][6]\r\n\t\r\n\t            if (a[i][7] != null) {\r\n\t              s += ' '\r\n\t              s += a[i][7]\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  return s + ' '\r\n\t}\r\n\t\r\n\t// Deep new id assignment\r\n\tfunction assignNewId(node) {\r\n\t  // do the same for SVG child nodes as well\r\n\t  for (var i = node.childNodes.length - 1; i >= 0; i--)\r\n\t    if (node.childNodes[i] instanceof window.SVGElement)\r\n\t      assignNewId(node.childNodes[i])\r\n\t\r\n\t  return SVG.adopt(node).id(SVG.eid(node.nodeName))\r\n\t}\r\n\t\r\n\t// Add more bounding box properties\r\n\tfunction fullBox(b) {\r\n\t  if (b.x == null) {\r\n\t    b.x      = 0\r\n\t    b.y      = 0\r\n\t    b.width  = 0\r\n\t    b.height = 0\r\n\t  }\r\n\t\r\n\t  b.w  = b.width\r\n\t  b.h  = b.height\r\n\t  b.x2 = b.x + b.width\r\n\t  b.y2 = b.y + b.height\r\n\t  b.cx = b.x + b.width / 2\r\n\t  b.cy = b.y + b.height / 2\r\n\t\r\n\t  return b\r\n\t}\r\n\t\r\n\t// Get id from reference string\r\n\tfunction idFromReference(url) {\r\n\t  var m = url.toString().match(SVG.regex.reference)\r\n\t\r\n\t  if (m) return m[1]\r\n\t}\r\n\t\r\n\t// Create matrix array for looping\r\n\tvar abcdef = 'abcdef'.split('')\n\t// Add CustomEvent to IE9 and IE10\r\n\tif (typeof window.CustomEvent !== 'function') {\r\n\t  // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\r\n\t  var CustomEvent = function(event, options) {\r\n\t    options = options || { bubbles: false, cancelable: false, detail: undefined }\r\n\t    var e = document.createEvent('CustomEvent')\r\n\t    e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)\r\n\t    return e\r\n\t  }\r\n\t\r\n\t  CustomEvent.prototype = window.Event.prototype\r\n\t\r\n\t  window.CustomEvent = CustomEvent\r\n\t}\r\n\t\r\n\t// requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish\r\n\t(function(w) {\r\n\t  var lastTime = 0\r\n\t  var vendors = ['moz', 'webkit']\r\n\t\r\n\t  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n\t    w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']\r\n\t    w.cancelAnimationFrame  = w[vendors[x] + 'CancelAnimationFrame'] ||\r\n\t                              w[vendors[x] + 'CancelRequestAnimationFrame']\r\n\t  }\r\n\t\r\n\t  w.requestAnimationFrame = w.requestAnimationFrame ||\r\n\t    function(callback) {\r\n\t      var currTime = new Date().getTime()\r\n\t      var timeToCall = Math.max(0, 16 - (currTime - lastTime))\r\n\t\r\n\t      var id = w.setTimeout(function() {\r\n\t        callback(currTime + timeToCall)\r\n\t      }, timeToCall)\r\n\t\r\n\t      lastTime = currTime + timeToCall\r\n\t      return id\r\n\t    }\r\n\t\r\n\t  w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;\r\n\t\r\n\t}(window))\r\n\t\r\n\treturn SVG\r\n\t\r\n\t}));\n\n/***/ }),\n\n/***/ 646:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _classCallCheck2 = __webpack_require__(1);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(3);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(2);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _Base = __webpack_require__(22);\n\t\n\tvar _Base2 = _interopRequireDefault(_Base);\n\t\n\tvar _AppConfigParser = __webpack_require__(432);\n\t\n\tvar _AppConfigParser2 = _interopRequireDefault(_AppConfigParser);\n\t\n\tvar _ModuleLoader = __webpack_require__(648);\n\t\n\tvar _ModuleLoader2 = _interopRequireDefault(_ModuleLoader);\n\t\n\tvar _moduleLoader = __webpack_require__(437);\n\t\n\tvar _moduleLoader2 = _interopRequireDefault(_moduleLoader);\n\t\n\tvar _Animation = __webpack_require__(685);\n\t\n\tvar _Animation2 = _interopRequireDefault(_Animation);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * If SVG animations are present on the current page instance this module will be fetched async.\n\t * Once loaded the parser checks which animations are present on the current page and loads the animations from the Animation.repository.\n\t * Thus only SVG animations which are really present will be fetched by the browser, because they can become really complex.\n\t * @extends {BaseModule}\n\t */\n\t\n\tvar AnimationModule = function (_BaseModule) {\n\t\t(0, _inherits3.default)(AnimationModule, _BaseModule);\n\t\n\t\tfunction AnimationModule(config) {\n\t\t\t(0, _classCallCheck3.default)(this, AnimationModule);\n\t\t\treturn (0, _possibleConstructorReturn3.default)(this, _BaseModule.call(this, config));\n\t\t}\n\t\n\t\tAnimationModule.prototype.init = function init() {\n\t\t\t_BaseModule.prototype.init.call(this);\n\t\n\t\t\t_moduleLoader2.default.loadDependencies(_Animation2.default, [_AppConfigParser2.default.getConfig(_ModuleLoader2.default.ANIMATIONS, this.node)]);\n\t\t};\n\t\n\t\treturn AnimationModule;\n\t}(_Base2.default);\n\t\n\texports.default = AnimationModule;\n\n/***/ }),\n\n/***/ 648:\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t/**\r\n\t *\r\n\t * @typedef {object} ModuleLoaderConfig\r\n\t * @property {string} SELECTOR\r\n\t * @property {string} ATTRIBUTE\r\n\t * @property {string} CONFIG_ATTRIBUTE\r\n\t */\n\t\n\texports.default = {\n\t\t/**\r\n\t  * @type ModuleLoaderConfig\r\n\t  */\n\t\tANIMATIONS: {\n\t\t\tSELECTOR: '[data-animation]',\n\t\t\tATTRIBUTE: 'data-animation',\n\t\t\tCONFIG_ATTRIBUTE: 'data-animation-config'\n\t\t}\n\t};\n\n/***/ }),\n\n/***/ 685:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _classCallCheck2 = __webpack_require__(1);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(3);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(2);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _BaseModule = __webpack_require__(431);\n\t\n\tvar _BaseModule2 = _interopRequireDefault(_BaseModule);\n\t\n\tvar _Animation = __webpack_require__(687);\n\t\n\tvar SplitPoints = _interopRequireWildcard(_Animation);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\r\n\t * Repository providing access to SVG animation controllers which will be loaded on demand when a specific animation is present on the current page instance.\r\n\t * @extends {BaseModuleRepository}\r\n\t */\n\t\n\tvar AnimationRepository = function (_BaseModuleRepository) {\n\t\t(0, _inherits3.default)(AnimationRepository, _BaseModuleRepository);\n\t\n\t\tfunction AnimationRepository() {\n\t\t\t(0, _classCallCheck3.default)(this, AnimationRepository);\n\t\t\treturn (0, _possibleConstructorReturn3.default)(this, _BaseModuleRepository.apply(this, arguments));\n\t\t}\n\t\n\t\t/**\r\n\t  * @override\r\n\t  * @returns {AnimationRepository} - repository instance\r\n\t  */\n\t\n\t\tAnimationRepository.prototype.init = function init() {\n\t\t\t_BaseModuleRepository.prototype.init.call(this);\n\t\n\t\t\tthis.registerHandlerForIdentifier(SplitPoints.burgerMenu, 'svg-burger-menu');\n\t\n\t\t\treturn this;\n\t\t};\n\t\n\t\treturn AnimationRepository;\n\t}(_BaseModule2.default);\n\t\n\tvar instance = new AnimationRepository().init();\n\t\n\texports.default = instance;\n\n/***/ }),\n\n/***/ 687:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.burgerMenu = burgerMenu;\n\t/* #if dynamic */\n\t\n\t/**\r\n\t * The burgerMenu splitpoint definiton\r\n\t * @param {function} resolve - call once the module is loaded\r\n\t * @param {function} reject - call when the load fails\r\n\t * @returns {void}\r\n\t */\n\tfunction burgerMenu(resolve, reject) {\n\t\n\t  __webpack_require__.e/* nsure */(16, function (require) {\n\t    resolve(__webpack_require__(650).default);\n\t  });\n\t}\n\t\n\t/* #end */\n\n\t// Temporary for static output versions: Disable split-points and require normally.\n\n\t/* eslint-disable no-redeclare */\n\n\t/* eslint-disable */\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// AnimationModule.chunk.js","/**\n * Basic module class definition providing basic interface functions\n */\nclass BaseModule {\n\n\t/**\n\t * Initialize a module with a config provided by the AppConmoduleConfig\n\t * @param {moduleConfig} moduleConfig - Config parsed from teh DOM\n\t */\n\tconstructor ( moduleConfig ) {\n\n\t\t/**\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.node       = moduleConfig.node;\n\t\t/**\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.config     = moduleConfig.config;\n\t\t/**\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.identifier = moduleConfig.identifier;\n\t}\n\n\tinit () {\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return {string} returns the identifier for the module instance\n\t */\n\tgetIdentifier () {\n\t\treturn this.identifier;\n\t}\n}\n\nexport default BaseModule;\n\n\n\n// WEBPACK FOOTER //\n// ./js/modules/Base.module.js","/*!\n* svg.js - A lightweight library for manipulating and animating SVG.\n* @version 2.5.1\n* https://svgdotjs.github.io/\n*\n* @copyright Wout Fierens <wout@mick-wout.com>\n* @license MIT\n*\n* BUILT: Mon Mar 27 2017 13:30:36 GMT+0200 (Mitteleuropische Sommerzeit)\n*/;\n(function(root, factory) {\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(function(){\r\n      return factory(root, root.document)\r\n    })\r\n  } else if (typeof exports === 'object') {\r\n    module.exports = root.document ? factory(root, root.document) : function(w){ return factory(w, w.document) }\r\n  } else {\r\n    root.SVG = factory(root, root.document)\r\n  }\r\n}(typeof window !== \"undefined\" ? window : this, function(window, document) {\r\n\r\n// The main wrapping element\r\nvar SVG = this.SVG = function(element) {\r\n  if (SVG.supported) {\r\n    element = new SVG.Doc(element)\r\n\r\n    if(!SVG.parser.draw)\r\n      SVG.prepare()\r\n\r\n    return element\r\n  }\r\n}\r\n\r\n// Default namespaces\r\nSVG.ns    = 'http://www.w3.org/2000/svg'\r\nSVG.xmlns = 'http://www.w3.org/2000/xmlns/'\r\nSVG.xlink = 'http://www.w3.org/1999/xlink'\r\nSVG.svgjs = 'http://svgjs.com/svgjs'\r\n\r\n// Svg support test\r\nSVG.supported = (function() {\r\n  return !! document.createElementNS &&\r\n         !! document.createElementNS(SVG.ns,'svg').createSVGRect\r\n})()\r\n\r\n// Don't bother to continue if SVG is not supported\r\nif (!SVG.supported) return false\r\n\r\n// Element id sequence\r\nSVG.did  = 1000\r\n\r\n// Get next named element id\r\nSVG.eid = function(name) {\r\n  return 'Svgjs' + capitalize(name) + (SVG.did++)\r\n}\r\n\r\n// Method for element creation\r\nSVG.create = function(name) {\r\n  // create element\r\n  var element = document.createElementNS(this.ns, name)\r\n\r\n  // apply unique id\r\n  element.setAttribute('id', this.eid(name))\r\n\r\n  return element\r\n}\r\n\r\n// Method for extending objects\r\nSVG.extend = function() {\r\n  var modules, methods, key, i\r\n\r\n  // Get list of modules\r\n  modules = [].slice.call(arguments)\r\n\r\n  // Get object with extensions\r\n  methods = modules.pop()\r\n\r\n  for (i = modules.length - 1; i >= 0; i--)\r\n    if (modules[i])\r\n      for (key in methods)\r\n        modules[i].prototype[key] = methods[key]\r\n\r\n  // Make sure SVG.Set inherits any newly added methods\r\n  if (SVG.Set && SVG.Set.inherit)\r\n    SVG.Set.inherit()\r\n}\r\n\r\n// Invent new element\r\nSVG.invent = function(config) {\r\n  // Create element initializer\r\n  var initializer = typeof config.create == 'function' ?\r\n    config.create :\r\n    function() {\r\n      this.constructor.call(this, SVG.create(config.create))\r\n    }\r\n\r\n  // Inherit prototype\r\n  if (config.inherit)\r\n    initializer.prototype = new config.inherit\r\n\r\n  // Extend with methods\r\n  if (config.extend)\r\n    SVG.extend(initializer, config.extend)\r\n\r\n  // Attach construct method to parent\r\n  if (config.construct)\r\n    SVG.extend(config.parent || SVG.Container, config.construct)\r\n\r\n  return initializer\r\n}\r\n\r\n// Adopt existing svg elements\r\nSVG.adopt = function(node) {\r\n  // check for presence of node\r\n  if (!node) return null\r\n\r\n  // make sure a node isn't already adopted\r\n  if (node.instance) return node.instance\r\n\r\n  // initialize variables\r\n  var element\r\n\r\n  // adopt with element-specific settings\r\n  if (node.nodeName == 'svg')\r\n    element = node.parentNode instanceof window.SVGElement ? new SVG.Nested : new SVG.Doc\r\n  else if (node.nodeName == 'linearGradient')\r\n    element = new SVG.Gradient('linear')\r\n  else if (node.nodeName == 'radialGradient')\r\n    element = new SVG.Gradient('radial')\r\n  else if (SVG[capitalize(node.nodeName)])\r\n    element = new SVG[capitalize(node.nodeName)]\r\n  else\r\n    element = new SVG.Element(node)\r\n\r\n  // ensure references\r\n  element.type  = node.nodeName\r\n  element.node  = node\r\n  node.instance = element\r\n\r\n  // SVG.Class specific preparations\r\n  if (element instanceof SVG.Doc)\r\n    element.namespace().defs()\r\n\r\n  // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\r\n  element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {})\r\n\r\n  return element\r\n}\r\n\r\n// Initialize parsing element\r\nSVG.prepare = function() {\r\n  // Select document body and create invisible svg element\r\n  var body = document.getElementsByTagName('body')[0]\r\n    , draw = (body ? new SVG.Doc(body) :  SVG.adopt(document.documentElement).nested()).size(2, 0)\r\n\r\n  // Create parser object\r\n  SVG.parser = {\r\n    body: body || document.documentElement\r\n  , draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden')\r\n  , poly: draw.polyline().node\r\n  , path: draw.path().node\r\n  , native: SVG.create('svg')\r\n  }\r\n}\r\n\r\nSVG.parser = {\r\n  native: SVG.create('svg')\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', function() {\r\n  if(!SVG.parser.draw)\r\n    SVG.prepare()\r\n}, false)\r\n\n// Storage for regular expressions\r\nSVG.regex = {\r\n  // Parse unit value\r\n  numberAndUnit:    /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i\r\n\r\n  // Parse hex value\r\n, hex:              /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i\r\n\r\n  // Parse rgb value\r\n, rgb:              /rgb\\((\\d+),(\\d+),(\\d+)\\)/\r\n\r\n  // Parse reference id\r\n, reference:        /#([a-z0-9\\-_]+)/i\r\n\r\n  // splits a transformation chain\r\n, transforms:       /\\)\\s*,?\\s*/\r\n\r\n  // Whitespace\r\n, whitespace:       /\\s/g\r\n\r\n  // Test hex value\r\n, isHex:            /^#[a-f0-9]{3,6}$/i\r\n\r\n  // Test rgb value\r\n, isRgb:            /^rgb\\(/\r\n\r\n  // Test css declaration\r\n, isCss:            /[^:]+:[^;]+;?/\r\n\r\n  // Test for blank string\r\n, isBlank:          /^(\\s+)?$/\r\n\r\n  // Test for numeric string\r\n, isNumber:         /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i\r\n\r\n  // Test for percent value\r\n, isPercent:        /^-?[\\d\\.]+%$/\r\n\r\n  // Test for image url\r\n, isImage:          /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i\r\n\r\n  // split at whitespace and comma\r\n, delimiter:        /[\\s,]+/\r\n\r\n  // The following regex are used to parse the d attribute of a path\r\n\r\n  // Matches all hyphens which are not after an exponent\r\n, hyphen:           /([^e])\\-/gi\r\n\r\n  // Replaces and tests for all path letters\r\n, pathLetters:      /[MLHVCSQTAZ]/gi\r\n\r\n  // yes we need this one, too\r\n, isPathLetter:     /[MLHVCSQTAZ]/i\r\n\r\n  // matches 0.154.23.45\r\n, numbersWithDots:  /((\\d?\\.\\d+(?:e[+-]?\\d+)?)((?:\\.\\d+(?:e[+-]?\\d+)?)+))+/gi\r\n\r\n  // matches .\r\n, dots:             /\\./g\r\n}\r\n\nSVG.utils = {\r\n  // Map function\r\n  map: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n\r\n    for (i = 0; i < il; i++)\r\n      result.push(block(array[i]))\r\n\r\n    return result\r\n  }\r\n\r\n  // Filter function\r\n, filter: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n\r\n    for (i = 0; i < il; i++)\r\n      if (block(array[i]))\r\n        result.push(array[i])\r\n\r\n    return result\r\n  }\r\n\r\n  // Degrees to radians\r\n, radians: function(d) {\r\n    return d % 360 * Math.PI / 180\r\n  }\r\n\r\n  // Radians to degrees\r\n, degrees: function(r) {\r\n    return r * 180 / Math.PI % 360\r\n  }\r\n\r\n, filterSVGElements: function(nodes) {\r\n    return this.filter( nodes, function(el) { return el instanceof window.SVGElement })\r\n  }\r\n\r\n}\n\r\nSVG.defaults = {\r\n  // Default attribute values\r\n  attrs: {\r\n    // fill and stroke\r\n    'fill-opacity':     1\r\n  , 'stroke-opacity':   1\r\n  , 'stroke-width':     0\r\n  , 'stroke-linejoin':  'miter'\r\n  , 'stroke-linecap':   'butt'\r\n  , fill:               '#000000'\r\n  , stroke:             '#000000'\r\n  , opacity:            1\r\n    // position\r\n  , x:                  0\r\n  , y:                  0\r\n  , cx:                 0\r\n  , cy:                 0\r\n    // size\r\n  , width:              0\r\n  , height:             0\r\n    // radius\r\n  , r:                  0\r\n  , rx:                 0\r\n  , ry:                 0\r\n    // gradient\r\n  , offset:             0\r\n  , 'stop-opacity':     1\r\n  , 'stop-color':       '#000000'\r\n    // text\r\n  , 'font-size':        16\r\n  , 'font-family':      'Helvetica, Arial, sans-serif'\r\n  , 'text-anchor':      'start'\r\n  }\r\n\r\n}\n// Module for color convertions\r\nSVG.Color = function(color) {\r\n  var match\r\n\r\n  // initialize defaults\r\n  this.r = 0\r\n  this.g = 0\r\n  this.b = 0\r\n\r\n  if(!color) return\r\n\r\n  // parse color\r\n  if (typeof color === 'string') {\r\n    if (SVG.regex.isRgb.test(color)) {\r\n      // get rgb values\r\n      match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace,''))\r\n\r\n      // parse numeric values\r\n      this.r = parseInt(match[1])\r\n      this.g = parseInt(match[2])\r\n      this.b = parseInt(match[3])\r\n\r\n    } else if (SVG.regex.isHex.test(color)) {\r\n      // get hex values\r\n      match = SVG.regex.hex.exec(fullHex(color))\r\n\r\n      // parse numeric values\r\n      this.r = parseInt(match[1], 16)\r\n      this.g = parseInt(match[2], 16)\r\n      this.b = parseInt(match[3], 16)\r\n\r\n    }\r\n\r\n  } else if (typeof color === 'object') {\r\n    this.r = color.r\r\n    this.g = color.g\r\n    this.b = color.b\r\n\r\n  }\r\n\r\n}\r\n\r\nSVG.extend(SVG.Color, {\r\n  // Default to hex conversion\r\n  toString: function() {\r\n    return this.toHex()\r\n  }\r\n  // Build hex value\r\n, toHex: function() {\r\n    return '#'\r\n      + compToHex(this.r)\r\n      + compToHex(this.g)\r\n      + compToHex(this.b)\r\n  }\r\n  // Build rgb value\r\n, toRgb: function() {\r\n    return 'rgb(' + [this.r, this.g, this.b].join() + ')'\r\n  }\r\n  // Calculate true brightness\r\n, brightness: function() {\r\n    return (this.r / 255 * 0.30)\r\n         + (this.g / 255 * 0.59)\r\n         + (this.b / 255 * 0.11)\r\n  }\r\n  // Make color morphable\r\n, morph: function(color) {\r\n    this.destination = new SVG.Color(color)\r\n\r\n    return this\r\n  }\r\n  // Get morphed color at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // normalise pos\r\n    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos\r\n\r\n    // generate morphed color\r\n    return new SVG.Color({\r\n      r: ~~(this.r + (this.destination.r - this.r) * pos)\r\n    , g: ~~(this.g + (this.destination.g - this.g) * pos)\r\n    , b: ~~(this.b + (this.destination.b - this.b) * pos)\r\n    })\r\n  }\r\n\r\n})\r\n\r\n// Testers\r\n\r\n// Test if given value is a color string\r\nSVG.Color.test = function(color) {\r\n  color += ''\r\n  return SVG.regex.isHex.test(color)\r\n      || SVG.regex.isRgb.test(color)\r\n}\r\n\r\n// Test if given value is a rgb object\r\nSVG.Color.isRgb = function(color) {\r\n  return color && typeof color.r == 'number'\r\n               && typeof color.g == 'number'\r\n               && typeof color.b == 'number'\r\n}\r\n\r\n// Test if given value is a color\r\nSVG.Color.isColor = function(color) {\r\n  return SVG.Color.isRgb(color) || SVG.Color.test(color)\r\n}\n// Module for array conversion\r\nSVG.Array = function(array, fallback) {\r\n  array = (array || []).valueOf()\r\n\r\n  // if array is empty and fallback is provided, use fallback\r\n  if (array.length == 0 && fallback)\r\n    array = fallback.valueOf()\r\n\r\n  // parse array\r\n  this.value = this.parse(array)\r\n}\r\n\r\nSVG.extend(SVG.Array, {\r\n  // Make array morphable\r\n  morph: function(array) {\r\n    this.destination = this.parse(array)\r\n\r\n    // normalize length of arrays\r\n    if (this.value.length != this.destination.length) {\r\n      var lastValue       = this.value[this.value.length - 1]\r\n        , lastDestination = this.destination[this.destination.length - 1]\r\n\r\n      while(this.value.length > this.destination.length)\r\n        this.destination.push(lastDestination)\r\n      while(this.value.length < this.destination.length)\r\n        this.value.push(lastValue)\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Clean up any duplicate points\r\n, settle: function() {\r\n    // find all unique values\r\n    for (var i = 0, il = this.value.length, seen = []; i < il; i++)\r\n      if (seen.indexOf(this.value[i]) == -1)\r\n        seen.push(this.value[i])\r\n\r\n    // set new value\r\n    return this.value = seen\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed array\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)\r\n\r\n    return new SVG.Array(array)\r\n  }\r\n  // Convert array to string\r\n, toString: function() {\r\n    return this.value.join(' ')\r\n  }\r\n  // Real value\r\n, valueOf: function() {\r\n    return this.value\r\n  }\r\n  // Parse whitespace separated string\r\n, parse: function(array) {\r\n    array = array.valueOf()\r\n\r\n    // if already is an array, no need to parse it\r\n    if (Array.isArray(array)) return array\r\n\r\n    return this.split(array)\r\n  }\r\n  // Strip unnecessary whitespace\r\n, split: function(string) {\r\n    return string.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n  }\r\n  // Reverse array\r\n, reverse: function() {\r\n    this.value.reverse()\r\n\r\n    return this\r\n  }\r\n, clone: function() {\r\n    var clone = new this.constructor()\r\n    clone.value = array_clone(this.value)\r\n    return clone\r\n  }\r\n})\n// Poly points array\r\nSVG.PointArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [[0,0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PointArray.prototype = new SVG.Array\r\nSVG.PointArray.prototype.constructor = SVG.PointArray\r\n\r\nSVG.extend(SVG.PointArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    // convert to a poly point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i].join(','))\r\n\r\n    return array.join(' ')\r\n  }\r\n  // Convert array to line object\r\n, toLine: function() {\r\n    return {\r\n      x1: this.value[0][0]\r\n    , y1: this.value[0][1]\r\n    , x2: this.value[1][0]\r\n    , y2: this.value[1][1]\r\n    }\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push([\r\n        this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos\r\n      , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos\r\n      ])\r\n\r\n    return new SVG.PointArray(array)\r\n  }\r\n  // Parse point string and flat array\r\n, parse: function(array) {\r\n    var points = []\r\n\r\n    array = array.valueOf()\r\n\r\n    // if it is an array\r\n    if (Array.isArray(array)) {\r\n      // and it is not flat, there is no need to parse it\r\n      if(Array.isArray(array[0])) {\r\n        return array\r\n      }\r\n    } else { // Else, it is considered as a string\r\n      // parse points\r\n      array = array.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n    }\r\n\r\n    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\r\n    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\r\n    if (array.length % 2 !== 0) array.pop()\r\n\r\n    // wrap points in two-tuples and parse points as floats\r\n    for(var i = 0, len = array.length; i < len; i = i + 2)\r\n      points.push([ array[i], array[i+1] ])\r\n\r\n    return points\r\n  }\r\n  // Move point string\r\n, move: function(x, y) {\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    // move every point\r\n    if (!isNaN(x) && !isNaN(y))\r\n      for (var i = this.value.length - 1; i >= 0; i--)\r\n        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]\r\n\r\n    return this\r\n  }\r\n  // Resize poly string\r\n, size: function(width, height) {\r\n    var i, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      if(box.width) this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x\r\n      if(box.height) this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get bounding box of points\r\n, bbox: function() {\r\n    SVG.parser.poly.setAttribute('points', this.toString())\r\n\r\n    return SVG.parser.poly.getBBox()\r\n  }\r\n})\r\n\n// Path points array\r\nSVG.PathArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [['M', 0, 0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PathArray.prototype = new SVG.Array\r\nSVG.PathArray.prototype.constructor = SVG.PathArray\r\n\r\nSVG.extend(SVG.PathArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    return arrayToString(this.value)\r\n  }\r\n  // Move path string\r\n, move: function(x, y) {\r\n    // get bounding box of current situation\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    if (!isNaN(x) && !isNaN(y)) {\r\n      // move every point\r\n      for (var l, i = this.value.length - 1; i >= 0; i--) {\r\n        l = this.value[i][0]\r\n\r\n        if (l == 'M' || l == 'L' || l == 'T')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n\r\n        } else if (l == 'H')  {\r\n          this.value[i][1] += x\r\n\r\n        } else if (l == 'V')  {\r\n          this.value[i][1] += y\r\n\r\n        } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n          this.value[i][3] += x\r\n          this.value[i][4] += y\r\n\r\n          if (l == 'C')  {\r\n            this.value[i][5] += x\r\n            this.value[i][6] += y\r\n          }\r\n\r\n        } else if (l == 'A')  {\r\n          this.value[i][6] += x\r\n          this.value[i][7] += y\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Resize path string\r\n, size: function(width, height) {\r\n    // get bounding box of current situation\r\n    var i, l, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      l = this.value[i][0]\r\n\r\n      if (l == 'M' || l == 'L' || l == 'T')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'H')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n\r\n      } else if (l == 'V')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n        this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y\r\n\r\n        if (l == 'C')  {\r\n          this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x\r\n          this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y\r\n        }\r\n\r\n      } else if (l == 'A')  {\r\n        // resize radii\r\n        this.value[i][1] = (this.value[i][1] * width)  / box.width\r\n        this.value[i][2] = (this.value[i][2] * height) / box.height\r\n\r\n        // move position values\r\n        this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y\r\n      }\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Test if the passed path array use the same path data commands as this path array\r\n, equalCommands: function(pathArray) {\r\n    var i, il, equalCommands\r\n\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    equalCommands = this.value.length === pathArray.value.length\r\n    for(i = 0, il = this.value.length; equalCommands && i < il; i++) {\r\n      equalCommands = this.value[i][0] === pathArray.value[i][0]\r\n    }\r\n\r\n    return equalCommands\r\n  }\r\n  // Make path array morphable\r\n, morph: function(pathArray) {\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    if(this.equalCommands(pathArray)) {\r\n      this.destination = pathArray\r\n    } else {\r\n      this.destination = null\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get morphed path array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    var sourceArray = this.value\r\n      , destinationArray = this.destination.value\r\n      , array = [], pathArray = new SVG.PathArray()\r\n      , i, il, j, jl\r\n\r\n    // Animate has specified in the SVG spec\r\n    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\r\n    for (i = 0, il = sourceArray.length; i < il; i++) {\r\n      array[i] = [sourceArray[i][0]]\r\n      for(j = 1, jl = sourceArray[i].length; j < jl; j++) {\r\n        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos\r\n      }\r\n      // For the two flags of the elliptical arc command, the SVG spec say:\r\n      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\r\n      // Elliptical arc command as an array followed by corresponding indexes:\r\n      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\r\n      //   0    1   2        3                 4             5      6  7\r\n      if(array[i][0] === 'A') {\r\n        array[i][4] = +(array[i][4] != 0)\r\n        array[i][5] = +(array[i][5] != 0)\r\n      }\r\n    }\r\n\r\n    // Directly modify the value of a path array, this is done this way for performance\r\n    pathArray.value = array\r\n    return pathArray\r\n  }\r\n  // Absolutize and parse path to array\r\n, parse: function(array) {\r\n    // if it's already a patharray, no need to parse it\r\n    if (array instanceof SVG.PathArray) return array.valueOf()\r\n\r\n    // prepare for parsing\r\n    var i, x0, y0, s, seg, arr\r\n      , x = 0\r\n      , y = 0\r\n      , paramCnt = { 'M':2, 'L':2, 'H':1, 'V':1, 'C':6, 'S':4, 'Q':4, 'T':2, 'A':7 }\r\n\r\n    if(typeof array == 'string'){\r\n\r\n      array = array\r\n        .replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\r\n        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\r\n        .replace(SVG.regex.hyphen, '$1 -')      // add space before hyphen\r\n        .trim()                                 // trim\r\n        .split(SVG.regex.delimiter)   // split into array\r\n\r\n    }else{\r\n      array = array.reduce(function(prev, curr){\r\n        return [].concat.call(prev, curr)\r\n      }, [])\r\n    }\r\n\r\n    // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\r\n\r\n    var arr = []\r\n\r\n    do{\r\n\r\n      // Test if we have a path letter\r\n      if(SVG.regex.isPathLetter.test(array[0])){\r\n        s = array[0]\r\n        array.shift()\r\n      // If last letter was a move command and we got no new, it defaults to [L]ine\r\n      }else if(s == 'M'){\r\n        s = 'L'\r\n      }else if(s == 'm'){\r\n        s = 'l'\r\n      }\r\n\r\n      // add path letter as first element\r\n      seg = [s.toUpperCase()]\r\n\r\n      // push all necessary parameters to segment\r\n      for(i = 0; i < paramCnt[seg[0]]; ++i){\r\n        seg.push(parseFloat(array.shift()))\r\n      }\r\n\r\n      // upper case\r\n      if(s == seg[0]){\r\n\r\n        if(s == 'M' || s == 'L' || s == 'C' || s == 'Q' || s == 'S' || s == 'T'){\r\n          x = seg[paramCnt[seg[0]]-1]\r\n          y = seg[paramCnt[seg[0]]]\r\n        }else if(s == 'V'){\r\n          y = seg[1]\r\n        }else if(s == 'H'){\r\n          x = seg[1]\r\n        }else if(s == 'A'){\r\n          x = seg[6]\r\n          y = seg[7]\r\n        }\r\n\r\n      // lower case\r\n      }else{\r\n\r\n        // convert relative to absolute values\r\n        if(s == 'm' || s == 'l' || s == 'c' || s == 's' || s == 'q' || s == 't'){\r\n\r\n          seg[1] += x\r\n          seg[2] += y\r\n\r\n          if(seg[3] != null){\r\n            seg[3] += x\r\n            seg[4] += y\r\n          }\r\n\r\n          if(seg[5] != null){\r\n            seg[5] += x\r\n            seg[6] += y\r\n          }\r\n\r\n          // move pointer\r\n          x = seg[paramCnt[seg[0]]-1]\r\n          y = seg[paramCnt[seg[0]]]\r\n\r\n        }else if(s == 'v'){\r\n          seg[1] += y\r\n          y = seg[1]\r\n        }else if(s == 'h'){\r\n          seg[1] += x\r\n          x = seg[1]\r\n        }else if(s == 'a'){\r\n          seg[6] += x\r\n          seg[7] += y\r\n          x = seg[6]\r\n          y = seg[7]\r\n        }\r\n\r\n      }\r\n\r\n      if(seg[0] == 'M'){\r\n        x0 = x\r\n        y0 = y\r\n      }\r\n\r\n      if(seg[0] == 'Z'){\r\n        x = x0\r\n        y = y0\r\n      }\r\n\r\n      arr.push(seg)\r\n\r\n    }while(array.length)\r\n\r\n    return arr\r\n\r\n  }\r\n  // Get bounding box of path\r\n, bbox: function() {\r\n    SVG.parser.path.setAttribute('d', this.toString())\r\n\r\n    return SVG.parser.path.getBBox()\r\n  }\r\n\r\n})\r\n\n// Module for unit convertions\r\nSVG.Number = SVG.invent({\r\n  // Initialize\r\n  create: function(value, unit) {\r\n    // initialize defaults\r\n    this.value = 0\r\n    this.unit  = unit || ''\r\n\r\n    // parse value\r\n    if (typeof value === 'number') {\r\n      // ensure a valid numeric value\r\n      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value\r\n\r\n    } else if (typeof value === 'string') {\r\n      unit = value.match(SVG.regex.numberAndUnit)\r\n\r\n      if (unit) {\r\n        // make value numeric\r\n        this.value = parseFloat(unit[1])\r\n\r\n        // normalize\r\n        if (unit[5] == '%')\r\n          this.value /= 100\r\n        else if (unit[5] == 's')\r\n          this.value *= 1000\r\n\r\n        // store unit\r\n        this.unit = unit[5]\r\n      }\r\n\r\n    } else {\r\n      if (value instanceof SVG.Number) {\r\n        this.value = value.valueOf()\r\n        this.unit  = value.unit\r\n      }\r\n    }\r\n\r\n  }\r\n  // Add methods\r\n, extend: {\r\n    // Stringalize\r\n    toString: function() {\r\n      return (\r\n        this.unit == '%' ?\r\n          ~~(this.value * 1e8) / 1e6:\r\n        this.unit == 's' ?\r\n          this.value / 1e3 :\r\n          this.value\r\n      ) + this.unit\r\n    }\r\n  , toJSON: function() {\r\n      return this.toString()\r\n    }\r\n  , // Convert to primitive\r\n    valueOf: function() {\r\n      return this.value\r\n    }\r\n    // Add number\r\n  , plus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this + number, this.unit || number.unit)\r\n    }\r\n    // Subtract number\r\n  , minus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this - number, this.unit || number.unit)\r\n    }\r\n    // Multiply number\r\n  , times: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this * number, this.unit || number.unit)\r\n    }\r\n    // Divide number\r\n  , divide: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this / number, this.unit || number.unit)\r\n    }\r\n    // Convert to different unit\r\n  , to: function(unit) {\r\n      var number = new SVG.Number(this)\r\n\r\n      if (typeof unit === 'string')\r\n        number.unit = unit\r\n\r\n      return number\r\n    }\r\n    // Make number morphable\r\n  , morph: function(number) {\r\n      this.destination = new SVG.Number(number)\r\n\r\n      if(number.relative) {\r\n        this.destination.value += this.value\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Get morphed number at given position\r\n  , at: function(pos) {\r\n      // Make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // Generate new morphed number\r\n      return new SVG.Number(this.destination)\r\n          .minus(this)\r\n          .times(pos)\r\n          .plus(this)\r\n    }\r\n\r\n  }\r\n})\r\n\n\r\nSVG.Element = SVG.invent({\r\n  // Initialize node\r\n  create: function(node) {\r\n    // make stroke value accessible dynamically\r\n    this._stroke = SVG.defaults.attrs.stroke\r\n    this._event = null\r\n\r\n    // initialize data object\r\n    this.dom = {}\r\n\r\n    // create circular reference\r\n    if (this.node = node) {\r\n      this.type = node.nodeName\r\n      this.node.instance = this\r\n\r\n      // store current attribute value\r\n      this._stroke = node.getAttribute('stroke') || this._stroke\r\n    }\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return this.attr('y', y)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)\r\n    }\r\n    // Move element to given x and y values\r\n  , move: function(x, y) {\r\n      return this.x(x).y(y)\r\n    }\r\n    // Move element by its center\r\n  , center: function(x, y) {\r\n      return this.cx(x).cy(y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return this.attr('width', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('height', height)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .width(new SVG.Number(p.width))\r\n        .height(new SVG.Number(p.height))\r\n    }\r\n    // Clone element\r\n  , clone: function(parent, withData) {\r\n      // write dom data to the dom so the clone can pickup the data\r\n      this.writeDataToDom()\r\n\r\n      // clone element and assign new id\r\n      var clone = assignNewId(this.node.cloneNode(true))\r\n\r\n      // insert the clone in the given parent or after myself\r\n      if(parent) parent.add(clone)\r\n      else this.after(clone)\r\n\r\n      return clone\r\n    }\r\n    // Remove element\r\n  , remove: function() {\r\n      if (this.parent())\r\n        this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n    // Replace element\r\n  , replace: function(element) {\r\n      this.after(element).remove()\r\n\r\n      return element\r\n    }\r\n    // Add element to given container and return self\r\n  , addTo: function(parent) {\r\n      return parent.put(this)\r\n    }\r\n    // Add element to given container and return container\r\n  , putIn: function(parent) {\r\n      return parent.add(this)\r\n    }\r\n    // Get / set id\r\n  , id: function(id) {\r\n      return this.attr('id', id)\r\n    }\r\n    // Checks whether the given point inside the bounding box of the element\r\n  , inside: function(x, y) {\r\n      var box = this.bbox()\r\n\r\n      return x > box.x\r\n          && y > box.y\r\n          && x < box.x + box.width\r\n          && y < box.y + box.height\r\n    }\r\n    // Show element\r\n  , show: function() {\r\n      return this.style('display', '')\r\n    }\r\n    // Hide element\r\n  , hide: function() {\r\n      return this.style('display', 'none')\r\n    }\r\n    // Is element visible?\r\n  , visible: function() {\r\n      return this.style('display') != 'none'\r\n    }\r\n    // Return id on string conversion\r\n  , toString: function() {\r\n      return this.attr('id')\r\n    }\r\n    // Return array of classes on the node\r\n  , classes: function() {\r\n      var attr = this.attr('class')\r\n\r\n      return attr == null ? [] : attr.trim().split(SVG.regex.delimiter)\r\n    }\r\n    // Return true if class exists on the node, false otherwise\r\n  , hasClass: function(name) {\r\n      return this.classes().indexOf(name) != -1\r\n    }\r\n    // Add class to the node\r\n  , addClass: function(name) {\r\n      if (!this.hasClass(name)) {\r\n        var array = this.classes()\r\n        array.push(name)\r\n        this.attr('class', array.join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Remove class from the node\r\n  , removeClass: function(name) {\r\n      if (this.hasClass(name)) {\r\n        this.attr('class', this.classes().filter(function(c) {\r\n          return c != name\r\n        }).join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Toggle the presence of a class on the node\r\n  , toggleClass: function(name) {\r\n      return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)\r\n    }\r\n    // Get referenced element form attribute value\r\n  , reference: function(attr) {\r\n      return SVG.get(this.attr(attr))\r\n    }\r\n    // Returns the parent element instance\r\n  , parent: function(type) {\r\n      var parent = this\r\n\r\n      // check for parent\r\n      if(!parent.node.parentNode) return null\r\n\r\n      // get parent element\r\n      parent = SVG.adopt(parent.node.parentNode)\r\n\r\n      if(!type) return parent\r\n\r\n      // loop trough ancestors if type is given\r\n      while(parent && parent.node instanceof window.SVGElement){\r\n        if(typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent\r\n        parent = SVG.adopt(parent.node.parentNode)\r\n      }\r\n    }\r\n    // Get parent document\r\n  , doc: function() {\r\n      return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)\r\n    }\r\n    // return array of all ancestors of given type up to the root svg\r\n  , parents: function(type) {\r\n      var parents = [], parent = this\r\n\r\n      do{\r\n        parent = parent.parent(type)\r\n        if(!parent || !parent.node) break\r\n\r\n        parents.push(parent)\r\n      } while(parent.parent)\r\n\r\n      return parents\r\n    }\r\n    // matches the element vs a css selector\r\n  , matches: function(selector){\r\n      return matches(this.node, selector)\r\n    }\r\n    // Returns the svg node to call native svg methods on it\r\n  , native: function() {\r\n      return this.node\r\n    }\r\n    // Import raw svg\r\n  , svg: function(svg) {\r\n      // create temporary holder\r\n      var well = document.createElement('svg')\r\n\r\n      // act as a setter if svg is given\r\n      if (svg && this instanceof SVG.Parent) {\r\n        // dump raw svg\r\n        well.innerHTML = '<svg>' + svg.replace(/\\n/, '').replace(/<(\\w+)([^<]+?)\\/>/g, '<$1$2></$1>') + '</svg>'\r\n\r\n        // transplant nodes\r\n        for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)\r\n          this.node.appendChild(well.firstChild.firstChild)\r\n\r\n      // otherwise act as a getter\r\n      } else {\r\n        // create a wrapping svg element in case of partial content\r\n        well.appendChild(svg = document.createElement('svg'))\r\n\r\n        // write svgjs data to the dom\r\n        this.writeDataToDom()\r\n\r\n        // insert a copy of this node\r\n        svg.appendChild(this.node.cloneNode(true))\r\n\r\n        // return target element\r\n        return well.innerHTML.replace(/^<svg>/, '').replace(/<\\/svg>$/, '')\r\n      }\r\n\r\n      return this\r\n    }\r\n  // write svgjs data to the dom\r\n  , writeDataToDom: function() {\r\n\r\n      // dump variables recursively\r\n      if(this.each || this.lines){\r\n        var fn = this.each ? this : this.lines();\r\n        fn.each(function(){\r\n          this.writeDataToDom()\r\n        })\r\n      }\r\n\r\n      // remove previously set data\r\n      this.node.removeAttribute('svgjs:data')\r\n\r\n      if(Object.keys(this.dom).length)\r\n        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)) // see #428\r\n\r\n      return this\r\n    }\r\n  // set given data to the elements data property\r\n  , setData: function(o){\r\n      this.dom = o\r\n      return this\r\n    }\r\n  , is: function(obj){\r\n      return is(this, obj)\r\n    }\r\n  }\r\n})\r\n\nSVG.easing = {\r\n  '-': function(pos){return pos}\r\n, '<>':function(pos){return -Math.cos(pos * Math.PI) / 2 + 0.5}\r\n, '>': function(pos){return  Math.sin(pos * Math.PI / 2)}\r\n, '<': function(pos){return -Math.cos(pos * Math.PI / 2) + 1}\r\n}\r\n\r\nSVG.morph = function(pos){\r\n  return function(from, to) {\r\n    return new SVG.MorphObj(from, to).at(pos)\r\n  }\r\n}\r\n\r\nSVG.Situation = SVG.invent({\r\n\r\n  create: function(o){\r\n    this.init = false\r\n    this.reversed = false\r\n    this.reversing = false\r\n\r\n    this.duration = new SVG.Number(o.duration).valueOf()\r\n    this.delay = new SVG.Number(o.delay).valueOf()\r\n\r\n    this.start = +new Date() + this.delay\r\n    this.finish = this.start + this.duration\r\n    this.ease = o.ease\r\n\r\n    // this.loop is incremented from 0 to this.loops\r\n    // it is also incremented when in an infinite loop (when this.loops is true)\r\n    this.loop = 0\r\n    this.loops = false\r\n\r\n    this.animations = {\r\n      // functionToCall: [list of morphable objects]\r\n      // e.g. move: [SVG.Number, SVG.Number]\r\n    }\r\n\r\n    this.attrs = {\r\n      // holds all attributes which are not represented from a function svg.js provides\r\n      // e.g. someAttr: SVG.Number\r\n    }\r\n\r\n    this.styles = {\r\n      // holds all styles which should be animated\r\n      // e.g. fill-color: SVG.Color\r\n    }\r\n\r\n    this.transforms = [\r\n      // holds all transformations as transformation objects\r\n      // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\r\n    ]\r\n\r\n    this.once = {\r\n      // functions to fire at a specific position\r\n      // e.g. \"0.5\": function foo(){}\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\n\r\nSVG.FX = SVG.invent({\r\n\r\n  create: function(element) {\r\n    this._target = element\r\n    this.situations = []\r\n    this.active = false\r\n    this.situation = null\r\n    this.paused = false\r\n    this.lastPos = 0\r\n    this.pos = 0\r\n    // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\r\n    // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\r\n    this.absPos = 0\r\n    this._speed = 1\r\n  }\r\n\r\n, extend: {\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\r\n     * @param ease function || string Function which should be used for easing or easing keyword\r\n     * @param delay Number indicating the delay before the animation starts\r\n     * @return target || this\r\n     */\r\n    animate: function(o, ease, delay){\r\n\r\n      if(typeof o == 'object'){\r\n        ease = o.ease\r\n        delay = o.delay\r\n        o = o.duration\r\n      }\r\n\r\n      var situation = new SVG.Situation({\r\n        duration: o || 1000,\r\n        delay: delay || 0,\r\n        ease: SVG.easing[ease || '-'] || ease\r\n      })\r\n\r\n      this.queue(situation)\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * sets a delay before the next element of the queue is called\r\n     * @param delay Duration of delay in milliseconds\r\n     * @return this.target()\r\n     */\r\n  , delay: function(delay){\r\n      // The delay is performed by an empty situation with its duration\r\n      // attribute set to the duration of the delay\r\n      var situation = new SVG.Situation({\r\n        duration: delay,\r\n        delay: 0,\r\n        ease: SVG.easing['-']\r\n      })\r\n\r\n      return this.queue(situation)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param null || target SVG.Element which should be set as new target\r\n     * @return target || this\r\n     */\r\n  , target: function(target){\r\n      if(target && target instanceof SVG.Element){\r\n        this._target = target\r\n        return this\r\n      }\r\n\r\n      return this._target\r\n    }\r\n\r\n    // returns the absolute position at a given time\r\n  , timeToAbsPos: function(timestamp){\r\n      return (timestamp - this.situation.start) / (this.situation.duration/this._speed)\r\n    }\r\n\r\n    // returns the timestamp from a given absolute positon\r\n  , absPosToTime: function(absPos){\r\n      return this.situation.duration/this._speed * absPos + this.situation.start\r\n    }\r\n\r\n    // starts the animationloop\r\n  , startAnimFrame: function(){\r\n      this.stopAnimFrame()\r\n      this.animationFrame = window.requestAnimationFrame(function(){ this.step() }.bind(this))\r\n    }\r\n\r\n    // cancels the animationframe\r\n  , stopAnimFrame: function(){\r\n      window.cancelAnimationFrame(this.animationFrame)\r\n    }\r\n\r\n    // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\r\n  , start: function(){\r\n      // dont start if already started\r\n      if(!this.active && this.situation){\r\n        this.active = true\r\n        this.startCurrent()\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // start the current situation\r\n  , startCurrent: function(){\r\n      this.situation.start = +new Date + this.situation.delay/this._speed\r\n      this.situation.finish = this.situation.start + this.situation.duration/this._speed\r\n      return this.initAnimations().step()\r\n    }\r\n\r\n    /**\r\n     * adds a function / Situation to the animation queue\r\n     * @param fn function / situation to add\r\n     * @return this\r\n     */\r\n  , queue: function(fn){\r\n      if(typeof fn == 'function' || fn instanceof SVG.Situation)\r\n        this.situations.push(fn)\r\n\r\n      if(!this.situation) this.situation = this.situations.shift()\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * pulls next element from the queue and execute it\r\n     * @return this\r\n     */\r\n  , dequeue: function(){\r\n      // stop current animation\r\n      this.stop()\r\n\r\n      // get next animation from queue\r\n      this.situation = this.situations.shift()\r\n\r\n      if(this.situation){\r\n        if(this.situation instanceof SVG.Situation) {\r\n          this.start()\r\n        } else {\r\n          // If it is not a SVG.Situation, then it is a function, we execute it\r\n          this.situation.call(this)\r\n        }\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // updates all animations to the current state of the element\r\n    // this is important when one property could be changed from another property\r\n  , initAnimations: function() {\r\n      var i, source\r\n      var s = this.situation\r\n\r\n      if(s.init) return this\r\n\r\n      for(i in s.animations){\r\n        source = this.target()[i]()\r\n\r\n        // The condition is because some methods return a normal number instead\r\n        // of a SVG.Number\r\n        if(s.animations[i] instanceof SVG.Number)\r\n          source = new SVG.Number(source)\r\n\r\n        s.animations[i] = source.morph(s.animations[i])\r\n      }\r\n\r\n      for(i in s.attrs){\r\n        s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i])\r\n      }\r\n\r\n      for(i in s.styles){\r\n        s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i])\r\n      }\r\n\r\n      s.initialTransformation = this.target().matrixify()\r\n\r\n      s.init = true\r\n      return this\r\n    }\r\n  , clearQueue: function(){\r\n      this.situations = []\r\n      return this\r\n    }\r\n  , clearCurrent: function(){\r\n      this.situation = null\r\n      return this\r\n    }\r\n    /** stops the animation immediately\r\n     * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\r\n     * @param clearQueue A Boolean indicating whether to remove queued animation as well.\r\n     * @return this\r\n     */\r\n  , stop: function(jumpToEnd, clearQueue){\r\n      var active = this.active\r\n      this.active = false\r\n\r\n      if(clearQueue){\r\n        this.clearQueue()\r\n      }\r\n\r\n      if(jumpToEnd && this.situation){\r\n        // initialize the situation if it was not\r\n        !active && this.startCurrent()\r\n        this.atEnd()\r\n      }\r\n\r\n      this.stopAnimFrame()\r\n\r\n      return this.clearCurrent()\r\n    }\r\n\r\n    /** resets the element to the state where the current element has started\r\n     * @return this\r\n     */\r\n  , reset: function(){\r\n      if(this.situation){\r\n        var temp = this.situation\r\n        this.stop()\r\n        this.situation = temp\r\n        this.atStart()\r\n      }\r\n      return this\r\n    }\r\n\r\n    // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.\r\n  , finish: function(){\r\n\r\n      this.stop(true, false)\r\n\r\n      while(this.dequeue().situation && this.stop(true, false));\r\n\r\n      this.clearQueue().clearCurrent()\r\n\r\n      return this\r\n    }\r\n\r\n    // set the internal animation pointer at the start position, before any loops, and updates the visualisation\r\n  , atStart: function() {\r\n      return this.at(0, true)\r\n    }\r\n\r\n    // set the internal animation pointer at the end position, after all the loops, and updates the visualisation\r\n  , atEnd: function() {\r\n      if (this.situation.loops === true) {\r\n        // If in a infinite loop, we end the current iteration\r\n        this.situation.loops = this.situation.loop + 1\r\n      }\r\n\r\n      if(typeof this.situation.loops == 'number') {\r\n        // If performing a finite number of loops, we go after all the loops\r\n        return this.at(this.situation.loops, true)\r\n      } else {\r\n        // If no loops, we just go at the end\r\n        return this.at(1, true)\r\n      }\r\n    }\r\n\r\n    // set the internal animation pointer to the specified position and updates the visualisation\r\n    // if isAbsPos is true, pos is treated as an absolute position\r\n  , at: function(pos, isAbsPos){\r\n      var durDivSpd = this.situation.duration/this._speed\r\n\r\n      this.absPos = pos\r\n      // If pos is not an absolute position, we convert it into one\r\n      if (!isAbsPos) {\r\n        if (this.situation.reversed) this.absPos = 1 - this.absPos\r\n        this.absPos += this.situation.loop\r\n      }\r\n\r\n      this.situation.start = +new Date - this.absPos * durDivSpd\r\n      this.situation.finish = this.situation.start + durDivSpd\r\n\r\n      return this.step(true)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the speed of the animations\r\n     * @param speed null || Number The new speed of the animations\r\n     * @return Number || this\r\n     */\r\n  , speed: function(speed){\r\n      if (speed === 0) return this.pause()\r\n\r\n      if (speed) {\r\n        this._speed = speed\r\n        // We use an absolute position here so that speed can affect the delay before the animation\r\n        return this.at(this.absPos, true)\r\n      } else return this._speed\r\n    }\r\n\r\n    // Make loopable\r\n  , loop: function(times, reverse) {\r\n      var c = this.last()\r\n\r\n      // store total loops\r\n      c.loops = (times != null) ? times : true\r\n      c.loop = 0\r\n\r\n      if(reverse) c.reversing = true\r\n      return this\r\n    }\r\n\r\n    // pauses the animation\r\n  , pause: function(){\r\n      this.paused = true\r\n      this.stopAnimFrame()\r\n\r\n      return this\r\n    }\r\n\r\n    // unpause the animation\r\n  , play: function(){\r\n      if(!this.paused) return this\r\n      this.paused = false\r\n      // We use an absolute position here so that the delay before the animation can be paused\r\n      return this.at(this.absPos, true)\r\n    }\r\n\r\n    /**\r\n     * toggle or set the direction of the animation\r\n     * true sets direction to backwards while false sets it to forwards\r\n     * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)\r\n     * @return this\r\n     */\r\n  , reverse: function(reversed){\r\n      var c = this.last()\r\n\r\n      if(typeof reversed == 'undefined') c.reversed = !c.reversed\r\n      else c.reversed = reversed\r\n\r\n      return this\r\n    }\r\n\r\n\r\n    /**\r\n     * returns a float from 0-1 indicating the progress of the current animation\r\n     * @param eased Boolean indicating whether the returned position should be eased or not\r\n     * @return number\r\n     */\r\n  , progress: function(easeIt){\r\n      return easeIt ? this.situation.ease(this.pos) : this.pos\r\n    }\r\n\r\n    /**\r\n     * adds a callback function which is called when the current animation is finished\r\n     * @param fn Function which should be executed as callback\r\n     * @return number\r\n     */\r\n  , after: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function wrapper(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, c)\r\n              this.off('finished.fx', wrapper) // prevent memory leak\r\n            }\r\n          }\r\n\r\n      this.target().on('finished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // adds a callback which is called whenever one animation step is performed\r\n  , during: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c)\r\n            }\r\n          }\r\n\r\n      // see above\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.after(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls after ALL animations in the queue are finished\r\n  , afterAll: function(fn){\r\n      var wrapper = function wrapper(e){\r\n            fn.call(this)\r\n            this.off('allfinished.fx', wrapper)\r\n          }\r\n\r\n      // see above\r\n      this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls on every animation step for all animations\r\n  , duringAll: function(fn){\r\n      var wrapper = function(e){\r\n            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation)\r\n          }\r\n\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.afterAll(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n  , last: function(){\r\n      return this.situations.length ? this.situations[this.situations.length-1] : this.situation\r\n    }\r\n\r\n    // adds one property to the animations\r\n  , add: function(method, args, type){\r\n      this.last()[type || 'animations'][method] = args\r\n      return this._callStart()\r\n    }\r\n\r\n    /** perform one step of the animation\r\n     *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\r\n     *  @return this\r\n     */\r\n  , step: function(ignoreTime){\r\n\r\n      // convert current time to an absolute position\r\n      if(!ignoreTime) this.absPos = this.timeToAbsPos(+new Date)\r\n\r\n      // This part convert an absolute position to a position\r\n      if(this.situation.loops !== false) {\r\n        var absPos, absPosInt, lastLoop\r\n\r\n        // If the absolute position is below 0, we just treat it as if it was 0\r\n        absPos = Math.max(this.absPos, 0)\r\n        absPosInt = Math.floor(absPos)\r\n\r\n        if(this.situation.loops === true || absPosInt < this.situation.loops) {\r\n          this.pos = absPos - absPosInt\r\n          lastLoop = this.situation.loop\r\n          this.situation.loop = absPosInt\r\n        } else {\r\n          this.absPos = this.situation.loops\r\n          this.pos = 1\r\n          // The -1 here is because we don't want to toggle reversed when all the loops have been completed\r\n          lastLoop = this.situation.loop - 1\r\n          this.situation.loop = this.situation.loops\r\n        }\r\n\r\n        if(this.situation.reversing) {\r\n          // Toggle reversed if an odd number of loops as occured since the last call of step\r\n          this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2)\r\n        }\r\n\r\n      } else {\r\n        // If there are no loop, the absolute position must not be above 1\r\n        this.absPos = Math.min(this.absPos, 1)\r\n        this.pos = this.absPos\r\n      }\r\n\r\n      // while the absolute position can be below 0, the position must not be below 0\r\n      if(this.pos < 0) this.pos = 0\r\n\r\n      if(this.situation.reversed) this.pos = 1 - this.pos\r\n\r\n\r\n      // apply easing\r\n      var eased = this.situation.ease(this.pos)\r\n\r\n      // call once-callbacks\r\n      for(var i in this.situation.once){\r\n        if(i > this.lastPos && i <= eased){\r\n          this.situation.once[i].call(this.target(), this.pos, eased)\r\n          delete this.situation.once[i]\r\n        }\r\n      }\r\n\r\n      // fire during callback with position, eased position and current situation as parameter\r\n      if(this.active) this.target().fire('during', {pos: this.pos, eased: eased, fx: this, situation: this.situation})\r\n\r\n      // the user may call stop or finish in the during callback\r\n      // so make sure that we still have a valid situation\r\n      if(!this.situation){\r\n        return this\r\n      }\r\n\r\n      // apply the actual animation to every property\r\n      this.eachAt()\r\n\r\n      // do final code when situation is finished\r\n      if((this.pos == 1 && !this.situation.reversed) || (this.situation.reversed && this.pos == 0)){\r\n\r\n        // stop animation callback\r\n        this.stopAnimFrame()\r\n\r\n        // fire finished callback with current situation as parameter\r\n        this.target().fire('finished', {fx:this, situation: this.situation})\r\n\r\n        if(!this.situations.length){\r\n          this.target().fire('allfinished')\r\n          this.target().off('.fx') // there shouldnt be any binding left, but to make sure...\r\n          this.active = false\r\n        }\r\n\r\n        // start next animation\r\n        if(this.active) this.dequeue()\r\n        else this.clearCurrent()\r\n\r\n      }else if(!this.paused && this.active){\r\n        // we continue animating when we are not at the end\r\n        this.startAnimFrame()\r\n      }\r\n\r\n      // save last eased position for once callback triggering\r\n      this.lastPos = eased\r\n      return this\r\n\r\n    }\r\n\r\n    // calculates the step for every property and calls block with it\r\n  , eachAt: function(){\r\n      var i, at, self = this, target = this.target(), s = this.situation\r\n\r\n      // apply animations which can be called trough a method\r\n      for(i in s.animations){\r\n\r\n        at = [].concat(s.animations[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target[i].apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with attr()\r\n      for(i in s.attrs){\r\n\r\n        at = [i].concat(s.attrs[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.attr.apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with style()\r\n      for(i in s.styles){\r\n\r\n        at = [i].concat(s.styles[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.style.apply(target, at)\r\n\r\n      }\r\n\r\n      // animate initialTransformation which has to be chained\r\n      if(s.transforms.length){\r\n\r\n        // get initial initialTransformation\r\n        at = s.initialTransformation\r\n        for(i = 0, len = s.transforms.length; i < len; i++){\r\n\r\n          // get next transformation in chain\r\n          var a = s.transforms[i]\r\n\r\n          // multiply matrix directly\r\n          if(a instanceof SVG.Matrix){\r\n\r\n            if(a.relative){\r\n              at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)))\r\n            }else{\r\n              at = at.morph(a).at(s.ease(this.pos))\r\n            }\r\n            continue\r\n          }\r\n\r\n          // when transformation is absolute we have to reset the needed transformation first\r\n          if(!a.relative)\r\n            a.undo(at.extract())\r\n\r\n          // and reapply it after\r\n          at = at.multiply(a.at(s.ease(this.pos)))\r\n\r\n        }\r\n\r\n        // set new matrix on element\r\n        target.matrix(at)\r\n      }\r\n\r\n      return this\r\n\r\n    }\r\n\r\n\r\n    // adds an once-callback which is called at a specific position and never again\r\n  , once: function(pos, fn, isEased){\r\n\r\n      if(!isEased)pos = this.situation.ease(pos)\r\n\r\n      this.situation.once[pos] = fn\r\n\r\n      return this\r\n    }\r\n\r\n  , _callStart: function() {\r\n      setTimeout(function(){this.start()}.bind(this), 0)\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n, parent: SVG.Element\r\n\r\n  // Add method to parent elements\r\n, construct: {\r\n    // Get fx module or create a new one, then animate with given duration and ease\r\n    animate: function(o, ease, delay) {\r\n      return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay)\r\n    }\r\n  , delay: function(delay){\r\n      return (this.fx || (this.fx = new SVG.FX(this))).delay(delay)\r\n    }\r\n  , stop: function(jumpToEnd, clearQueue) {\r\n      if (this.fx)\r\n        this.fx.stop(jumpToEnd, clearQueue)\r\n\r\n      return this\r\n    }\r\n  , finish: function() {\r\n      if (this.fx)\r\n        this.fx.finish()\r\n\r\n      return this\r\n    }\r\n    // Pause current animation\r\n  , pause: function() {\r\n      if (this.fx)\r\n        this.fx.pause()\r\n\r\n      return this\r\n    }\r\n    // Play paused current animation\r\n  , play: function() {\r\n      if (this.fx)\r\n        this.fx.play()\r\n\r\n      return this\r\n    }\r\n    // Set/Get the speed of the animations\r\n  , speed: function(speed) {\r\n      if (this.fx)\r\n        if (speed == null)\r\n          return this.fx.speed()\r\n        else\r\n          this.fx.speed(speed)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\n// MorphObj is used whenever no morphable object is given\r\nSVG.MorphObj = SVG.invent({\r\n\r\n  create: function(from, to){\r\n    // prepare color for morphing\r\n    if(SVG.Color.isColor(to)) return new SVG.Color(from).morph(to)\r\n    // prepare number for morphing\r\n    if(SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to)\r\n\r\n    // prepare for plain morphing\r\n    this.value = from\r\n    this.destination = to\r\n  }\r\n\r\n, extend: {\r\n    at: function(pos, real){\r\n      return real < 1 ? this.value : this.destination\r\n    },\r\n\r\n    valueOf: function(){\r\n      return this.value\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  // Add animatable attributes\r\n  attr: function(a, v, relative) {\r\n    // apply attributes individually\r\n    if (typeof a == 'object') {\r\n      for (var key in a)\r\n        this.attr(key, a[key])\r\n\r\n    } else {\r\n      this.add(a, v, 'attrs')\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable styles\r\n, style: function(s, v) {\r\n    if (typeof s == 'object')\r\n      for (var key in s)\r\n        this.style(key, s[key])\r\n\r\n    else\r\n      this.add(s, v, 'styles')\r\n\r\n    return this\r\n  }\r\n  // Animatable x-axis\r\n, x: function(x, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({x:x}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(x)\r\n    num.relative = relative\r\n    return this.add('x', num)\r\n  }\r\n  // Animatable y-axis\r\n, y: function(y, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({y:y}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(y)\r\n    num.relative = relative\r\n    return this.add('y', num)\r\n  }\r\n  // Animatable center x-axis\r\n, cx: function(x) {\r\n    return this.add('cx', new SVG.Number(x))\r\n  }\r\n  // Animatable center y-axis\r\n, cy: function(y) {\r\n    return this.add('cy', new SVG.Number(y))\r\n  }\r\n  // Add animatable move\r\n, move: function(x, y) {\r\n    return this.x(x).y(y)\r\n  }\r\n  // Add animatable center\r\n, center: function(x, y) {\r\n    return this.cx(x).cy(y)\r\n  }\r\n  // Add animatable size\r\n, size: function(width, height) {\r\n    if (this.target() instanceof SVG.Text) {\r\n      // animate font size for Text elements\r\n      this.attr('font-size', width)\r\n\r\n    } else {\r\n      // animate bbox based size for all other elements\r\n      var box\r\n\r\n      if(!width || !height){\r\n        box = this.target().bbox()\r\n      }\r\n\r\n      if(!width){\r\n        width = box.width / box.height  * height\r\n      }\r\n\r\n      if(!height){\r\n        height = box.height / box.width  * width\r\n      }\r\n\r\n      this.add('width' , new SVG.Number(width))\r\n          .add('height', new SVG.Number(height))\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable plot\r\n, plot: function() {\r\n    // We use arguments here since SVG.Line's plot method can be passed 4 parameters\r\n    return this.add('plot', arguments.length > 1 ? [].slice.call(arguments) : arguments[0])\r\n  }\r\n  // Add leading method\r\n, leading: function(value) {\r\n    return this.target().leading ?\r\n      this.add('leading', new SVG.Number(value)) :\r\n      this\r\n  }\r\n  // Add animatable viewbox\r\n, viewbox: function(x, y, width, height) {\r\n    if (this.target() instanceof SVG.Container) {\r\n      this.add('viewbox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n    return this\r\n  }\r\n, update: function(o) {\r\n    if (this.target() instanceof SVG.Stop) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        return this.update({\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        })\r\n      }\r\n\r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', o.offset)\r\n    }\r\n\r\n    return this\r\n  }\r\n})\r\n\nSVG.Box = SVG.invent({\r\n  create: function(x, y, width, height) {\r\n    if (typeof x == 'object' && !(x instanceof SVG.Element)) {\r\n      // chromes getBoundingClientRect has no x and y property\r\n      return SVG.Box.call(this, x.left != null ? x.left : x.x , x.top != null ? x.top : x.y, x.width, x.height)\r\n    } else if (arguments.length == 4) {\r\n      this.x = x\r\n      this.y = y\r\n      this.width = width\r\n      this.height = height\r\n\r\n    }\r\n\r\n    // add center, right, bottom...\r\n    fullBox(this)\r\n  }\r\n, extend: {\r\n    // Merge rect box with another, return a new instance\r\n    merge: function(box) {\r\n      var b = new this.constructor()\r\n\r\n      // merge boxes\r\n      b.x      = Math.min(this.x, box.x)\r\n      b.y      = Math.min(this.y, box.y)\r\n      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x\r\n      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y\r\n\r\n      return fullBox(b)\r\n    }\r\n\r\n  , transform: function(m) {\r\n      var xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, p\r\n\r\n      var pts = [\r\n        new SVG.Point(this.x, this.y),\r\n        new SVG.Point(this.x2, this.y),\r\n        new SVG.Point(this.x, this.y2),\r\n        new SVG.Point(this.x2, this.y2)\r\n      ]\r\n\r\n      pts.forEach(function(p) {\r\n        p = p.transform(m)\r\n        xMin = Math.min(xMin,p.x)\r\n        xMax = Math.max(xMax,p.x)\r\n        yMin = Math.min(yMin,p.y)\r\n        yMax = Math.max(yMax,p.y)\r\n      })\r\n\r\n      bbox = new this.constructor()\r\n      bbox.x = xMin\r\n      bbox.width = xMax-xMin\r\n      bbox.y = yMin\r\n      bbox.height = yMax-yMin\r\n\r\n      fullBox(bbox)\r\n\r\n      return bbox\r\n    }\r\n  }\r\n})\r\n\r\nSVG.BBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    // get values if element is given\r\n    if (element instanceof SVG.Element) {\r\n      var box\r\n\r\n      // yes this is ugly, but Firefox can be a bitch when it comes to elements that are not yet rendered\r\n      try {\r\n\r\n        if (!document.documentElement.contains){\r\n          // This is IE - it does not support contains() for top-level SVGs\r\n          var topParent = element.node\r\n          while (topParent.parentNode){\r\n            topParent = topParent.parentNode\r\n          }\r\n          if (topParent != document) throw new Exception('Element not in the dom')\r\n        } else {\r\n          // the element is NOT in the dom, throw error\r\n          if(!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')\r\n        }\r\n\r\n        // find native bbox\r\n        box = element.node.getBBox()\r\n      } catch(e) {\r\n        if(element instanceof SVG.Shape){\r\n          var clone = element.clone(SVG.parser.draw).show()\r\n          box = clone.node.getBBox()\r\n          clone.remove()\r\n        }else{\r\n          box = {\r\n            x:      element.node.clientLeft\r\n          , y:      element.node.clientTop\r\n          , width:  element.node.clientWidth\r\n          , height: element.node.clientHeight\r\n          }\r\n        }\r\n      }\r\n\r\n      SVG.Box.call(this, box)\r\n    }\r\n\r\n  }\r\n\r\n  // Define ancestor\r\n, inherit: SVG.Box\r\n\r\n  // Define Parent\r\n, parent: SVG.Element\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get bounding box\r\n    bbox: function() {\r\n      return new SVG.BBox(this)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.BBox.prototype.constructor = SVG.BBox\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  tbox: function(){\r\n    console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.')\r\n    return this.rbox(this.doc())\r\n  }\r\n})\r\n\r\nSVG.RBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    if (element instanceof SVG.Element) {\r\n      SVG.Box.call(this, element.node.getBoundingClientRect())\r\n    }\r\n  }\r\n\r\n, inherit: SVG.Box\r\n\r\n  // define Parent\r\n, parent: SVG.Element\r\n\r\n, extend: {\r\n    addOffset: function() {\r\n      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\r\n      this.x += window.pageXOffset\r\n      this.y += window.pageYOffset\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get rect box\r\n    rbox: function(el) {\r\n      if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse())\r\n      return new SVG.RBox(this).addOffset()\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.RBox.prototype.constructor = SVG.RBox\r\n\nSVG.Matrix = SVG.invent({\r\n  // Initialize\r\n  create: function(source) {\r\n    var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0])\r\n\r\n    // ensure source as object\r\n    source = source instanceof SVG.Element ?\r\n      source.matrixify() :\r\n    typeof source === 'string' ?\r\n      arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) :\r\n    arguments.length == 6 ?\r\n      arrayToMatrix([].slice.call(arguments)) :\r\n    Array.isArray(source) ?\r\n      arrayToMatrix(source) :\r\n    typeof source === 'object' ?\r\n      source : base\r\n\r\n    // merge source\r\n    for (i = abcdef.length - 1; i >= 0; --i)\r\n      this[abcdef[i]] = source && typeof source[abcdef[i]] === 'number' ?\r\n        source[abcdef[i]] : base[abcdef[i]]\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Extract individual transformations\r\n    extract: function() {\r\n      // find delta transform points\r\n      var px    = deltaTransformPoint(this, 0, 1)\r\n        , py    = deltaTransformPoint(this, 1, 0)\r\n        , skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90\r\n\r\n      return {\r\n        // translation\r\n        x:        this.e\r\n      , y:        this.f\r\n      , transformedX:(this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , transformedY:(this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // skew\r\n      , skewX:    -skewX\r\n      , skewY:    180 / Math.PI * Math.atan2(py.y, py.x)\r\n        // scale\r\n      , scaleX:   Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , scaleY:   Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // rotation\r\n      , rotation: skewX\r\n      , a: this.a\r\n      , b: this.b\r\n      , c: this.c\r\n      , d: this.d\r\n      , e: this.e\r\n      , f: this.f\r\n      , matrix: new SVG.Matrix(this)\r\n      }\r\n    }\r\n    // Clone matrix\r\n  , clone: function() {\r\n      return new SVG.Matrix(this)\r\n    }\r\n    // Morph one matrix into another\r\n  , morph: function(matrix) {\r\n      // store new destination\r\n      this.destination = new SVG.Matrix(matrix)\r\n\r\n      return this\r\n    }\r\n    // Get morphed matrix at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var matrix = new SVG.Matrix({\r\n        a: this.a + (this.destination.a - this.a) * pos\r\n      , b: this.b + (this.destination.b - this.b) * pos\r\n      , c: this.c + (this.destination.c - this.c) * pos\r\n      , d: this.d + (this.destination.d - this.d) * pos\r\n      , e: this.e + (this.destination.e - this.e) * pos\r\n      , f: this.f + (this.destination.f - this.f) * pos\r\n      })\r\n\r\n      return matrix\r\n    }\r\n    // Multiplies by given matrix\r\n  , multiply: function(matrix) {\r\n      return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()))\r\n    }\r\n    // Inverses matrix\r\n  , inverse: function() {\r\n      return new SVG.Matrix(this.native().inverse())\r\n    }\r\n    // Translate matrix\r\n  , translate: function(x, y) {\r\n      return new SVG.Matrix(this.native().translate(x || 0, y || 0))\r\n    }\r\n    // Scale matrix\r\n  , scale: function(x, y, cx, cy) {\r\n      // support uniformal scale\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))\r\n    }\r\n    // Rotate matrix\r\n  , rotate: function(r, cx, cy) {\r\n      // convert degrees to radians\r\n      r = SVG.utils.radians(r)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))\r\n    }\r\n    // Flip matrix on x or y, at a given offset\r\n  , flip: function(a, o) {\r\n      o = typeof a == 'number' ? a : o\r\n      return a == 'x' ?\r\n          this.scale(-1, 1, o, 0) :\r\n        a == 'y' ?\r\n          this.scale(1, -1, 0, o) :\r\n          this.scale(-1, -1, o, o)\r\n    }\r\n    // Skew\r\n  , skew: function(x, y, cx, cy) {\r\n      // support uniformal skew\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      // convert degrees to radians\r\n      x = SVG.utils.radians(x)\r\n      y = SVG.utils.radians(y)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0))\r\n    }\r\n    // SkewX\r\n  , skewX: function(x, cx, cy) {\r\n      return this.skew(x, 0, cx, cy)\r\n    }\r\n    // SkewY\r\n  , skewY: function(y, cx, cy) {\r\n      return this.skew(0, y, cx, cy)\r\n    }\r\n    // Transform around a center point\r\n  , around: function(cx, cy, matrix) {\r\n      return this\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0))\r\n        .multiply(matrix)\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))\r\n    }\r\n    // Convert to native SVGMatrix\r\n  , native: function() {\r\n      // create new matrix\r\n      var matrix = SVG.parser.native.createSVGMatrix()\r\n\r\n      // update with current values\r\n      for (var i = abcdef.length - 1; i >= 0; i--)\r\n        matrix[abcdef[i]] = this[abcdef[i]]\r\n\r\n      return matrix\r\n    }\r\n    // Convert matrix to string\r\n  , toString: function() {\r\n      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')'\r\n    }\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Element\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Get current matrix\r\n    ctm: function() {\r\n      return new SVG.Matrix(this.node.getCTM())\r\n    },\r\n    // Get current screen matrix\r\n    screenCTM: function() {\r\n      /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\r\n         This is needed because FF does not return the transformation matrix\r\n         for the inner coordinate system when getScreenCTM() is called on nested svgs.\r\n         However all other Browsers do that */\r\n      if(this instanceof SVG.Nested) {\r\n        var rect = this.rect(1,1)\r\n        var m = rect.node.getScreenCTM()\r\n        rect.remove()\r\n        return new SVG.Matrix(m)\r\n      }\r\n      return new SVG.Matrix(this.node.getScreenCTM())\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\nSVG.Point = SVG.invent({\r\n  // Initialize\r\n  create: function(x,y) {\r\n    var i, source, base = {x:0, y:0}\r\n\r\n    // ensure source as object\r\n    source = Array.isArray(x) ?\r\n      {x:x[0], y:x[1]} :\r\n    typeof x === 'object' ?\r\n      {x:x.x, y:x.y} :\r\n    x != null ?\r\n      {x:x, y:(y != null ? y : x)} : base // If y has no value, then x is used has its value\r\n\r\n    // merge source\r\n    this.x = source.x\r\n    this.y = source.y\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Clone point\r\n    clone: function() {\r\n      return new SVG.Point(this)\r\n    }\r\n    // Morph one point into another\r\n  , morph: function(x, y) {\r\n      // store new destination\r\n      this.destination = new SVG.Point(x, y)\r\n\r\n      return this\r\n    }\r\n    // Get morphed point at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var point = new SVG.Point({\r\n        x: this.x + (this.destination.x - this.x) * pos\r\n      , y: this.y + (this.destination.y - this.y) * pos\r\n      })\r\n\r\n      return point\r\n    }\r\n    // Convert to native SVGPoint\r\n  , native: function() {\r\n      // create new point\r\n      var point = SVG.parser.native.createSVGPoint()\r\n\r\n      // update with current values\r\n      point.x = this.x\r\n      point.y = this.y\r\n\r\n      return point\r\n    }\r\n    // transform point with matrix\r\n  , transform: function(matrix) {\r\n      return new SVG.Point(this.native().matrixTransform(matrix.native()))\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n\r\n  // Get point\r\n  point: function(x, y) {\r\n    return new SVG.Point(x,y).transform(this.screenCTM().inverse());\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Element, {\r\n  // Set svg element attribute\r\n  attr: function(a, v, n) {\r\n    // act as full getter\r\n    if (a == null) {\r\n      // get an object of attributes\r\n      a = {}\r\n      v = this.node.attributes\r\n      for (n = v.length - 1; n >= 0; n--)\r\n        a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue\r\n\r\n      return a\r\n\r\n    } else if (typeof a == 'object') {\r\n      // apply every attribute individually if an object is passed\r\n      for (v in a) this.attr(v, a[v])\r\n\r\n    } else if (v === null) {\r\n        // remove value\r\n        this.node.removeAttribute(a)\r\n\r\n    } else if (v == null) {\r\n      // act as a getter if the first and only argument is not an object\r\n      v = this.node.getAttribute(a)\r\n      return v == null ?\r\n        SVG.defaults.attrs[a] :\r\n      SVG.regex.isNumber.test(v) ?\r\n        parseFloat(v) : v\r\n\r\n    } else {\r\n      // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\r\n      if (a == 'stroke-width')\r\n        this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)\r\n      else if (a == 'stroke')\r\n        this._stroke = v\r\n\r\n      // convert image fill and stroke to patterns\r\n      if (a == 'fill' || a == 'stroke') {\r\n        if (SVG.regex.isImage.test(v))\r\n          v = this.doc().defs().image(v, 0, 0)\r\n\r\n        if (v instanceof SVG.Image)\r\n          v = this.doc().defs().pattern(0, 0, function() {\r\n            this.add(v)\r\n          })\r\n      }\r\n\r\n      // ensure correct numeric values (also accepts NaN and Infinity)\r\n      if (typeof v === 'number')\r\n        v = new SVG.Number(v)\r\n\r\n      // ensure full hex color\r\n      else if (SVG.Color.isColor(v))\r\n        v = new SVG.Color(v)\r\n\r\n      // parse array values\r\n      else if (Array.isArray(v))\r\n        v = new SVG.Array(v)\r\n\r\n      // if the passed attribute is leading...\r\n      if (a == 'leading') {\r\n        // ... call the leading method instead\r\n        if (this.leading)\r\n          this.leading(v)\r\n      } else {\r\n        // set given attribute on node\r\n        typeof n === 'string' ?\r\n          this.node.setAttributeNS(n, a, v.toString()) :\r\n          this.node.setAttribute(a, v.toString())\r\n      }\r\n\r\n      // rebuild if required\r\n      if (this.rebuild && (a == 'font-size' || a == 'x'))\r\n        this.rebuild(a, v)\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.extend(SVG.Element, {\r\n  // Add transformations\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this\r\n      , matrix\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // get current matrix\r\n    matrix = new SVG.Matrix(target)\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.multiply(new SVG.Matrix(o)) :\r\n        // absolute\r\n        new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.rotate(o.rotation, o.cx, o.cy) :\r\n        // absolute\r\n        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      if (!relative) {\r\n        // absolute; multiply inversed values\r\n        var e = matrix.extract()\r\n        o.scaleX = o.scaleX * 1 / e.scaleX\r\n        o.scaleY = o.scaleY * 1 / e.scaleY\r\n      }\r\n\r\n      matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skew != null || o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0\r\n\r\n      if (!relative) {\r\n        // absolute; reset skew values\r\n        var e = matrix.extract()\r\n        matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse())\r\n      }\r\n\r\n      matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      matrix = matrix.flip(\r\n        o.flip\r\n      , o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      )\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      if (relative) {\r\n        // relative\r\n        matrix = matrix.translate(o.x, o.y)\r\n      } else {\r\n        // absolute\r\n        if (o.x != null) matrix.e = o.x\r\n        if (o.y != null) matrix.f = o.y\r\n      }\r\n    }\r\n\r\n    return this.attr('transform', matrix)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this.target()\r\n      , matrix\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = new SVG.Rotate(o.rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skewY != null ? o.skewY : 0\r\n\r\n      matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      matrix = new SVG.Matrix().flip(\r\n        o.flip\r\n      , o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      )\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      matrix = new SVG.Translate(o.x, o.y)\r\n    }\r\n\r\n    if(!matrix) return this\r\n\r\n    matrix.relative = relative\r\n\r\n    this.last().transforms.push(matrix)\r\n\r\n    return this._callStart()\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Reset all transformations\r\n  untransform: function() {\r\n    return this.attr('transform', null)\r\n  },\r\n  // merge the whole transformation chain into one matrix and returns it\r\n  matrixify: function() {\r\n\r\n    var matrix = (this.attr('transform') || '')\r\n      // split transformations\r\n      .split(SVG.regex.transforms).slice(0,-1).map(function(str){\r\n        // generate key => value pairs\r\n        var kv = str.trim().split('(')\r\n        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function(str){ return parseFloat(str) })]\r\n      })\r\n      // merge every transformation into one matrix\r\n      .reduce(function(matrix, transform){\r\n\r\n        if(transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))\r\n        return matrix[transform[0]].apply(matrix, transform[1])\r\n\r\n      }, new SVG.Matrix())\r\n\r\n    return matrix\r\n  },\r\n  // add an element to another parent without changing the visual representation on the screen\r\n  toParent: function(parent) {\r\n    if(this == parent) return this\r\n    var ctm = this.screenCTM()\r\n    var pCtm = parent.screenCTM().inverse()\r\n\r\n    this.addTo(parent).untransform().transform(pCtm.multiply(ctm))\r\n\r\n    return this\r\n  },\r\n  // same as above with parent equals root-svg\r\n  toDoc: function() {\r\n    return this.toParent(this.doc())\r\n  }\r\n\r\n})\r\n\r\nSVG.Transformation = SVG.invent({\r\n\r\n  create: function(source, inversed){\r\n\r\n    if(arguments.length > 1 && typeof inversed != 'boolean'){\r\n      return this.constructor.call(this, [].slice.call(arguments))\r\n    }\r\n\r\n    if(Array.isArray(source)){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[i]\r\n      }\r\n    } else if(typeof source == 'object'){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[this.arguments[i]]\r\n      }\r\n    }\r\n\r\n    this.inversed = false\r\n\r\n    if(inversed === true){\r\n      this.inversed = true\r\n    }\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    arguments: []\r\n  , method: ''\r\n\r\n  , at: function(pos){\r\n\r\n      var params = []\r\n\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        params.push(this[this.arguments[i]])\r\n      }\r\n\r\n      var m = this._undo || new SVG.Matrix()\r\n\r\n      m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos)\r\n\r\n      return this.inversed ? m.inverse() : m\r\n\r\n    }\r\n\r\n  , undo: function(o){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]]\r\n      }\r\n\r\n      // The method SVG.Matrix.extract which was used before calling this\r\n      // method to obtain a value for the parameter o doesn't return a cx and\r\n      // a cy so we use the ones that were provided to this object at its creation\r\n      o.cx = this.cx\r\n      o.cy = this.cy\r\n\r\n      this._undo = new SVG[capitalize(this.method)](o, true).at(1)\r\n\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.Translate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['transformedX', 'transformedY']\r\n  , method: 'translate'\r\n  }\r\n\r\n})\r\n\r\nSVG.Rotate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['rotation', 'cx', 'cy']\r\n  , method: 'rotate'\r\n  , at: function(pos){\r\n      var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy)\r\n      return this.inversed ? m.inverse() : m\r\n    }\r\n  , undo: function(o){\r\n      this._undo = o\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Scale = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['scaleX', 'scaleY', 'cx', 'cy']\r\n  , method: 'scale'\r\n  }\r\n\r\n})\r\n\r\nSVG.Skew = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['skewX', 'skewY', 'cx', 'cy']\r\n  , method: 'skew'\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Element, {\r\n  // Dynamic style generator\r\n  style: function(s, v) {\r\n    if (arguments.length == 0) {\r\n      // get full style\r\n      return this.node.style.cssText || ''\r\n\r\n    } else if (arguments.length < 2) {\r\n      // apply every style individually if an object is passed\r\n      if (typeof s == 'object') {\r\n        for (v in s) this.style(v, s[v])\r\n\r\n      } else if (SVG.regex.isCss.test(s)) {\r\n        // parse css string\r\n        s = s.split(/\\s*;\\s*/)\r\n          // filter out suffix ; and stuff like ;;\r\n          .filter(function(e) { return !!e })\r\n          .map(function(e){ return e.split(/\\s*:\\s*/) })\r\n\r\n        // apply every definition individually\r\n        while (v = s.pop()) {\r\n          this.style(v[0], v[1])\r\n        }\r\n      } else {\r\n        // act as a getter if the first and only argument is not an object\r\n        return this.node.style[camelCase(s)]\r\n      }\r\n\r\n    } else {\r\n      this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.Parent = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Returns all child elements\r\n    children: function() {\r\n      return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {\r\n        return SVG.adopt(node)\r\n      })\r\n    }\r\n    // Add given element at a position\r\n  , add: function(element, i) {\r\n      if (i == null)\r\n        this.node.appendChild(element.node)\r\n      else if (element.node != this.node.childNodes[i])\r\n        this.node.insertBefore(element.node, this.node.childNodes[i])\r\n\r\n      return this\r\n    }\r\n    // Basically does the same as `add()` but returns the added element instead\r\n  , put: function(element, i) {\r\n      this.add(element, i)\r\n      return element\r\n    }\r\n    // Checks if the given element is a child\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // Gets index of given element\r\n  , index: function(element) {\r\n      return [].slice.call(this.node.childNodes).indexOf(element.node)\r\n    }\r\n    // Get a element at the given index\r\n  , get: function(i) {\r\n      return SVG.adopt(this.node.childNodes[i])\r\n    }\r\n    // Get first child\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get the last child\r\n  , last: function() {\r\n      return this.get(this.node.childNodes.length - 1)\r\n    }\r\n    // Iterates over all children and invokes a given block\r\n  , each: function(block, deep) {\r\n      var i, il\r\n        , children = this.children()\r\n\r\n      for (i = 0, il = children.length; i < il; i++) {\r\n        if (children[i] instanceof SVG.Element)\r\n          block.apply(children[i], [i, children])\r\n\r\n        if (deep && (children[i] instanceof SVG.Container))\r\n          children[i].each(block, deep)\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Remove a given child\r\n  , removeElement: function(element) {\r\n      this.node.removeChild(element.node)\r\n\r\n      return this\r\n    }\r\n    // Remove all elements in this container\r\n  , clear: function() {\r\n      // remove children\r\n      while(this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // remove defs reference\r\n      delete this._defs\r\n\r\n      return this\r\n    }\r\n  , // Get defs\r\n    defs: function() {\r\n      return this.doc().defs()\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Parent, {\r\n\r\n  ungroup: function(parent, depth) {\r\n    if(depth === 0 || this instanceof SVG.Defs) return this\r\n\r\n    parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent))\r\n    depth = depth || Infinity\r\n\r\n    this.each(function(){\r\n      if(this instanceof SVG.Defs) return this\r\n      if(this instanceof SVG.Parent) return this.ungroup(parent, depth-1)\r\n      return this.toParent(parent)\r\n    })\r\n\r\n    this.node.firstChild || this.remove()\r\n\r\n    return this\r\n  },\r\n\r\n  flatten: function(parent, depth) {\r\n    return this.ungroup(parent, depth)\r\n  }\r\n\r\n})\nSVG.Container = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n})\n\r\nSVG.ViewBox = SVG.invent({\r\n\r\n  create: function(source) {\r\n    var i, base = [0, 0, 0, 0]\r\n\r\n    var x, y, width, height, box, view, we, he\r\n      , wm   = 1 // width multiplier\r\n      , hm   = 1 // height multiplier\r\n      , reg  = /[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?/gi\r\n\r\n    if(source instanceof SVG.Element){\r\n\r\n      we = source\r\n      he = source\r\n      view = (source.attr('viewBox') || '').match(reg)\r\n      box = source.bbox\r\n\r\n      // get dimensions of current node\r\n      width  = new SVG.Number(source.width())\r\n      height = new SVG.Number(source.height())\r\n\r\n      // find nearest non-percentual dimensions\r\n      while (width.unit == '%') {\r\n        wm *= width.value\r\n        width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width())\r\n        we = we.parent()\r\n      }\r\n      while (height.unit == '%') {\r\n        hm *= height.value\r\n        height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height())\r\n        he = he.parent()\r\n      }\r\n\r\n      // ensure defaults\r\n      this.x      = 0\r\n      this.y      = 0\r\n      this.width  = width  * wm\r\n      this.height = height * hm\r\n      this.zoom   = 1\r\n\r\n      if (view) {\r\n        // get width and height from viewbox\r\n        x      = parseFloat(view[0])\r\n        y      = parseFloat(view[1])\r\n        width  = parseFloat(view[2])\r\n        height = parseFloat(view[3])\r\n\r\n        // calculate zoom accoring to viewbox\r\n        this.zoom = ((this.width / this.height) > (width / height)) ?\r\n          this.height / height :\r\n          this.width  / width\r\n\r\n        // calculate real pixel dimensions on parent SVG.Doc element\r\n        this.x      = x\r\n        this.y      = y\r\n        this.width  = width\r\n        this.height = height\r\n\r\n      }\r\n\r\n    }else{\r\n\r\n      // ensure source as object\r\n      source = typeof source === 'string' ?\r\n        source.match(reg).map(function(el){ return parseFloat(el) }) :\r\n      Array.isArray(source) ?\r\n        source :\r\n      typeof source == 'object' ?\r\n        [source.x, source.y, source.width, source.height] :\r\n      arguments.length == 4 ?\r\n        [].slice.call(arguments) :\r\n        base\r\n\r\n      this.x = source[0]\r\n      this.y = source[1]\r\n      this.width = source[2]\r\n      this.height = source[3]\r\n    }\r\n\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    toString: function() {\r\n      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height\r\n    }\r\n  , morph: function(x, y, width, height){\r\n      this.destination = new SVG.ViewBox(x, y, width, height)\r\n      return this\r\n    }\r\n\r\n  , at: function(pos) {\r\n\r\n      if(!this.destination) return this\r\n\r\n      return new SVG.ViewBox([\r\n          this.x + (this.destination.x - this.x) * pos\r\n        , this.y + (this.destination.y - this.y) * pos\r\n        , this.width + (this.destination.width - this.width) * pos\r\n        , this.height + (this.destination.height - this.height) * pos\r\n      ])\r\n\r\n    }\r\n\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Container\r\n\r\n  // Add parent method\r\n, construct: {\r\n\r\n    // get/set viewbox\r\n    viewbox: function(x, y, width, height) {\r\n      if (arguments.length == 0)\r\n        // act as a getter if there are no arguments\r\n        return new SVG.ViewBox(this)\r\n\r\n      // otherwise act as a setter\r\n      return this.attr('viewBox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n  }\r\n\r\n})\n// Add events to elements\r\n;[  'click'\r\n  , 'dblclick'\r\n  , 'mousedown'\r\n  , 'mouseup'\r\n  , 'mouseover'\r\n  , 'mouseout'\r\n  , 'mousemove'\r\n  // , 'mouseenter' -> not supported by IE\r\n  // , 'mouseleave' -> not supported by IE\r\n  , 'touchstart'\r\n  , 'touchmove'\r\n  , 'touchleave'\r\n  , 'touchend'\r\n  , 'touchcancel' ].forEach(function(event) {\r\n\r\n  // add event to SVG.Element\r\n  SVG.Element.prototype[event] = function(f) {\r\n    // bind event to element rather than element node\r\n    SVG.on(this.node, event, f)\r\n    return this\r\n  }\r\n})\r\n\r\n// Initialize listeners stack\r\nSVG.listeners = []\r\nSVG.handlerMap = []\r\nSVG.listenerId = 0\r\n\r\n// Add event binder in the SVG namespace\r\nSVG.on = function(node, event, listener, binding) {\r\n  // create listener, get object-index\r\n  var l     = listener.bind(binding || node.instance || node)\r\n    , index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1\r\n    , ev    = event.split('.')[0]\r\n    , ns    = event.split('.')[1] || '*'\r\n\r\n\r\n  // ensure valid object\r\n  SVG.listeners[index]         = SVG.listeners[index]         || {}\r\n  SVG.listeners[index][ev]     = SVG.listeners[index][ev]     || {}\r\n  SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {}\r\n\r\n  if(!listener._svgjsListenerId)\r\n    listener._svgjsListenerId = ++SVG.listenerId\r\n\r\n  // reference listener\r\n  SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l\r\n\r\n  // add listener\r\n  node.addEventListener(ev, l, false)\r\n}\r\n\r\n// Add event unbinder in the SVG namespace\r\nSVG.off = function(node, event, listener) {\r\n  var index = SVG.handlerMap.indexOf(node)\r\n    , ev    = event && event.split('.')[0]\r\n    , ns    = event && event.split('.')[1]\r\n\r\n  if(index == -1) return\r\n\r\n  if (listener) {\r\n    if(typeof listener == 'function') listener = listener._svgjsListenerId\r\n    if(!listener) return\r\n\r\n    // remove listener reference\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {\r\n      // remove listener\r\n      node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false)\r\n\r\n      delete SVG.listeners[index][ev][ns || '*'][listener]\r\n    }\r\n\r\n  } else if (ns && ev) {\r\n    // remove all listeners for a namespaced event\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {\r\n      for (listener in SVG.listeners[index][ev][ns])\r\n        SVG.off(node, [ev, ns].join('.'), listener)\r\n\r\n      delete SVG.listeners[index][ev][ns]\r\n    }\r\n\r\n  } else if (ns){\r\n    // remove all listeners for a specific namespace\r\n    for(event in SVG.listeners[index]){\r\n        for(namespace in SVG.listeners[index][event]){\r\n            if(ns === namespace){\r\n                SVG.off(node, [event, ns].join('.'))\r\n            }\r\n        }\r\n    }\r\n\r\n  } else if (ev) {\r\n    // remove all listeners for the event\r\n    if (SVG.listeners[index][ev]) {\r\n      for (namespace in SVG.listeners[index][ev])\r\n        SVG.off(node, [ev, namespace].join('.'))\r\n\r\n      delete SVG.listeners[index][ev]\r\n    }\r\n\r\n  } else {\r\n    // remove all listeners on a given node\r\n    for (event in SVG.listeners[index])\r\n      SVG.off(node, event)\r\n\r\n    delete SVG.listeners[index]\r\n    delete SVG.handlerMap[index]\r\n\r\n  }\r\n}\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Bind given event to listener\r\n  on: function(event, listener, binding) {\r\n    SVG.on(this.node, event, listener, binding)\r\n\r\n    return this\r\n  }\r\n  // Unbind event from listener\r\n, off: function(event, listener) {\r\n    SVG.off(this.node, event, listener)\r\n\r\n    return this\r\n  }\r\n  // Fire given event\r\n, fire: function(event, data) {\r\n\r\n    // Dispatch event\r\n    if(event instanceof window.Event){\r\n        this.node.dispatchEvent(event)\r\n    }else{\r\n        this.node.dispatchEvent(event = new window.CustomEvent(event, {detail:data, cancelable: true}))\r\n    }\r\n\r\n    this._event = event\r\n    return this\r\n  }\r\n, event: function() {\r\n    return this._event\r\n  }\r\n})\n\r\nSVG.Defs = SVG.invent({\r\n  // Initialize node\r\n  create: 'defs'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n})\nSVG.G = SVG.invent({\r\n  // Initialize node\r\n  create: 'g'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.transform('x') : this.transform({ x: x - this.x() }, true)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.transform('y') : this.transform({ y: y - this.y() }, true)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2)\r\n    }\r\n  , gbox: function() {\r\n\r\n      var bbox  = this.bbox()\r\n        , trans = this.transform()\r\n\r\n      bbox.x  += trans.x\r\n      bbox.x2 += trans.x\r\n      bbox.cx += trans.x\r\n\r\n      bbox.y  += trans.y\r\n      bbox.y2 += trans.y\r\n      bbox.cy += trans.y\r\n\r\n      return bbox\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a group element\r\n    group: function() {\r\n      return this.put(new SVG.G)\r\n    }\r\n  }\r\n})\r\n\n// ### This module adds backward / forward functionality to elements.\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Get all siblings, including myself\r\n  siblings: function() {\r\n    return this.parent().children()\r\n  }\r\n  // Get the curent position siblings\r\n, position: function() {\r\n    return this.parent().index(this)\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, next: function() {\r\n    return this.siblings()[this.position() + 1]\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, previous: function() {\r\n    return this.siblings()[this.position() - 1]\r\n  }\r\n  // Send given element one step forward\r\n, forward: function() {\r\n    var i = this.position() + 1\r\n      , p = this.parent()\r\n\r\n    // move node one step forward\r\n    p.removeElement(this).add(this, i)\r\n\r\n    // make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element one step backward\r\n, backward: function() {\r\n    var i = this.position()\r\n\r\n    if (i > 0)\r\n      this.parent().removeElement(this).add(this, i - 1)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the front\r\n, front: function() {\r\n    var p = this.parent()\r\n\r\n    // Move node forward\r\n    p.node.appendChild(this.node)\r\n\r\n    // Make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the back\r\n, back: function() {\r\n    if (this.position() > 0)\r\n      this.parent().removeElement(this).add(this, 0)\r\n\r\n    return this\r\n  }\r\n  // Inserts a given element before the targeted element\r\n, before: function(element) {\r\n    element.remove()\r\n\r\n    var i = this.position()\r\n\r\n    this.parent().add(element, i)\r\n\r\n    return this\r\n  }\r\n  // Insters a given element after the targeted element\r\n, after: function(element) {\r\n    element.remove()\r\n\r\n    var i = this.position()\r\n\r\n    this.parent().add(element, i + 1)\r\n\r\n    return this\r\n  }\r\n\r\n})\nSVG.Mask = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('mask'))\r\n\r\n    // keep references to masked elements\r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unmask all masked elements and remove itself\r\n    remove: function() {\r\n      // unmask all targets\r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unmask()\r\n      this.targets = []\r\n\r\n      // remove mask from parent\r\n      this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create masking element\r\n    mask: function() {\r\n      return this.defs().put(new SVG.Mask)\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Distribute mask to svg element\r\n  maskWith: function(element) {\r\n    // use given mask or create a new one\r\n    this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element)\r\n\r\n    // store reverence on self in mask\r\n    this.masker.targets.push(this)\r\n\r\n    // apply mask\r\n    return this.attr('mask', 'url(\"#' + this.masker.attr('id') + '\")')\r\n  }\r\n  // Unmask element\r\n, unmask: function() {\r\n    delete this.masker\r\n    return this.attr('mask', null)\r\n  }\r\n\r\n})\r\n\nSVG.ClipPath = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('clipPath'))\r\n\r\n    // keep references to clipped elements\r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unclip all clipped elements and remove itself\r\n    remove: function() {\r\n      // unclip all targets\r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unclip()\r\n      this.targets = []\r\n\r\n      // remove clipPath from parent\r\n      this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create clipping element\r\n    clip: function() {\r\n      return this.defs().put(new SVG.ClipPath)\r\n    }\r\n  }\r\n})\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Distribute clipPath to svg element\r\n  clipWith: function(element) {\r\n    // use given clip or create a new one\r\n    this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element)\r\n\r\n    // store reverence on self in mask\r\n    this.clipper.targets.push(this)\r\n\r\n    // apply mask\r\n    return this.attr('clip-path', 'url(\"#' + this.clipper.attr('id') + '\")')\r\n  }\r\n  // Unclip element\r\n, unclip: function() {\r\n    delete this.clipper\r\n    return this.attr('clip-path', null)\r\n  }\r\n\r\n})\nSVG.Gradient = SVG.invent({\r\n  // Initialize node\r\n  create: function(type) {\r\n    this.constructor.call(this, SVG.create(type + 'Gradient'))\r\n\r\n    // store type\r\n    this.type = type\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add a color stop\r\n    at: function(offset, color, opacity) {\r\n      return this.put(new SVG.Stop).update(offset, color, opacity)\r\n    }\r\n    // Update gradient\r\n  , update: function(block) {\r\n      // remove all stops\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'gradientTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create gradient element in defs\r\n    gradient: function(type, block) {\r\n      return this.defs().gradient(type, block)\r\n    }\r\n  }\r\n})\r\n\r\n// Add animatable methods to both gradient and fx module\r\nSVG.extend(SVG.Gradient, SVG.FX, {\r\n  // From position\r\n  from: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :\r\n      this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })\r\n  }\r\n  // To position\r\n, to: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :\r\n      this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })\r\n  }\r\n})\r\n\r\n// Base gradient generation\r\nSVG.extend(SVG.Defs, {\r\n  // define gradient\r\n  gradient: function(type, block) {\r\n    return this.put(new SVG.Gradient(type)).update(block)\r\n  }\r\n\r\n})\r\n\r\nSVG.Stop = SVG.invent({\r\n  // Initialize node\r\n  create: 'stop'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // add color stops\r\n    update: function(o) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        o = {\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        }\r\n      }\r\n\r\n      // set attributes\r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.Pattern = SVG.invent({\r\n  // Initialize node\r\n  create: 'pattern'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Return the fill id\r\n    fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Update pattern by rebuilding\r\n  , update: function(block) {\r\n      // remove content\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'patternTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create pattern element in defs\r\n    pattern: function(width, height, block) {\r\n      return this.defs().pattern(width, height, block)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Define gradient\r\n  pattern: function(width, height, block) {\r\n    return this.put(new SVG.Pattern).update(block).attr({\r\n      x:            0\r\n    , y:            0\r\n    , width:        width\r\n    , height:       height\r\n    , patternUnits: 'userSpaceOnUse'\r\n    })\r\n  }\r\n\r\n})\nSVG.Doc = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    if (element) {\r\n      // ensure the presence of a dom element\r\n      element = typeof element == 'string' ?\r\n        document.getElementById(element) :\r\n        element\r\n\r\n      // If the target is an svg element, use that element as the main wrapper.\r\n      // This allows svg.js to work with svg documents as well.\r\n      if (element.nodeName == 'svg') {\r\n        this.constructor.call(this, element)\r\n      } else {\r\n        this.constructor.call(this, SVG.create('svg'))\r\n        element.appendChild(this.node)\r\n        this.size('100%', '100%')\r\n      }\r\n\r\n      // set svg element attributes and ensure defs node\r\n      this.namespace().defs()\r\n    }\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add namespaces\r\n    namespace: function() {\r\n      return this\r\n        .attr({ xmlns: SVG.ns, version: '1.1' })\r\n        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)\r\n        .attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns)\r\n    }\r\n    // Creates and returns defs element\r\n  , defs: function() {\r\n      if (!this._defs) {\r\n        var defs\r\n\r\n        // Find or create a defs element in this instance\r\n        if (defs = this.node.getElementsByTagName('defs')[0])\r\n          this._defs = SVG.adopt(defs)\r\n        else\r\n          this._defs = new SVG.Defs\r\n\r\n        // Make sure the defs node is at the end of the stack\r\n        this.node.appendChild(this._defs.node)\r\n      }\r\n\r\n      return this._defs\r\n    }\r\n    // custom parent method\r\n  , parent: function() {\r\n      return this.node.parentNode.nodeName == '#document' ? null : this.node.parentNode\r\n    }\r\n    // Fix for possible sub-pixel offset. See:\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=608812\r\n  , spof: function(spof) {\r\n      var pos = this.node.getScreenCTM()\r\n\r\n      if (pos)\r\n        this\r\n          .style('left', (-pos.e % 1) + 'px')\r\n          .style('top',  (-pos.f % 1) + 'px')\r\n\r\n      return this\r\n    }\r\n\r\n      // Removes the doc from the DOM\r\n  , remove: function() {\r\n      if(this.parent()) {\r\n        this.parent().removeChild(this.node);\r\n      }\r\n\r\n      return this;\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.Shape = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n})\n\r\nSVG.Bare = SVG.invent({\r\n  // Initialize\r\n  create: function(element, inherit) {\r\n    // construct element\r\n    this.constructor.call(this, SVG.create(element))\r\n\r\n    // inherit custom methods\r\n    if (inherit)\r\n      for (var method in inherit.prototype)\r\n        if (typeof inherit.prototype[method] === 'function')\r\n          this[method] = inherit.prototype[method]\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Insert some plain text\r\n    words: function(text) {\r\n      // remove contents\r\n      while (this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // create text node\r\n      this.node.appendChild(document.createTextNode(text))\r\n\r\n      return this\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Create an element that is not described by SVG.js\r\n  element: function(element, inherit) {\r\n    return this.put(new SVG.Bare(element, inherit))\r\n  }\r\n})\r\n\nSVG.Symbol = SVG.invent({\r\n  // Initialize node\r\n  create: 'symbol'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n, construct: {\r\n    // create symbol\r\n    symbol: function() {\r\n      return this.put(new SVG.Symbol)\r\n    }\r\n  }\r\n})\r\n\nSVG.Use = SVG.invent({\r\n  // Initialize node\r\n  create: 'use'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Use element as a reference\r\n    element: function(element, file) {\r\n      // Set lined element\r\n      return this.attr('href', (file || '') + '#' + element, SVG.xlink)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a use element\r\n    use: function(element, file) {\r\n      return this.put(new SVG.Use).element(element, file)\r\n    }\r\n  }\r\n})\nSVG.Rect = SVG.invent({\r\n  // Initialize node\r\n  create: 'rect'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a rect element\r\n    rect: function(width, height) {\r\n      return this.put(new SVG.Rect()).size(width, height)\r\n    }\r\n  }\r\n})\nSVG.Circle = SVG.invent({\r\n  // Initialize node\r\n  create: 'circle'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create circle element, based on ellipse\r\n    circle: function(size) {\r\n      return this.put(new SVG.Circle).rx(new SVG.Number(size).divide(2)).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Circle, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('r', rx)\r\n  }\r\n  // Alias radius x value\r\n, ry: function(ry) {\r\n    return this.rx(ry)\r\n  }\r\n})\r\n\r\nSVG.Ellipse = SVG.invent({\r\n  // Initialize node\r\n  create: 'ellipse'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create an ellipse\r\n    ellipse: function(width, height) {\r\n      return this.put(new SVG.Ellipse).size(width, height).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('rx', rx)\r\n  }\r\n  // Radius y value\r\n, ry: function(ry) {\r\n    return this.attr('ry', ry)\r\n  }\r\n})\r\n\r\n// Add common method\r\nSVG.extend(SVG.Circle, SVG.Ellipse, {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.attr('cx') : this.attr('cx', x)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.attr('cy') : this.attr('cy', y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.rx() * 2 : this.rx(new SVG.Number(width).divide(2))\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.ry() * 2 : this.ry(new SVG.Number(height).divide(2))\r\n    }\r\n    // Custom size function\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .rx(new SVG.Number(p.width).divide(2))\r\n        .ry(new SVG.Number(p.height).divide(2))\r\n    }\r\n})\nSVG.Line = SVG.invent({\r\n  // Initialize node\r\n  create: 'line'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Get array\r\n    array: function() {\r\n      return new SVG.PointArray([\r\n        [ this.attr('x1'), this.attr('y1') ]\r\n      , [ this.attr('x2'), this.attr('y2') ]\r\n      ])\r\n    }\r\n    // Overwrite native plot() method\r\n  , plot: function(x1, y1, x2, y2) {\r\n      if (x1 == null)\r\n        return this.array()\r\n      else if (typeof y1 !== 'undefined')\r\n        x1 = { x1: x1, y1: y1, x2: x2, y2: y2 }\r\n      else\r\n        x1 = new SVG.PointArray(x1).toLine()\r\n\r\n      return this.attr(x1)\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr(this.array().move(x, y).toLine())\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr(this.array().size(p.width, p.height).toLine())\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a line element\r\n    line: function(x1, y1, x2, y2) {\r\n      // make sure plot is called as a setter\r\n      // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray\r\n      return SVG.Line.prototype.plot.apply(\r\n        this.put(new SVG.Line)\r\n      , x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]\r\n      )\r\n    }\r\n  }\r\n})\r\n\nSVG.Polyline = SVG.invent({\r\n  // Initialize node\r\n  create: 'polyline'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polyline element\r\n    polyline: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polyline).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.Polygon = SVG.invent({\r\n  // Initialize node\r\n  create: 'polygon'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polygon element\r\n    polygon: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polygon).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\n// Add polygon-specific functions\r\nSVG.extend(SVG.Polyline, SVG.Polygon, {\r\n  // Get array\r\n  array: function() {\r\n    return this._array || (this._array = new SVG.PointArray(this.attr('points')))\r\n  }\r\n  // Plot new path\r\n, plot: function(p) {\r\n    return (p == null) ?\r\n      this.array() :\r\n      this.clear().attr('points', typeof p == 'string' ? p : (this._array = new SVG.PointArray(p)))\r\n  }\r\n  // Clear array cache\r\n, clear: function() {\r\n    delete this._array\r\n    return this\r\n  }\r\n  // Move by left top corner\r\n, move: function(x, y) {\r\n    return this.attr('points', this.array().move(x, y))\r\n  }\r\n  // Set element size to given width and height\r\n, size: function(width, height) {\r\n    var p = proportionalSize(this, width, height)\r\n\r\n    return this.attr('points', this.array().size(p.width, p.height))\r\n  }\r\n\r\n})\r\n\n// unify all point to point elements\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\r\n  // Define morphable array\r\n  morphArray:  SVG.PointArray\r\n  // Move by left top corner over x-axis\r\n, x: function(x) {\r\n    return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n  }\r\n  // Move by left top corner over y-axis\r\n, y: function(y) {\r\n    return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n  }\r\n  // Set width of element\r\n, width: function(width) {\r\n    var b = this.bbox()\r\n\r\n    return width == null ? b.width : this.size(width, b.height)\r\n  }\r\n  // Set height of element\r\n, height: function(height) {\r\n    var b = this.bbox()\r\n\r\n    return height == null ? b.height : this.size(b.width, height)\r\n  }\r\n})\nSVG.Path = SVG.invent({\r\n  // Initialize node\r\n  create: 'path'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Define morphable array\r\n    morphArray:  SVG.PathArray\r\n    // Get array\r\n  , array: function() {\r\n      return this._array || (this._array = new SVG.PathArray(this.attr('d')))\r\n    }\r\n    // Plot new path\r\n  , plot: function(d) {\r\n      return (d == null) ?\r\n        this.array() :\r\n        this.clear().attr('d', typeof d == 'string' ? d : (this._array = new SVG.PathArray(d)))\r\n    }\r\n    // Clear array cache\r\n  , clear: function() {\r\n      delete this._array\r\n      return this\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr('d', this.array().move(x, y))\r\n    }\r\n    // Move by left top corner over x-axis\r\n  , x: function(x) {\r\n      return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n    }\r\n    // Move by left top corner over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr('d', this.array().size(p.width, p.height))\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.bbox().width : this.size(width, this.bbox().height)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.bbox().height : this.size(this.bbox().width, height)\r\n    }\r\n\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped path element\r\n    path: function(d) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Path).plot(d || new SVG.PathArray)\r\n    }\r\n  }\r\n})\r\n\nSVG.Image = SVG.invent({\r\n  // Initialize node\r\n  create: 'image'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // (re)load image\r\n    load: function(url) {\r\n      if (!url) return this\r\n\r\n      var self = this\r\n        , img  = new window.Image()\r\n\r\n      // preload image\r\n      SVG.on(img, 'load', function() {\r\n        var p = self.parent(SVG.Pattern)\r\n\r\n        if(p === null) return\r\n\r\n        // ensure image size\r\n        if (self.width() == 0 && self.height() == 0)\r\n          self.size(img.width, img.height)\r\n\r\n        // ensure pattern size if not set\r\n        if (p && p.width() == 0 && p.height() == 0)\r\n          p.size(self.width(), self.height())\r\n\r\n        // callback\r\n        if (typeof self._loaded === 'function')\r\n          self._loaded.call(self, {\r\n            width:  img.width\r\n          , height: img.height\r\n          , ratio:  img.width / img.height\r\n          , url:    url\r\n          })\r\n      })\r\n\r\n      SVG.on(img, 'error', function(e){\r\n        if (typeof self._error === 'function'){\r\n            self._error.call(self, e)\r\n        }\r\n      })\r\n\r\n      return this.attr('href', (img.src = this.src = url), SVG.xlink)\r\n    }\r\n    // Add loaded callback\r\n  , loaded: function(loaded) {\r\n      this._loaded = loaded\r\n      return this\r\n    }\r\n\r\n  , error: function(error) {\r\n      this._error = error\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // create image element, load image and set its size\r\n    image: function(source, width, height) {\r\n      return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)\r\n    }\r\n  }\r\n\r\n})\nSVG.Text = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('text'))\r\n\r\n    this.dom.leading = new SVG.Number(1.3)    // store leading value for rebuilding\r\n    this._rebuild = true                      // enable automatic updating of dy values\r\n    this._build   = false                     // disable build mode for adding multiple lines\r\n\r\n    // set default font\r\n    this.attr('font-family', SVG.defaults.attrs['font-family'])\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      // act as getter\r\n      if (x == null)\r\n        return this.attr('x')\r\n\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      var oy = this.attr('y')\r\n        , o  = typeof oy === 'number' ? oy - this.bbox().y : 0\r\n\r\n      // act as getter\r\n      if (y == null)\r\n        return typeof oy === 'number' ? oy - o : oy\r\n\r\n      return this.attr('y', typeof y === 'number' ? y + o : y)\r\n    }\r\n    // Move center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)\r\n    }\r\n    // Move center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)\r\n    }\r\n    // Set the text content\r\n  , text: function(text) {\r\n      // act as getter\r\n      if (typeof text === 'undefined'){\r\n        var text = ''\r\n        var children = this.node.childNodes\r\n        for(var i = 0, len = children.length; i < len; ++i){\r\n\r\n          // add newline if its not the first child and newLined is set to true\r\n          if(i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true){\r\n            text += '\\n'\r\n          }\r\n\r\n          // add content of this node\r\n          text += children[i].textContent\r\n        }\r\n\r\n        return text\r\n      }\r\n\r\n      // remove existing content\r\n      this.clear().build(true)\r\n\r\n      if (typeof text === 'function') {\r\n        // call block\r\n        text.call(this, this)\r\n\r\n      } else {\r\n        // store text and make sure text is not blank\r\n        text = text.split('\\n')\r\n\r\n        // build new lines\r\n        for (var i = 0, il = text.length; i < il; i++)\r\n          this.tspan(text[i]).newLine()\r\n      }\r\n\r\n      // disable build mode and rebuild lines\r\n      return this.build(false).rebuild()\r\n    }\r\n    // Set font size\r\n  , size: function(size) {\r\n      return this.attr('font-size', size).rebuild()\r\n    }\r\n    // Set / get leading\r\n  , leading: function(value) {\r\n      // act as getter\r\n      if (value == null)\r\n        return this.dom.leading\r\n\r\n      // act as setter\r\n      this.dom.leading = new SVG.Number(value)\r\n\r\n      return this.rebuild()\r\n    }\r\n    // Get all the first level lines\r\n  , lines: function() {\r\n      var node = (this.textPath && this.textPath() || this).node\r\n\r\n      // filter tspans and map them to SVG.js instances\r\n      var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function(el){\r\n        return SVG.adopt(el)\r\n      })\r\n\r\n      // return an instance of SVG.set\r\n      return new SVG.Set(lines)\r\n    }\r\n    // Rebuild appearance type\r\n  , rebuild: function(rebuild) {\r\n      // store new rebuild flag if given\r\n      if (typeof rebuild == 'boolean')\r\n        this._rebuild = rebuild\r\n\r\n      // define position of all lines\r\n      if (this._rebuild) {\r\n        var self = this\r\n          , blankLineOffset = 0\r\n          , dy = this.dom.leading * new SVG.Number(this.attr('font-size'))\r\n\r\n        this.lines().each(function() {\r\n          if (this.dom.newLined) {\r\n            if (!self.textPath())\r\n              this.attr('x', self.attr('x'))\r\n            if(this.text() == '\\n') {\r\n              blankLineOffset += dy\r\n            }else{\r\n              this.attr('dy', dy + blankLineOffset)\r\n              blankLineOffset = 0\r\n            }\r\n          }\r\n        })\r\n\r\n        this.fire('rebuild')\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Enable / disable build mode\r\n  , build: function(build) {\r\n      this._build = !!build\r\n      return this\r\n    }\r\n    // overwrite method from parent to set data properly\r\n  , setData: function(o){\r\n      this.dom = o\r\n      this.dom.leading = new SVG.Number(o.leading || 1.3)\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create text element\r\n    text: function(text) {\r\n      return this.put(new SVG.Text).text(text)\r\n    }\r\n    // Create plain text element\r\n  , plain: function(text) {\r\n      return this.put(new SVG.Text).plain(text)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Tspan = SVG.invent({\r\n  // Initialize node\r\n  create: 'tspan'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set text content\r\n    text: function(text) {\r\n      if(text == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '')\r\n\r\n      typeof text === 'function' ? text.call(this, this) : this.plain(text)\r\n\r\n      return this\r\n    }\r\n    // Shortcut dx\r\n  , dx: function(dx) {\r\n      return this.attr('dx', dx)\r\n    }\r\n    // Shortcut dy\r\n  , dy: function(dy) {\r\n      return this.attr('dy', dy)\r\n    }\r\n    // Create new line\r\n  , newLine: function() {\r\n      // fetch text parent\r\n      var t = this.parent(SVG.Text)\r\n\r\n      // mark new line\r\n      this.dom.newLined = true\r\n\r\n      // apply new hyn\r\n      return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x())\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Text, SVG.Tspan, {\r\n  // Create plain text node\r\n  plain: function(text) {\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // create text node\r\n    this.node.appendChild(document.createTextNode(text))\r\n\r\n    return this\r\n  }\r\n  // Create a tspan\r\n, tspan: function(text) {\r\n    var node  = (this.textPath && this.textPath() || this).node\r\n      , tspan = new SVG.Tspan\r\n\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // add new tspan\r\n    node.appendChild(tspan.node)\r\n\r\n    return tspan.text(text)\r\n  }\r\n  // Clear all lines\r\n, clear: function() {\r\n    var node = (this.textPath && this.textPath() || this).node\r\n\r\n    // remove existing child nodes\r\n    while (node.hasChildNodes())\r\n      node.removeChild(node.lastChild)\r\n\r\n    return this\r\n  }\r\n  // Get length of text element\r\n, length: function() {\r\n    return this.node.getComputedTextLength()\r\n  }\r\n})\r\n\nSVG.TextPath = SVG.invent({\r\n  // Initialize node\r\n  create: 'textPath'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n  // Define parent class\r\n, parent: SVG.Text\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create path for text to run on\r\n    path: function(d) {\r\n      // create textPath element\r\n      var path  = new SVG.TextPath\r\n        , track = this.doc().defs().path(d)\r\n\r\n      // move lines to textpath\r\n      while (this.node.hasChildNodes())\r\n        path.node.appendChild(this.node.firstChild)\r\n\r\n      // add textPath element as child node\r\n      this.node.appendChild(path.node)\r\n\r\n      // link textPath to path and add content\r\n      path.attr('href', '#' + track, SVG.xlink)\r\n\r\n      return this\r\n    }\r\n    // return the array of the path track element\r\n  , array: function() {\r\n      var track = this.track()\r\n\r\n      return track ? track.array() : null\r\n    }\r\n    // Plot path if any\r\n  , plot: function(d) {\r\n      var track = this.track()\r\n        , pathArray = null\r\n\r\n      if (track) {\r\n        pathArray = track.plot(d)\r\n      }\r\n\r\n      return (d == null) ? pathArray : this\r\n    }\r\n    // Get the path track element\r\n  , track: function() {\r\n      var path = this.textPath()\r\n\r\n      if (path)\r\n        return path.reference('href')\r\n    }\r\n    // Get the textPath child\r\n  , textPath: function() {\r\n      if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath')\r\n        return SVG.adopt(this.node.firstChild)\r\n    }\r\n  }\r\n})\r\n\nSVG.Nested = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('svg'))\r\n\r\n    this.style('overflow', 'visible')\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create nested svg document\r\n    nested: function() {\r\n      return this.put(new SVG.Nested)\r\n    }\r\n  }\r\n})\nSVG.A = SVG.invent({\r\n  // Initialize node\r\n  create: 'a'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Link url\r\n    to: function(url) {\r\n      return this.attr('href', url, SVG.xlink)\r\n    }\r\n    // Link show attribute\r\n  , show: function(target) {\r\n      return this.attr('show', target, SVG.xlink)\r\n    }\r\n    // Link target attribute\r\n  , target: function(target) {\r\n      return this.attr('target', target)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a hyperlink element\r\n    link: function(url) {\r\n      return this.put(new SVG.A).to(url)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Create a hyperlink element\r\n  linkTo: function(url) {\r\n    var link = new SVG.A\r\n\r\n    if (typeof url == 'function')\r\n      url.call(link, link)\r\n    else\r\n      link.to(url)\r\n\r\n    return this.parent().put(link).put(this)\r\n  }\r\n\r\n})\nSVG.Marker = SVG.invent({\r\n  // Initialize node\r\n  create: 'marker'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set width of element\r\n    width: function(width) {\r\n      return this.attr('markerWidth', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('markerHeight', height)\r\n    }\r\n    // Set marker refX and refY\r\n  , ref: function(x, y) {\r\n      return this.attr('refX', x).attr('refY', y)\r\n    }\r\n    // Update marker\r\n  , update: function(block) {\r\n      // remove all content\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , toString: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    marker: function(width, height, block) {\r\n      // Create marker element in defs\r\n      return this.defs().marker(width, height, block)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Create marker\r\n  marker: function(width, height, block) {\r\n    // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\r\n    return this.put(new SVG.Marker)\r\n      .size(width, height)\r\n      .ref(width / 2, height / 2)\r\n      .viewbox(0, 0, width, height)\r\n      .attr('orient', 'auto')\r\n      .update(block)\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {\r\n  // Create and attach markers\r\n  marker: function(marker, width, height, block) {\r\n    var attr = ['marker']\r\n\r\n    // Build attribute name\r\n    if (marker != 'all') attr.push(marker)\r\n    attr = attr.join('-')\r\n\r\n    // Set marker attribute\r\n    marker = arguments[1] instanceof SVG.Marker ?\r\n      arguments[1] :\r\n      this.doc().marker(width, height, block)\r\n\r\n    return this.attr(attr, marker)\r\n  }\r\n\r\n})\n// Define list of available attributes for stroke and fill\r\nvar sugar = {\r\n  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']\r\n, fill:   ['color', 'opacity', 'rule']\r\n, prefix: function(t, a) {\r\n    return a == 'color' ? t : t + '-' + a\r\n  }\r\n}\r\n\r\n// Add sugar for fill and stroke\r\n;['fill', 'stroke'].forEach(function(m) {\r\n  var i, extension = {}\r\n\r\n  extension[m] = function(o) {\r\n    if (typeof o == 'undefined')\r\n      return this\r\n    if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))\r\n      this.attr(m, o)\r\n\r\n    else\r\n      // set all attributes from sugar.fill and sugar.stroke list\r\n      for (i = sugar[m].length - 1; i >= 0; i--)\r\n        if (o[sugar[m][i]] != null)\r\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])\r\n\r\n    return this\r\n  }\r\n\r\n  SVG.extend(SVG.Element, SVG.FX, extension)\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, SVG.FX, {\r\n  // Map rotation to transform\r\n  rotate: function(d, cx, cy) {\r\n    return this.transform({ rotation: d, cx: cx, cy: cy })\r\n  }\r\n  // Map skew to transform\r\n, skew: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ skew: x, cx: y, cy: cx }) :\r\n      this.transform({ skewX: x, skewY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map scale to transform\r\n, scale: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ scale: x, cx: y, cy: cx }) :\r\n      this.transform({ scaleX: x, scaleY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map translate to transform\r\n, translate: function(x, y) {\r\n    return this.transform({ x: x, y: y })\r\n  }\r\n  // Map flip to transform\r\n, flip: function(a, o) {\r\n    o = typeof a == 'number' ? a : o\r\n    return this.transform({ flip: a || 'both', offset: o })\r\n  }\r\n  // Map matrix to transform\r\n, matrix: function(m) {\r\n    return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m))\r\n  }\r\n  // Opacity\r\n, opacity: function(value) {\r\n    return this.attr('opacity', value)\r\n  }\r\n  // Relative move over x axis\r\n, dx: function(x) {\r\n    return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true)\r\n  }\r\n  // Relative move over y axis\r\n, dy: function(y) {\r\n    return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true)\r\n  }\r\n  // Relative move over x and y axes\r\n, dmove: function(x, y) {\r\n    return this.dx(x).dy(y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {\r\n  // Add x and y radius\r\n  radius: function(x, y) {\r\n    var type = (this._target || this).type;\r\n    return type == 'radial' || type == 'circle' ?\r\n      this.attr('r', new SVG.Number(x)) :\r\n      this.rx(x).ry(y == null ? x : y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Path, {\r\n  // Get path length\r\n  length: function() {\r\n    return this.node.getTotalLength()\r\n  }\r\n  // Get point at length\r\n, pointAt: function(length) {\r\n    return this.node.getPointAtLength(length)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {\r\n  // Set font\r\n  font: function(a, v) {\r\n    if (typeof a == 'object') {\r\n      for (v in a) this.font(v, a[v])\r\n    }\r\n\r\n    return a == 'leading' ?\r\n        this.leading(v) :\r\n      a == 'anchor' ?\r\n        this.attr('text-anchor', v) :\r\n      a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ?\r\n        this.attr('font-'+ a, v) :\r\n        this.attr(a, v)\r\n  }\r\n})\r\n\nSVG.Set = SVG.invent({\r\n  // Initialize\r\n  create: function(members) {\r\n    // Set initial state\r\n    Array.isArray(members) ? this.members = members : this.clear()\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add element to set\r\n    add: function() {\r\n      var i, il, elements = [].slice.call(arguments)\r\n\r\n      for (i = 0, il = elements.length; i < il; i++)\r\n        this.members.push(elements[i])\r\n\r\n      return this\r\n    }\r\n    // Remove element from set\r\n  , remove: function(element) {\r\n      var i = this.index(element)\r\n\r\n      // remove given child\r\n      if (i > -1)\r\n        this.members.splice(i, 1)\r\n\r\n      return this\r\n    }\r\n    // Iterate over all members\r\n  , each: function(block) {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        block.apply(this.members[i], [i, this.members])\r\n\r\n      return this\r\n    }\r\n    // Restore to defaults\r\n  , clear: function() {\r\n      // initialize store\r\n      this.members = []\r\n\r\n      return this\r\n    }\r\n    // Get the length of a set\r\n  , length: function() {\r\n      return this.members.length\r\n    }\r\n    // Checks if a given element is present in set\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // retuns index of given element in set\r\n  , index: function(element) {\r\n      return this.members.indexOf(element)\r\n    }\r\n    // Get member at given index\r\n  , get: function(i) {\r\n      return this.members[i]\r\n    }\r\n    // Get first member\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get last member\r\n  , last: function() {\r\n      return this.get(this.members.length - 1)\r\n    }\r\n    // Default value\r\n  , valueOf: function() {\r\n      return this.members\r\n    }\r\n    // Get the bounding box of all members included or empty box if set has no items\r\n  , bbox: function(){\r\n      // return an empty box of there are no members\r\n      if (this.members.length == 0)\r\n        return new SVG.RBox()\r\n\r\n      // get the first rbox and update the target bbox\r\n      var rbox = this.members[0].rbox(this.members[0].doc())\r\n\r\n      this.each(function() {\r\n        // user rbox for correct position and visual representation\r\n        rbox = rbox.merge(this.rbox(this.doc()))\r\n      })\r\n\r\n      return rbox\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a new set\r\n    set: function(members) {\r\n      return new SVG.Set(members)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.FX.Set = SVG.invent({\r\n  // Initialize node\r\n  create: function(set) {\r\n    // store reference to set\r\n    this.set = set\r\n  }\r\n\r\n})\r\n\r\n// Alias methods\r\nSVG.Set.inherit = function() {\r\n  var m\r\n    , methods = []\r\n\r\n  // gather shape methods\r\n  for(var m in SVG.Shape.prototype)\r\n    if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply shape aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        if (this.members[i] && typeof this.members[i][method] == 'function')\r\n          this.members[i][method].apply(this.members[i], arguments)\r\n\r\n      return method == 'animate' ? (this.fx || (this.fx = new SVG.FX.Set(this))) : this\r\n    }\r\n  })\r\n\r\n  // clear methods for the next round\r\n  methods = []\r\n\r\n  // gather fx methods\r\n  for(var m in SVG.FX.prototype)\r\n    if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply fx aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.FX.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.set.members.length; i < il; i++)\r\n        this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)\r\n\r\n      return this\r\n    }\r\n  })\r\n}\r\n\r\n\r\n\n\r\nSVG.extend(SVG.Element, {\r\n  // Store data values on svg nodes\r\n  data: function(a, v, r) {\r\n    if (typeof a == 'object') {\r\n      for (v in a)\r\n        this.data(v, a[v])\r\n\r\n    } else if (arguments.length < 2) {\r\n      try {\r\n        return JSON.parse(this.attr('data-' + a))\r\n      } catch(e) {\r\n        return this.attr('data-' + a)\r\n      }\r\n\r\n    } else {\r\n      this.attr(\r\n        'data-' + a\r\n      , v === null ?\r\n          null :\r\n        r === true || typeof v === 'string' || typeof v === 'number' ?\r\n          v :\r\n          JSON.stringify(v)\r\n      )\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.extend(SVG.Element, {\r\n  // Remember arbitrary data\r\n  remember: function(k, v) {\r\n    // remember every item in an object individually\r\n    if (typeof arguments[0] == 'object')\r\n      for (var v in k)\r\n        this.remember(v, k[v])\r\n\r\n    // retrieve memory\r\n    else if (arguments.length == 1)\r\n      return this.memory()[k]\r\n\r\n    // store memory\r\n    else\r\n      this.memory()[k] = v\r\n\r\n    return this\r\n  }\r\n\r\n  // Erase a given memory\r\n, forget: function() {\r\n    if (arguments.length == 0)\r\n      this._memory = {}\r\n    else\r\n      for (var i = arguments.length - 1; i >= 0; i--)\r\n        delete this.memory()[arguments[i]]\r\n\r\n    return this\r\n  }\r\n\r\n  // Initialize or return local memory object\r\n, memory: function() {\r\n    return this._memory || (this._memory = {})\r\n  }\r\n\r\n})\n// Method for getting an element by id\r\nSVG.get = function(id) {\r\n  var node = document.getElementById(idFromReference(id) || id)\r\n  return SVG.adopt(node)\r\n}\r\n\r\n// Select elements by query string\r\nSVG.select = function(query, parent) {\r\n  return new SVG.Set(\r\n    SVG.utils.map((parent || document).querySelectorAll(query), function(node) {\r\n      return SVG.adopt(node)\r\n    })\r\n  )\r\n}\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Scoped select method\r\n  select: function(query) {\r\n    return SVG.select(query, this.node)\r\n  }\r\n\r\n})\nfunction pathRegReplace(a, b, c, d) {\r\n  return c + d.replace(SVG.regex.dots, ' .')\r\n}\r\n\r\n// creates deep clone of array\r\nfunction array_clone(arr){\r\n  var clone = arr.slice(0)\r\n  for(var i = clone.length; i--;){\r\n    if(Array.isArray(clone[i])){\r\n      clone[i] = array_clone(clone[i])\r\n    }\r\n  }\r\n  return clone\r\n}\r\n\r\n// tests if a given element is instance of an object\r\nfunction is(el, obj){\r\n  return el instanceof obj\r\n}\r\n\r\n// tests if a given selector matches an element\r\nfunction matches(el, selector) {\r\n  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\r\n}\r\n\r\n// Convert dash-separated-string to camelCase\r\nfunction camelCase(s) {\r\n  return s.toLowerCase().replace(/-(.)/g, function(m, g) {\r\n    return g.toUpperCase()\r\n  })\r\n}\r\n\r\n// Capitalize first letter of a string\r\nfunction capitalize(s) {\r\n  return s.charAt(0).toUpperCase() + s.slice(1)\r\n}\r\n\r\n// Ensure to six-based hex\r\nfunction fullHex(hex) {\r\n  return hex.length == 4 ?\r\n    [ '#',\r\n      hex.substring(1, 2), hex.substring(1, 2)\r\n    , hex.substring(2, 3), hex.substring(2, 3)\r\n    , hex.substring(3, 4), hex.substring(3, 4)\r\n    ].join('') : hex\r\n}\r\n\r\n// Component to hex value\r\nfunction compToHex(comp) {\r\n  var hex = comp.toString(16)\r\n  return hex.length == 1 ? '0' + hex : hex\r\n}\r\n\r\n// Calculate proportional width and height values when necessary\r\nfunction proportionalSize(element, width, height) {\r\n  if (width == null || height == null) {\r\n    var box = element.bbox()\r\n\r\n    if (width == null)\r\n      width = box.width / box.height * height\r\n    else if (height == null)\r\n      height = box.height / box.width * width\r\n  }\r\n\r\n  return {\r\n    width:  width\r\n  , height: height\r\n  }\r\n}\r\n\r\n// Delta transform point\r\nfunction deltaTransformPoint(matrix, x, y) {\r\n  return {\r\n    x: x * matrix.a + y * matrix.c + 0\r\n  , y: x * matrix.b + y * matrix.d + 0\r\n  }\r\n}\r\n\r\n// Map matrix array to object\r\nfunction arrayToMatrix(a) {\r\n  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }\r\n}\r\n\r\n// Parse matrix if required\r\nfunction parseMatrix(matrix) {\r\n  if (!(matrix instanceof SVG.Matrix))\r\n    matrix = new SVG.Matrix(matrix)\r\n\r\n  return matrix\r\n}\r\n\r\n// Add centre point to transform object\r\nfunction ensureCentre(o, target) {\r\n  o.cx = o.cx == null ? target.bbox().cx : o.cx\r\n  o.cy = o.cy == null ? target.bbox().cy : o.cy\r\n}\r\n\r\n// PathArray Helpers\r\nfunction arrayToString(a) {\r\n  for (var i = 0, il = a.length, s = ''; i < il; i++) {\r\n    s += a[i][0]\r\n\r\n    if (a[i][1] != null) {\r\n      s += a[i][1]\r\n\r\n      if (a[i][2] != null) {\r\n        s += ' '\r\n        s += a[i][2]\r\n\r\n        if (a[i][3] != null) {\r\n          s += ' '\r\n          s += a[i][3]\r\n          s += ' '\r\n          s += a[i][4]\r\n\r\n          if (a[i][5] != null) {\r\n            s += ' '\r\n            s += a[i][5]\r\n            s += ' '\r\n            s += a[i][6]\r\n\r\n            if (a[i][7] != null) {\r\n              s += ' '\r\n              s += a[i][7]\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return s + ' '\r\n}\r\n\r\n// Deep new id assignment\r\nfunction assignNewId(node) {\r\n  // do the same for SVG child nodes as well\r\n  for (var i = node.childNodes.length - 1; i >= 0; i--)\r\n    if (node.childNodes[i] instanceof window.SVGElement)\r\n      assignNewId(node.childNodes[i])\r\n\r\n  return SVG.adopt(node).id(SVG.eid(node.nodeName))\r\n}\r\n\r\n// Add more bounding box properties\r\nfunction fullBox(b) {\r\n  if (b.x == null) {\r\n    b.x      = 0\r\n    b.y      = 0\r\n    b.width  = 0\r\n    b.height = 0\r\n  }\r\n\r\n  b.w  = b.width\r\n  b.h  = b.height\r\n  b.x2 = b.x + b.width\r\n  b.y2 = b.y + b.height\r\n  b.cx = b.x + b.width / 2\r\n  b.cy = b.y + b.height / 2\r\n\r\n  return b\r\n}\r\n\r\n// Get id from reference string\r\nfunction idFromReference(url) {\r\n  var m = url.toString().match(SVG.regex.reference)\r\n\r\n  if (m) return m[1]\r\n}\r\n\r\n// Create matrix array for looping\r\nvar abcdef = 'abcdef'.split('')\n// Add CustomEvent to IE9 and IE10\r\nif (typeof window.CustomEvent !== 'function') {\r\n  // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\r\n  var CustomEvent = function(event, options) {\r\n    options = options || { bubbles: false, cancelable: false, detail: undefined }\r\n    var e = document.createEvent('CustomEvent')\r\n    e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)\r\n    return e\r\n  }\r\n\r\n  CustomEvent.prototype = window.Event.prototype\r\n\r\n  window.CustomEvent = CustomEvent\r\n}\r\n\r\n// requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish\r\n(function(w) {\r\n  var lastTime = 0\r\n  var vendors = ['moz', 'webkit']\r\n\r\n  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n    w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']\r\n    w.cancelAnimationFrame  = w[vendors[x] + 'CancelAnimationFrame'] ||\r\n                              w[vendors[x] + 'CancelRequestAnimationFrame']\r\n  }\r\n\r\n  w.requestAnimationFrame = w.requestAnimationFrame ||\r\n    function(callback) {\r\n      var currTime = new Date().getTime()\r\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime))\r\n\r\n      var id = w.setTimeout(function() {\r\n        callback(currTime + timeToCall)\r\n      }, timeToCall)\r\n\r\n      lastTime = currTime + timeToCall\r\n      return id\r\n    }\r\n\r\n  w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;\r\n\r\n}(window))\r\n\r\nreturn SVG\r\n\r\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/svg.js/dist/svg.js\n// module id = 167\n// module chunks = 1 10","import BaseModule from './../Base.module';\nimport AppConfigParser from './../../services/AppConfigParser.service';\nimport ModuleLoaderConfig from './constants/ModuleLoader.const';\nimport ModuleLoader from 'module-loader';\nimport AnimationRepository from './../repositories/Animation.repository';\n\n/**\n * If SVG animations are present on the current page instance this module will be fetched async.\n * Once loaded the parser checks which animations are present on the current page and loads the animations from the Animation.repository.\n * Thus only SVG animations which are really present will be fetched by the browser, because they can become really complex.\n * @extends {BaseModule}\n */\nclass AnimationModule extends BaseModule {\n\n\tconstructor ( config ) {\n\n\t\tsuper( config );\n\t}\n\n\tinit () {\n\t\tsuper.init();\n\n\t\tModuleLoader.loadDependencies(\n\t\t\t\tAnimationRepository,\n\t\t\t\t[ AppConfigParser.getConfig( ModuleLoaderConfig.ANIMATIONS, this.node ) ]\n\t\t);\n\t}\n}\n\nexport default AnimationModule;\n\n\n\n// WEBPACK FOOTER //\n// ./js/modules/animation/Animation.module.js","/**\r\n *\r\n * @typedef {object} ModuleLoaderConfig\r\n * @property {string} SELECTOR\r\n * @property {string} ATTRIBUTE\r\n * @property {string} CONFIG_ATTRIBUTE\r\n */\r\n\r\nexport default {\r\n\t/**\r\n\t * @type ModuleLoaderConfig\r\n\t */\r\n\tANIMATIONS : {\r\n\t\tSELECTOR :         '[data-animation]',\r\n\t\tATTRIBUTE :        'data-animation',\r\n\t\tCONFIG_ATTRIBUTE : 'data-animation-config'\r\n\t}\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./js/modules/animation/constants/ModuleLoader.const.js","import BaseModuleRepository from './BaseModule.repository';\r\nimport * as SplitPoints from './splitpoints/Animation.splitpoints';\r\n\r\n/**\r\n * Repository providing access to SVG animation controllers which will be loaded on demand when a specific animation is present on the current page instance.\r\n * @extends {BaseModuleRepository}\r\n */\r\nclass AnimationRepository extends BaseModuleRepository {\r\n\r\n\t/**\r\n\t * @override\r\n\t * @returns {AnimationRepository} - repository instance\r\n\t */\r\n\tinit () {\r\n\t\tsuper.init();\r\n\r\n\t\tthis.registerHandlerForIdentifier(\r\n\t\t\tSplitPoints.burgerMenu,\r\n\t\t\t'svg-burger-menu'\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\nconst instance = new AnimationRepository().init();\r\n\r\nexport default instance;\r\n\n\n\n// WEBPACK FOOTER //\n// ./js/modules/repositories/Animation.repository.js","/* #if dynamic */\r\n\r\n/**\r\n * The burgerMenu splitpoint definiton\r\n * @param {function} resolve - call once the module is loaded\r\n * @param {function} reject - call when the load fails\r\n * @returns {void}\r\n */\r\nexport function burgerMenu ( resolve, reject ) {\r\n\r\n\trequire.ensure(\r\n\t\t\t[ 'jquery', 'svg.js' ],\r\n\t\t\t( require ) => {\r\n\t\t\t\tresolve( require( './../../animation/controller/BurgerMenu.controller' ).default );\r\n\t\t\t}, 'BurgerMenu'\r\n\t);\r\n}\r\n\r\n/* #end */\r\n\r\n// Temporary for static output versions: Disable split-points and require normally.\r\n\r\n/* eslint-disable no-redeclare */\r\n                \r\n   \r\n                                      \r\n                                                             \r\n                                                      \r\n                  \r\n   \r\n                                                \r\n\r\n                                                                                    \r\n \r\n          \r\n/* eslint-disable */\r\n\n\n\n// WEBPACK FOOTER //\n// ./js/modules/repositories/splitpoints/Animation.splitpoints.js"],"sourceRoot":""}